/// autogenerated analytical inverse kinematics code from ikfast program part of OpenRAVE
/// \author Rosen Diankov
///
/// Licensed under the Apache License, Version 2.0 (the "License");
/// you may not use this file except in compliance with the License.
/// You may obtain a copy of the License at
///     http://www.apache.org/licenses/LICENSE-2.0
/// 
/// Unless required by applicable law or agreed to in writing, software
/// distributed under the License is distributed on an "AS IS" BASIS,
/// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
/// See the License for the specific language governing permissions and
/// limitations under the License.
///
/// ikfast version 0x1000004a generated on 2024-07-03 11:56:02.542355
/// Generated using solver transform6d
/// To compile with gcc:
///     gcc -lstdc++ ik.cpp
/// To compile without any main function as a shared object (might need -llapack):
///     gcc -fPIC -lstdc++ -DIKFAST_NO_MAIN -DIKFAST_CLIBRARY -shared -Wl,-soname,libik.so -o libik.so ik.cpp

//// START
//// Make sure the version number matches.
//// You might need to install the dev version to get the header files.
//// sudo apt-get install python3.4-dev
#include "Python.h"
//// END

#define IKFAST_HAS_LIBRARY
#include "ikfast.h" // found inside share/openrave-X.Y/python/ikfast.h
using namespace ikfast;

// check if the included ikfast version matches what this file was compiled with
#define IKFAST_COMPILE_ASSERT(x) extern int __dummy[(int)x]
IKFAST_COMPILE_ASSERT(IKFAST_VERSION==0x1000004a);

#include <cmath>
#include <vector>
#include <limits>
#include <algorithm>
#include <complex>

#ifndef IKFAST_ASSERT
#include <stdexcept>
#include <sstream>
#include <iostream>

#ifdef _MSC_VER
#ifndef __PRETTY_FUNCTION__
#define __PRETTY_FUNCTION__ __FUNCDNAME__
#endif
#endif

#ifndef __PRETTY_FUNCTION__
#define __PRETTY_FUNCTION__ __func__
#endif

#define IKFAST_ASSERT(b) { if( !(b) ) { std::stringstream ss; ss << "ikfast exception: " << __FILE__ << ":" << __LINE__ << ": " <<__PRETTY_FUNCTION__ << ": Assertion '" << #b << "' failed"; throw std::runtime_error(ss.str()); } }

#endif

#if defined(_MSC_VER)
#define IKFAST_ALIGNED16(x) __declspec(align(16)) x
#else
#define IKFAST_ALIGNED16(x) x __attribute((aligned(16)))
#endif

#define IK2PI  ((IkReal)6.28318530717959)
#define IKPI  ((IkReal)3.14159265358979)
#define IKPI_2  ((IkReal)1.57079632679490)

#ifdef _MSC_VER
#ifndef isnan
#define isnan _isnan
#endif
#ifndef isinf
#define isinf _isinf
#endif
//#ifndef isfinite
//#define isfinite _isfinite
//#endif
#endif // _MSC_VER

// lapack routines
extern "C" {
  void dgetrf_ (const int* m, const int* n, double* a, const int* lda, int* ipiv, int* info);
  void zgetrf_ (const int* m, const int* n, std::complex<double>* a, const int* lda, int* ipiv, int* info);
  void dgetri_(const int* n, const double* a, const int* lda, int* ipiv, double* work, const int* lwork, int* info);
  void dgesv_ (const int* n, const int* nrhs, double* a, const int* lda, int* ipiv, double* b, const int* ldb, int* info);
  void dgetrs_(const char *trans, const int *n, const int *nrhs, double *a, const int *lda, int *ipiv, double *b, const int *ldb, int *info);
  void dgeev_(const char *jobvl, const char *jobvr, const int *n, double *a, const int *lda, double *wr, double *wi,double *vl, const int *ldvl, double *vr, const int *ldvr, double *work, const int *lwork, int *info);
}

using namespace std; // necessary to get std math routines

#ifdef IKFAST_NAMESPACE
namespace IKFAST_NAMESPACE {
#endif

inline float IKabs(float f) { return fabsf(f); }
inline double IKabs(double f) { return fabs(f); }

inline float IKsqr(float f) { return f*f; }
inline double IKsqr(double f) { return f*f; }

inline float IKlog(float f) { return logf(f); }
inline double IKlog(double f) { return log(f); }

// allows asin and acos to exceed 1. has to be smaller than thresholds used for branch conds and evaluation
#ifndef IKFAST_SINCOS_THRESH
#define IKFAST_SINCOS_THRESH ((IkReal)1e-7)
#endif

// used to check input to atan2 for degenerate cases. has to be smaller than thresholds used for branch conds and evaluation
#ifndef IKFAST_ATAN2_MAGTHRESH
#define IKFAST_ATAN2_MAGTHRESH ((IkReal)1e-7)
#endif

// minimum distance of separate solutions
#ifndef IKFAST_SOLUTION_THRESH
#define IKFAST_SOLUTION_THRESH ((IkReal)1e-6)
#endif

// there are checkpoints in ikfast that are evaluated to make sure they are 0. This threshold speicfies by how much they can deviate
#ifndef IKFAST_EVALCOND_THRESH
#define IKFAST_EVALCOND_THRESH ((IkReal)0.00001)
#endif


inline float IKasin(float f)
{
IKFAST_ASSERT( f > -1-IKFAST_SINCOS_THRESH && f < 1+IKFAST_SINCOS_THRESH ); // any more error implies something is wrong with the solver
if( f <= -1 ) return float(-IKPI_2);
else if( f >= 1 ) return float(IKPI_2);
return asinf(f);
}
inline double IKasin(double f)
{
IKFAST_ASSERT( f > -1-IKFAST_SINCOS_THRESH && f < 1+IKFAST_SINCOS_THRESH ); // any more error implies something is wrong with the solver
if( f <= -1 ) return -IKPI_2;
else if( f >= 1 ) return IKPI_2;
return asin(f);
}

// return positive value in [0,y)
inline float IKfmod(float x, float y)
{
    while(x < 0) {
        x += y;
    }
    return fmodf(x,y);
}

// return positive value in [0,y)
inline double IKfmod(double x, double y)
{
    while(x < 0) {
        x += y;
    }
    return fmod(x,y);
}

inline float IKacos(float f)
{
IKFAST_ASSERT( f > -1-IKFAST_SINCOS_THRESH && f < 1+IKFAST_SINCOS_THRESH ); // any more error implies something is wrong with the solver
if( f <= -1 ) return float(IKPI);
else if( f >= 1 ) return float(0);
return acosf(f);
}
inline double IKacos(double f)
{
IKFAST_ASSERT( f > -1-IKFAST_SINCOS_THRESH && f < 1+IKFAST_SINCOS_THRESH ); // any more error implies something is wrong with the solver
if( f <= -1 ) return IKPI;
else if( f >= 1 ) return 0;
return acos(f);
}
inline float IKsin(float f) { return sinf(f); }
inline double IKsin(double f) { return sin(f); }
inline float IKcos(float f) { return cosf(f); }
inline double IKcos(double f) { return cos(f); }
inline float IKtan(float f) { return tanf(f); }
inline double IKtan(double f) { return tan(f); }
inline float IKsqrt(float f) { if( f <= 0.0f ) return 0.0f; return sqrtf(f); }
inline double IKsqrt(double f) { if( f <= 0.0 ) return 0.0; return sqrt(f); }
inline float IKatan2Simple(float fy, float fx) {
    return atan2f(fy,fx);
}
inline float IKatan2(float fy, float fx) {
    if( isnan(fy) ) {
        IKFAST_ASSERT(!isnan(fx)); // if both are nan, probably wrong value will be returned
        return float(IKPI_2);
    }
    else if( isnan(fx) ) {
        return 0;
    }
    return atan2f(fy,fx);
}
inline double IKatan2Simple(double fy, double fx) {
    return atan2(fy,fx);
}
inline double IKatan2(double fy, double fx) {
    if( isnan(fy) ) {
        IKFAST_ASSERT(!isnan(fx)); // if both are nan, probably wrong value will be returned
        return IKPI_2;
    }
    else if( isnan(fx) ) {
        return 0;
    }
    return atan2(fy,fx);
}

template <typename T>
struct CheckValue
{
    T value;
    bool valid;
};

template <typename T>
inline CheckValue<T> IKatan2WithCheck(T fy, T fx, T epsilon)
{
    CheckValue<T> ret;
    ret.valid = false;
    ret.value = 0;
    if( !isnan(fy) && !isnan(fx) ) {
        if( IKabs(fy) >= IKFAST_ATAN2_MAGTHRESH || IKabs(fx) > IKFAST_ATAN2_MAGTHRESH ) {
            ret.value = IKatan2Simple(fy,fx);
            ret.valid = true;
        }
    }
    return ret;
}

inline float IKsign(float f) {
    if( f > 0 ) {
        return float(1);
    }
    else if( f < 0 ) {
        return float(-1);
    }
    return 0;
}

inline double IKsign(double f) {
    if( f > 0 ) {
        return 1.0;
    }
    else if( f < 0 ) {
        return -1.0;
    }
    return 0;
}

template <typename T>
inline CheckValue<T> IKPowWithIntegerCheck(T f, int n)
{
    CheckValue<T> ret;
    ret.valid = true;
    if( n == 0 ) {
        ret.value = 1.0;
        return ret;
    }
    else if( n == 1 )
    {
        ret.value = f;
        return ret;
    }
    else if( n < 0 )
    {
        if( f == 0 )
        {
            ret.valid = false;
            ret.value = (T)1.0e30;
            return ret;
        }
        if( n == -1 ) {
            ret.value = T(1.0)/f;
            return ret;
        }
    }

    int num = n > 0 ? n : -n;
    if( num == 2 ) {
        ret.value = f*f;
    }
    else if( num == 3 ) {
        ret.value = f*f*f;
    }
    else {
        ret.value = 1.0;
        while(num>0) {
            if( num & 1 ) {
                ret.value *= f;
            }
            num >>= 1;
            f *= f;
        }
    }
    
    if( n < 0 ) {
        ret.value = T(1.0)/ret.value;
    }
    return ret;
}

/// solves the forward kinematics equations.
/// \param pfree is an array specifying the free joints of the chain.
IKFAST_API void ComputeFk(const IkReal* j, IkReal* eetrans, IkReal* eerot) {
IkReal x0,x1,x2,x3,x4,x5,x6,x7,x8,x9,x10,x11,x12,x13,x14,x15,x16,x17,x18,x19,x20,x21,x22,x23,x24,x25,x26,x27,x28,x29,x30,x31,x32,x33,x34,x35,x36,x37,x38,x39,x40,x41,x42,x43,x44,x45,x46,x47,x48,x49,x50,x51,x52,x53,x54,x55,x56,x57,x58,x59,x60,x61,x62,x63,x64;
x0=IKcos(j[1]);
x1=IKcos(j[4]);
x2=IKcos(j[2]);
x3=IKsin(j[4]);
x4=IKsin(j[2]);
x5=IKsin(j[3]);
x6=IKcos(j[3]);
x7=IKsin(j[1]);
x8=IKcos(j[5]);
x9=IKsin(j[5]);
x10=IKsin(j[6]);
x11=IKcos(j[6]);
x12=IKsin(j[7]);
x13=IKcos(j[7]);
x14=((1.0)*x1);
x15=((1.0)*x3);
x16=((1.0)*x8);
x17=((0.30495)*x8);
x18=((0.30495)*x3);
x19=((0.30495)*x9);
x20=((1.0)*x9);
x21=((1.0)*x10);
x22=((0.30495)*x1);
x23=((1.0)*x11);
x24=((0.3215)*x1);
x25=(x2*x7);
x26=((-1.0)*x3);
x27=(x0*x2);
x28=(x2*x5);
x29=((-1.0)*x10);
x30=((-1.0)*x1);
x31=(x0*x5);
x32=((-1.0)*x11);
x33=(x5*x7);
x34=(x2*x6);
x35=(x0*x4*x6);
x36=(x4*x6*x7);
x37=(x15*x27);
x38=(x14*x34);
x39=(((x31*x4))+(((-1.0)*x6*x7)));
x40=((((-1.0)*x36))+x31);
x41=(((x0*x6))+((x33*x4)));
x42=((((-1.0)*x38))+((x3*x4)));
x43=(x38+(((-1.0)*x15*x4)));
x44=((((-1.0)*x35))+(((-1.0)*x33)));
x45=(x39*x9);
x46=(((x14*x4))+((x15*x34)));
x47=(x41*x9);
x48=(x41*x8);
x49=(x42*x8);
x50=(x39*x8);
x51=((1.0)*x44);
x52=(x43*x9);
x53=(x1*x44);
x54=(x49+((x28*x9)));
x55=((((-1.0)*x14*x40))+((x15*x25)));
x56=(((x25*x26))+((x1*x40)));
x57=(x53+((x26*x27)));
x58=(x56*x8);
x59=(x55*x9);
x60=(x57*x8);
x61=(x47+x58);
x62=(x45+x60);
x63=((((-1.0)*x23*x54))+(((-1.0)*x21*x46)));
x64=(((x32*x61))+((x29*((((x26*x40))+((x25*x30)))))));
eerot[0]=(((x11*((((x1*x27))+((x3*x44))))))+((x10*((x45+((x8*(((((-1.0)*x37))+x53)))))))));
eerot[1]=((((-1.0)*x12*((((x23*x62))+((x21*(((((-1.0)*x15*x44))+(((-1.0)*x14*x27))))))))))+((x13*((((x9*((x37+((x30*x44))))))+x50)))));
eerot[2]=(((x13*((((x32*x62))+((x29*((((x27*x30))+((x26*x44))))))))))+(((-1.0)*x12*((((x16*x39))+((x20*(((((-1.0)*x14*x44))+x37)))))))));
eetrans[0]=((0.03265)+((x10*((((x19*x39))+((x17*x57))))))+((x11*((((x22*x27))+((x18*x44))))))+(((0.117)*x0))+(((0.352)*x27))+((x3*(((((-0.3215)*x35))+(((-0.3215)*x33))))))+((x24*x27)));
eerot[3]=(((x11*((((x1*x25))+((x3*x40))))))+((x10*x61)));
eerot[4]=(((x12*x64))+((x13*((x48+x59)))));
eerot[5]=(((x13*x64))+((x12*(((((-1.0)*x20*x55))+(((-1.0)*x16*x41)))))));
eetrans[1]=(((x10*((((x19*x41))+((x17*x56))))))+((x3*(((((-0.3215)*x36))+(((0.3215)*x31))))))+(((0.117)*x7))+(((0.352)*x25))+((x11*((((x22*x25))+((x18*x40))))))+((x24*x25)));
eerot[6]=(((x10*x54))+(((-1.0)*x11*x46)));
eerot[7]=(((x12*x63))+((x13*((x52+((x28*x8)))))));
eerot[8]=(((x13*x63))+((x12*(((((-1.0)*x20*x43))+(((-1.0)*x16*x28)))))));
IkReal x65=((1.0)*x4);
eetrans[2]=((0.78601)+((x10*((((x19*x28))+((x17*x42))))))+(((-1.0)*x24*x65))+((x11*(((((-1.0)*x18*x34))+(((-1.0)*x22*x65))))))+(((-0.3215)*x3*x34))+(((-0.352)*x4))+j[0]);
}

IKFAST_API int GetNumFreeParameters() { return 2; }
IKFAST_API int* GetFreeParameters() { static int freeparams[] = {0, 3}; return freeparams; }
IKFAST_API int GetNumJoints() { return 8; }

IKFAST_API int GetIkRealSize() { return sizeof(IkReal); }

IKFAST_API int GetIkType() { return 0x67000001; }

class IKSolver {
public:
IkReal j9,cj9,sj9,htj9,j9mul,j10,cj10,sj10,htj10,j10mul,j12,cj12,sj12,htj12,j12mul,j13,cj13,sj13,htj13,j13mul,j14,cj14,sj14,htj14,j14mul,j15,cj15,sj15,htj15,j15mul,j5,cj5,sj5,htj5,j11,cj11,sj11,htj11,new_r00,r00,rxp0_0,new_r01,r01,rxp0_1,new_r02,r02,rxp0_2,new_r10,r10,rxp1_0,new_r11,r11,rxp1_1,new_r12,r12,rxp1_2,new_r20,r20,rxp2_0,new_r21,r21,rxp2_1,new_r22,r22,rxp2_2,new_px,px,npx,new_py,py,npy,new_pz,pz,npz,pp;
unsigned char _ij9[2], _nj9,_ij10[2], _nj10,_ij12[2], _nj12,_ij13[2], _nj13,_ij14[2], _nj14,_ij15[2], _nj15,_ij5[2], _nj5,_ij11[2], _nj11;

IkReal j100, cj100, sj100;
unsigned char _ij100[2], _nj100;
bool ComputeIk(const IkReal* eetrans, const IkReal* eerot, const IkReal* pfree, IkSolutionListBase<IkReal>& solutions) {
j9=numeric_limits<IkReal>::quiet_NaN(); _ij9[0] = -1; _ij9[1] = -1; _nj9 = -1; j10=numeric_limits<IkReal>::quiet_NaN(); _ij10[0] = -1; _ij10[1] = -1; _nj10 = -1; j12=numeric_limits<IkReal>::quiet_NaN(); _ij12[0] = -1; _ij12[1] = -1; _nj12 = -1; j13=numeric_limits<IkReal>::quiet_NaN(); _ij13[0] = -1; _ij13[1] = -1; _nj13 = -1; j14=numeric_limits<IkReal>::quiet_NaN(); _ij14[0] = -1; _ij14[1] = -1; _nj14 = -1; j15=numeric_limits<IkReal>::quiet_NaN(); _ij15[0] = -1; _ij15[1] = -1; _nj15 = -1;  _ij5[0] = -1; _ij5[1] = -1; _nj5 = 0;  _ij11[0] = -1; _ij11[1] = -1; _nj11 = 0; 
for(int dummyiter = 0; dummyiter < 1; ++dummyiter) {
    solutions.Clear();
j5=pfree[0]; cj5=cos(pfree[0]); sj5=sin(pfree[0]), htj5=tan(pfree[0]*0.5);
j11=pfree[1]; cj11=cos(pfree[1]); sj11=sin(pfree[1]), htj11=tan(pfree[1]*0.5);
r00 = eerot[0*3+0];
r01 = eerot[0*3+1];
r02 = eerot[0*3+2];
r10 = eerot[1*3+0];
r11 = eerot[1*3+1];
r12 = eerot[1*3+2];
r20 = eerot[2*3+0];
r21 = eerot[2*3+1];
r22 = eerot[2*3+2];
px = eetrans[0]; py = eetrans[1]; pz = eetrans[2];

new_r00=((-1.0)*r02);
new_r01=r01;
new_r02=r00;
new_px=((-0.03265)+px+(((-0.30495)*r00)));
new_r10=((-1.0)*r12);
new_r11=r11;
new_r12=r10;
new_py=((((-0.30495)*r10))+py);
new_r20=((-1.0)*r22);
new_r21=r21;
new_r22=r20;
new_pz=((-0.72601)+(((-0.30495)*r20))+pz+(((-1.0)*j5)));
r00 = new_r00; r01 = new_r01; r02 = new_r02; r10 = new_r10; r11 = new_r11; r12 = new_r12; r20 = new_r20; r21 = new_r21; r22 = new_r22; px = new_px; py = new_py; pz = new_pz;
IkReal x66=((1.0)*px);
IkReal x67=((1.0)*pz);
IkReal x68=((1.0)*py);
pp=((px*px)+(py*py)+(pz*pz));
npx=(((px*r00))+((py*r10))+((pz*r20)));
npy=(((px*r01))+((py*r11))+((pz*r21)));
npz=(((px*r02))+((py*r12))+((pz*r22)));
rxp0_0=((((-1.0)*r20*x68))+((pz*r10)));
rxp0_1=(((px*r20))+(((-1.0)*r00*x67)));
rxp0_2=((((-1.0)*r10*x66))+((py*r00)));
rxp1_0=((((-1.0)*r21*x68))+((pz*r11)));
rxp1_1=(((px*r21))+(((-1.0)*r01*x67)));
rxp1_2=((((-1.0)*r11*x66))+((py*r01)));
rxp2_0=(((pz*r12))+(((-1.0)*r22*x68)));
rxp2_1=(((px*r22))+(((-1.0)*r02*x67)));
rxp2_2=((((-1.0)*r12*x66))+((py*r02)));
IkReal op[8+1], zeror[8];
int numroots;
IkReal x69=((0.12)*pz);
IkReal x70=((0.234)*px);
IkReal x71=((1.0)*pp);
IkReal x72=((0.43631325)+x69);
IkReal x73=((-0.01635875)+x69);
IkReal x74=(x71+x70);
IkReal x75=((((-1.0)*x71))+x72+x70);
IkReal x76=((((-1.0)*x71))+x73+x70);
IkReal x77=((((-1.0)*x74))+x72);
IkReal x78=((((-1.0)*x74))+x73);
IkReal gconst0=x75;
IkReal gconst1=x76;
IkReal gconst2=x75;
IkReal gconst3=x76;
IkReal gconst4=x77;
IkReal gconst5=x78;
IkReal gconst6=x77;
IkReal gconst7=x78;
IkReal x79=py*py;
IkReal x80=sj11*sj11;
IkReal x81=px*px;
IkReal x82=((1.0)*gconst4);
IkReal x83=(gconst5*gconst7);
IkReal x84=(gconst0*gconst3);
IkReal x85=(gconst1*gconst2);
IkReal x86=((2.0)*gconst5);
IkReal x87=((1.0)*gconst0);
IkReal x88=(gconst1*gconst7);
IkReal x89=(gconst0*gconst6);
IkReal x90=(gconst1*gconst3);
IkReal x91=(gconst4*gconst7);
IkReal x92=((2.0)*gconst0);
IkReal x93=(gconst1*gconst6);
IkReal x94=(gconst0*gconst7);
IkReal x95=((2.0)*gconst4);
IkReal x96=(gconst3*gconst5);
IkReal x97=(gconst2*gconst5);
IkReal x98=(gconst3*gconst4);
IkReal x99=(gconst2*gconst4);
IkReal x100=(gconst4*gconst6);
IkReal x101=(gconst5*gconst6);
IkReal x102=(gconst0*gconst2);
IkReal x103=((0.819647758336)*px*py);
IkReal x104=(py*x80);
IkReal x105=(gconst6*x79);
IkReal x106=((4.0)*px*py);
IkReal x107=((4.0)*x81);
IkReal x108=(gconst2*x79);
IkReal x109=((2.0)*x79);
IkReal x110=((1.0)*x79);
IkReal x111=((0.413449)*x80);
IkReal x112=((0.826898)*x80);
IkReal x113=(x79*x91);
IkReal x114=(x101*x79);
IkReal x115=(x79*x97);
IkReal x116=(x79*x98);
IkReal x117=(x79*x94);
IkReal x118=(x79*x93);
IkReal x119=((0.081258731456994)*x104);
IkReal x120=(x79*x85);
IkReal x121=(x79*x84);
IkReal x122=(gconst6*x111);
IkReal x123=(x79*x80);
IkReal x124=(x110*x83);
IkReal x125=(x101*x111);
IkReal x126=(x105*x82);
IkReal x127=(x106*x99);
IkReal x128=(x106*x88);
IkReal x129=(x106*x96);
IkReal x130=(x106*x89);
IkReal x131=(x106*x98);
IkReal x132=(x106*x94);
IkReal x133=(x106*x97);
IkReal x134=(x106*x93);
IkReal x135=(x111*x93);
IkReal x136=(x110*x88);
IkReal x137=(x108*x82);
IkReal x138=(x111*x97);
IkReal x139=((0.090555253776)*x123);
IkReal x140=(x105*x87);
IkReal x141=(x110*x96);
IkReal x142=((0.386988264)*pp*x104);
IkReal x143=((0.090555253776)*px*x104);
IkReal x144=((0.04643859168)*pz*x104);
IkReal x145=(x108*x87);
IkReal x146=(x111*x85);
IkReal x147=(x110*x90);
IkReal x148=(x120+x121);
IkReal x149=(x113+x114);
IkReal x150=(x144+x119);
IkReal x151=(x145+x146+x147);
IkReal x152=(x126+x124+x125);
IkReal x153=(x117+x116+x115+x118);
IkReal x154=(x134+x131+x133+x132);
IkReal x155=(x130+x127+x128+x129);
IkReal x156=(x140+x141+x135+x137+x136+x139+x138);
op[0]=((((-1.0)*x152))+x149);
op[1]=((((-1.0)*x150))+(((-1.0)*x103))+x142+x143);
op[2]=((((-1.0)*x156))+((x107*x91))+(((-1.0)*x101*x112))+(((-1.0)*x100*x107))+(((-1.0)*x105*x86))+x153+((x109*x83))+(((-1.0)*x109*x91))+((x105*x95))+((x101*x107))+(((-1.0)*x107*x83)));
op[3]=((((-1.0)*x155))+(((-1.0)*x101*x106))+(((-0.193494132)*gconst2*x104))+x154+(((-0.386988264)*gconst5*x104))+((x106*x83))+(((-0.193494132)*gconst1*x104))+(((-1.0)*x106*x91))+(((-0.386988264)*gconst6*x104))+((x100*x106)));
op[4]=((((-1.0)*x107*x96))+(((-1.0)*x107*x99))+(((-0.181110507552)*x123))+(((-1.0)*x151))+(((-1.0)*x152))+((x107*x93))+((x107*x97))+((x107*x94))+((x107*x98))+x148+x149+(((-1.0)*x112*x93))+(((-1.0)*x112*x97))+((gconst3*x79*x86))+((x108*x95))+(((-1.0)*gconst3*x79*x95))+(((-1.0)*gconst7*x79*x92))+((x109*x88))+((x109*x89))+(((-1.0)*x108*x86))+(((-1.0)*x109*x93))+(((-1.0)*x107*x88))+(((-1.0)*x107*x89)));
op[5]=((((-0.193494132)*gconst5*x104))+(((-1.0)*x154))+(((-0.386988264)*gconst2*x104))+x155+((x106*x84))+((x106*x85))+(((-0.193494132)*gconst6*x104))+(((-1.0)*x102*x106))+(((-1.0)*x106*x90))+(((-0.386988264)*gconst1*x104)));
op[6]=((((-1.0)*x107*x90))+(((-1.0)*x156))+((x107*x85))+((x107*x84))+(((-1.0)*x112*x85))+x153+((x108*x92))+((x109*x90))+(((-1.0)*x102*x107))+(((-1.0)*x109*x85))+(((-1.0)*x109*x84)));
op[7]=((((-1.0)*x143))+(((-1.0)*x150))+x142+x103);
op[8]=((((-1.0)*x151))+x148);
polyroots8(op,zeror,numroots);
IkReal j9array[8], cj9array[8], sj9array[8], tempj9array[1];
int numsolutions = 0;
for(int ij9 = 0; ij9 < numroots; ++ij9)
{
IkReal htj9 = zeror[ij9];
tempj9array[0]=((2.0)*(atan(htj9)));
for(int kj9 = 0; kj9 < 1; ++kj9)
{
j9array[numsolutions] = tempj9array[kj9];
if( j9array[numsolutions] > IKPI )
{
    j9array[numsolutions]-=IK2PI;
}
else if( j9array[numsolutions] < -IKPI )
{
    j9array[numsolutions]+=IK2PI;
}
sj9array[numsolutions] = IKsin(j9array[numsolutions]);
cj9array[numsolutions] = IKcos(j9array[numsolutions]);
numsolutions++;
}
}
bool j9valid[8]={true,true,true,true,true,true,true,true};
_nj9 = 8;
for(int ij9 = 0; ij9 < numsolutions; ++ij9)
    {
if( !j9valid[ij9] )
{
    continue;
}
    j9 = j9array[ij9]; cj9 = cj9array[ij9]; sj9 = sj9array[ij9];
htj9 = IKtan(j9/2);

_ij9[0] = ij9; _ij9[1] = -1;
for(int iij9 = ij9+1; iij9 < numsolutions; ++iij9)
{
if( j9valid[iij9] && IKabs(cj9array[ij9]-cj9array[iij9]) < IKFAST_SOLUTION_THRESH && IKabs(sj9array[ij9]-sj9array[iij9]) < IKFAST_SOLUTION_THRESH )
{
    j9valid[iij9]=false; _ij9[1] = iij9; break; 
}
}
{
IkReal j10eval[2];
IkReal x157=cj9*cj9;
IkReal x158=py*py;
IkReal x159=px*px;
IkReal x160=pz*pz;
IkReal x161=((0.704)*sj11);
IkReal x162=((57.8402452426398)*sj11);
IkReal x163=((13.5346173867777)*sj11);
IkReal x164=(cj9*px);
IkReal x165=(py*sj9);
IkReal x166=(pz*sj11);
IkReal x167=((0.164736)*sj11);
IkReal x168=(x157*x161);
IkReal x169=(sj11*x164*x165);
j10eval[0]=((((115.68049048528)*x169))+(((-1.0)*x157*x158*x162))+(((-1.0)*x163*x165))+(((-1.0)*x163*x164))+sj11+(((-6.94082942911678)*x166))+((x158*x162))+((x160*x162))+((x157*x159*x162)));
j10eval[1]=IKsign(((((1.408)*x169))+(((-1.0)*x158*x168))+(((0.012171456)*sj11))+((x158*x161))+(((-0.08448)*x166))+(((-1.0)*x165*x167))+((x159*x168))+((x160*x161))+(((-1.0)*x164*x167))));
if( IKabs(j10eval[0]) < 0.0000010000000000  || IKabs(j10eval[1]) < 0.0000010000000000  )
{
{
IkReal j12eval[1];
j12eval[0]=sj11;
if( IKabs(j12eval[0]) < 0.0000010000000000  )
{
{
IkReal evalcond[1];
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(j11))), 6.28318530717959)));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j12array[2], cj12array[2], sj12array[2];
bool j12valid[2]={false};
_nj12 = 2;
cj12array[0]=((-0.927723605612894)+(((-0.530185211367171)*pz))+(((-1.03386116216598)*cj9*px))+(((4.41821009472642)*pp))+(((-1.03386116216598)*py*sj9)));
if( cj12array[0] >= -1-IKFAST_SINCOS_THRESH && cj12array[0] <= 1+IKFAST_SINCOS_THRESH )
{
    j12valid[0] = j12valid[1] = true;
    j12array[0] = IKacos(cj12array[0]);
    sj12array[0] = IKsin(j12array[0]);
    cj12array[1] = cj12array[0];
    j12array[1] = -j12array[0];
    sj12array[1] = -sj12array[0];
}
else if( isnan(cj12array[0]) )
{
    // probably any value will work
    j12valid[0] = true;
    cj12array[0] = 1; sj12array[0] = 0; j12array[0] = 0;
}
for(int ij12 = 0; ij12 < 2; ++ij12)
{
if( !j12valid[ij12] )
{
    continue;
}
_ij12[0] = ij12; _ij12[1] = -1;
for(int iij12 = ij12+1; iij12 < 2; ++iij12)
{
if( j12valid[iij12] && IKabs(cj12array[ij12]-cj12array[iij12]) < IKFAST_SOLUTION_THRESH && IKabs(sj12array[ij12]-sj12array[iij12]) < IKFAST_SOLUTION_THRESH )
{
    j12valid[iij12]=false; _ij12[1] = iij12; break; 
}
}
j12 = j12array[ij12]; cj12 = cj12array[ij12]; sj12 = sj12array[ij12];

{
IkReal j10eval[2];
sj11=0;
cj11=1.0;
j11=0;
j10eval[0]=((1.00411003994062)+cj12);
j10eval[1]=IKsign(((909065.0)+(((905344.0)*cj12))));
if( IKabs(j10eval[0]) < 0.0000010000000000  || IKabs(j10eval[1]) < 0.0000010000000000  )
{
{
IkReal j10eval[2];
sj11=0;
cj11=1.0;
j11=0;
IkReal x170=(pz*sj12);
IkReal x171=(cj9*px);
IkReal x172=(py*sj9);
IkReal x173=((643.0)*cj12);
IkReal x174=((16.6666666666667)*cj12);
j10eval[0]=((2.13499222395023)+(((-16.6666666666667)*x170))+sj12+(((-1.0)*x171*x174))+(((-18.2477967858994)*x171))+(((-18.2477967858994)*x172))+(((-1.0)*x172*x174))+(((1.95)*cj12)));
j10eval[1]=IKsign(((82.368)+(((75.231)*cj12))+(((38.58)*sj12))+(((-704.0)*x172))+(((-704.0)*x171))+(((-643.0)*x170))+(((-1.0)*x171*x173))+(((-1.0)*x172*x173))));
if( IKabs(j10eval[0]) < 0.0000010000000000  || IKabs(j10eval[1]) < 0.0000010000000000  )
{
{
IkReal j10eval[1];
sj11=0;
cj11=1.0;
j11=0;
IkReal x175=((16.6666666666667)*sj12);
j10eval[0]=((-1.09486780715397)+(((-1.0)*cj9*px*x175))+(((-1.0)*py*sj9*x175))+(((18.2477967858994)*pz))+(((16.6666666666667)*cj12*pz))+(((-1.0)*cj12))+(((1.95)*sj12)));
if( IKabs(j10eval[0]) < 0.0000010000000000  )
{
continue; // no branches [j10]

} else
{
{
IkReal j10array[1], cj10array[1], sj10array[1];
bool j10valid[1]={false};
_nj10 = 1;
IkReal x176=(cj9*px);
IkReal x177=((2000.0)*pz);
IkReal x178=(cj12*pz);
IkReal x179=((1286000.0)*sj12);
IkReal x180=((643.0)*sj12);
IkReal x181=(py*sj9);
CheckValue<IkReal> x182=IKPowWithIntegerCheck(((-84480.0)+(((1408000.0)*pz))+(((150462.0)*sj12))+(((-1.0)*x176*x179))+(((-1.0)*x179*x181))+(((-77160.0)*cj12))+(((1286000.0)*x178))),-1);
if(!x182.valid){
continue;
}
CheckValue<IkReal> x183=IKPowWithIntegerCheck(((-42.24)+(((-1.0)*x180*x181))+(((-1.0)*x176*x180))+(((643.0)*x178))+(((-38.58)*cj12))+(((704.0)*pz))+(((75.231)*sj12))),-1);
if(!x183.valid){
continue;
}
if( IKabs(((x182.value)*(((399049.0)+(((-4000000.0)*(pz*pz)))+(((-413449.0)*(cj12*cj12)))+(((480000.0)*pz)))))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((x183.value)*(((14.04)+((x177*x181))+(((-206.7245)*cj12*sj12))+((x176*x177))+(((-120.0)*x181))+(((-120.0)*x176))+(((-234.0)*pz))+(((-226.336)*sj12)))))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((x182.value)*(((399049.0)+(((-4000000.0)*(pz*pz)))+(((-413449.0)*(cj12*cj12)))+(((480000.0)*pz))))))+IKsqr(((x183.value)*(((14.04)+((x177*x181))+(((-206.7245)*cj12*sj12))+((x176*x177))+(((-120.0)*x181))+(((-120.0)*x176))+(((-234.0)*pz))+(((-226.336)*sj12))))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j10array[0]=IKatan2(((x182.value)*(((399049.0)+(((-4000000.0)*(pz*pz)))+(((-413449.0)*(cj12*cj12)))+(((480000.0)*pz))))), ((x183.value)*(((14.04)+((x177*x181))+(((-206.7245)*cj12*sj12))+((x176*x177))+(((-120.0)*x181))+(((-120.0)*x176))+(((-234.0)*pz))+(((-226.336)*sj12))))));
sj10array[0]=IKsin(j10array[0]);
cj10array[0]=IKcos(j10array[0]);
if( j10array[0] > IKPI )
{
    j10array[0]-=IK2PI;
}
else if( j10array[0] < -IKPI )
{    j10array[0]+=IK2PI;
}
j10valid[0] = true;
for(int ij10 = 0; ij10 < 1; ++ij10)
{
if( !j10valid[ij10] )
{
    continue;
}
_ij10[0] = ij10; _ij10[1] = -1;
for(int iij10 = ij10+1; iij10 < 1; ++iij10)
{
if( j10valid[iij10] && IKabs(cj10array[ij10]-cj10array[iij10]) < IKFAST_SOLUTION_THRESH && IKabs(sj10array[ij10]-sj10array[iij10]) < IKFAST_SOLUTION_THRESH )
{
    j10valid[iij10]=false; _ij10[1] = iij10; break; 
}
}
j10 = j10array[ij10]; cj10 = cj10array[ij10]; sj10 = sj10array[ij10];
{
IkReal evalcond[5];
IkReal x184=IKsin(j10);
IkReal x185=IKcos(j10);
IkReal x186=((0.3215)*cj12);
IkReal x187=(cj9*px);
IkReal x188=((0.3215)*sj12);
IkReal x189=(py*sj9);
IkReal x190=(pz*x184);
IkReal x191=((1.0)*x185);
IkReal x192=((0.704)*x185);
evalcond[0]=((-0.06)+((x185*x188))+(((0.352)*x184))+((x184*x186))+pz);
evalcond[1]=((0.117)+((x185*x186))+(((-1.0)*x189))+(((-1.0)*x187))+(((0.352)*x185))+(((-1.0)*x184*x188)));
evalcond[2]=(((pz*x185))+(((-0.06)*x185))+x188+(((-0.117)*x184))+((x184*x187))+((x184*x189)));
evalcond[3]=((0.352)+(((0.117)*x185))+(((-1.0)*x189*x191))+(((-0.06)*x184))+x190+x186+(((-1.0)*x187*x191)));
evalcond[4]=((-0.03783075)+(((0.12)*pz))+(((-0.704)*x190))+((x187*x192))+(((0.04224)*x184))+(((0.234)*x187))+(((0.234)*x189))+((x189*x192))+(((-1.0)*pp))+(((-0.082368)*x185)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}

}

} else
{
{
IkReal j10array[1], cj10array[1], sj10array[1];
bool j10valid[1]={false};
_nj10 = 1;
IkReal x651=(py*sj9);
IkReal x652=(cj9*px);
IkReal x653=((2000.0)*pz);
IkReal x654=((643.0)*cj12);
CheckValue<IkReal> x655=IKPowWithIntegerCheck(IKsign(((82.368)+(((75.231)*cj12))+(((-1.0)*x651*x654))+(((38.58)*sj12))+(((-704.0)*x652))+(((-704.0)*x651))+(((-1.0)*x652*x654))+(((-643.0)*pz*sj12)))),-1);
if(!x655.valid){
continue;
}
CheckValue<IkReal> x656 = IKatan2WithCheck(IkReal(((14.04)+((x652*x653))+(((-120.0)*x651))+(((-120.0)*x652))+(((-234.0)*pz))+((x651*x653))+(((206.7245)*cj12*sj12))+(((226.336)*sj12)))),IkReal(((-240.608)+((pz*x653))+(((-452.672)*cj12))+(((-206.7245)*(cj12*cj12)))+(((-240.0)*pz)))),IKFAST_ATAN2_MAGTHRESH);
if(!x656.valid){
continue;
}
j10array[0]=((-1.5707963267949)+(((1.5707963267949)*(x655.value)))+(x656.value));
sj10array[0]=IKsin(j10array[0]);
cj10array[0]=IKcos(j10array[0]);
if( j10array[0] > IKPI )
{
    j10array[0]-=IK2PI;
}
else if( j10array[0] < -IKPI )
{    j10array[0]+=IK2PI;
}
j10valid[0] = true;
for(int ij10 = 0; ij10 < 1; ++ij10)
{
if( !j10valid[ij10] )
{
    continue;
}
_ij10[0] = ij10; _ij10[1] = -1;
for(int iij10 = ij10+1; iij10 < 1; ++iij10)
{
if( j10valid[iij10] && IKabs(cj10array[ij10]-cj10array[iij10]) < IKFAST_SOLUTION_THRESH && IKabs(sj10array[ij10]-sj10array[iij10]) < IKFAST_SOLUTION_THRESH )
{
    j10valid[iij10]=false; _ij10[1] = iij10; break; 
}
}
j10 = j10array[ij10]; cj10 = cj10array[ij10]; sj10 = sj10array[ij10];
{
IkReal evalcond[5];
IkReal x657=IKsin(j10);
IkReal x658=IKcos(j10);
IkReal x659=((0.3215)*cj12);
IkReal x660=(cj9*px);
IkReal x661=((0.3215)*sj12);
IkReal x662=(py*sj9);
IkReal x663=(pz*x657);
IkReal x664=((1.0)*x658);
IkReal x665=((0.704)*x658);
evalcond[0]=((-0.06)+(((0.352)*x657))+pz+((x657*x659))+((x658*x661)));
evalcond[1]=((0.117)+(((0.352)*x658))+(((-1.0)*x657*x661))+(((-1.0)*x662))+(((-1.0)*x660))+((x658*x659)));
evalcond[2]=((((-0.06)*x658))+((x657*x662))+((x657*x660))+((pz*x658))+(((-0.117)*x657))+x661);
evalcond[3]=((0.352)+(((-0.06)*x657))+(((-1.0)*x662*x664))+(((0.117)*x658))+(((-1.0)*x660*x664))+x659+x663);
evalcond[4]=((-0.03783075)+(((0.12)*pz))+((x662*x665))+(((-1.0)*pp))+((x660*x665))+(((-0.082368)*x658))+(((-0.704)*x663))+(((0.234)*x660))+(((0.234)*x662))+(((0.04224)*x657)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}

}

} else
{
{
IkReal j10array[1], cj10array[1], sj10array[1];
bool j10valid[1]={false};
_nj10 = 1;
IkReal x666=(cj9*px);
IkReal x667=((1286000.0)*sj12);
IkReal x668=((1286000.0)*cj12);
IkReal x669=((1286000.0)*py*sj9);
CheckValue<IkReal> x670=IKPowWithIntegerCheck(IKsign(((909065.0)+(((905344.0)*cj12)))),-1);
if(!x670.valid){
continue;
}
CheckValue<IkReal> x671 = IKatan2WithCheck(IkReal(((84480.0)+(((-1.0)*py*sj9*x667))+(((150462.0)*sj12))+(((-1.0)*pz*x668))+(((77160.0)*cj12))+(((-1408000.0)*pz))+(((-1.0)*x666*x667)))),IkReal(((-164736.0)+((x666*x668))+(((77160.0)*sj12))+(((1408000.0)*x666))+(((-150462.0)*cj12))+(((-1.0)*pz*x667))+(((1408000.0)*py*sj9))+((py*sj9*x668)))),IKFAST_ATAN2_MAGTHRESH);
if(!x671.valid){
continue;
}
j10array[0]=((-1.5707963267949)+(((1.5707963267949)*(x670.value)))+(x671.value));
sj10array[0]=IKsin(j10array[0]);
cj10array[0]=IKcos(j10array[0]);
if( j10array[0] > IKPI )
{
    j10array[0]-=IK2PI;
}
else if( j10array[0] < -IKPI )
{    j10array[0]+=IK2PI;
}
j10valid[0] = true;
for(int ij10 = 0; ij10 < 1; ++ij10)
{
if( !j10valid[ij10] )
{
    continue;
}
_ij10[0] = ij10; _ij10[1] = -1;
for(int iij10 = ij10+1; iij10 < 1; ++iij10)
{
if( j10valid[iij10] && IKabs(cj10array[ij10]-cj10array[iij10]) < IKFAST_SOLUTION_THRESH && IKabs(sj10array[ij10]-sj10array[iij10]) < IKFAST_SOLUTION_THRESH )
{
    j10valid[iij10]=false; _ij10[1] = iij10; break; 
}
}
j10 = j10array[ij10]; cj10 = cj10array[ij10]; sj10 = sj10array[ij10];
{
IkReal evalcond[5];
IkReal x672=IKsin(j10);
IkReal x673=IKcos(j10);
IkReal x674=((0.3215)*cj12);
IkReal x675=(cj9*px);
IkReal x676=((0.3215)*sj12);
IkReal x677=(py*sj9);
IkReal x678=(pz*x672);
IkReal x679=((1.0)*x673);
IkReal x680=((0.704)*x673);
evalcond[0]=((-0.06)+((x673*x676))+((x672*x674))+pz+(((0.352)*x672)));
evalcond[1]=((0.117)+((x673*x674))+(((-1.0)*x677))+(((-1.0)*x675))+(((0.352)*x673))+(((-1.0)*x672*x676)));
evalcond[2]=(((pz*x673))+((x672*x675))+((x672*x677))+(((-0.117)*x672))+(((-0.06)*x673))+x676);
evalcond[3]=((0.352)+(((-1.0)*x675*x679))+(((0.117)*x673))+(((-0.06)*x672))+x678+x674+(((-1.0)*x677*x679)));
evalcond[4]=((-0.03783075)+(((0.12)*pz))+(((-0.082368)*x673))+((x677*x680))+(((0.04224)*x672))+(((-1.0)*pp))+(((-0.704)*x678))+((x675*x680))+(((0.234)*x675))+(((0.234)*x677)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}

}
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((-3.14159265358979)+j11)))), 6.28318530717959)));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j12array[2], cj12array[2], sj12array[2];
bool j12valid[2]={false};
_nj12 = 2;
cj12array[0]=((-0.927723605612894)+(((-0.530185211367171)*pz))+(((-1.03386116216598)*cj9*px))+(((4.41821009472642)*pp))+(((-1.03386116216598)*py*sj9)));
if( cj12array[0] >= -1-IKFAST_SINCOS_THRESH && cj12array[0] <= 1+IKFAST_SINCOS_THRESH )
{
    j12valid[0] = j12valid[1] = true;
    j12array[0] = IKacos(cj12array[0]);
    sj12array[0] = IKsin(j12array[0]);
    cj12array[1] = cj12array[0];
    j12array[1] = -j12array[0];
    sj12array[1] = -sj12array[0];
}
else if( isnan(cj12array[0]) )
{
    // probably any value will work
    j12valid[0] = true;
    cj12array[0] = 1; sj12array[0] = 0; j12array[0] = 0;
}
for(int ij12 = 0; ij12 < 2; ++ij12)
{
if( !j12valid[ij12] )
{
    continue;
}
_ij12[0] = ij12; _ij12[1] = -1;
for(int iij12 = ij12+1; iij12 < 2; ++iij12)
{
if( j12valid[iij12] && IKabs(cj12array[ij12]-cj12array[iij12]) < IKFAST_SOLUTION_THRESH && IKabs(sj12array[ij12]-sj12array[iij12]) < IKFAST_SOLUTION_THRESH )
{
    j12valid[iij12]=false; _ij12[1] = iij12; break; 
}
}
j12 = j12array[ij12]; cj12 = cj12array[ij12]; sj12 = sj12array[ij12];

{
IkReal j10eval[2];
sj11=0;
cj11=-1.0;
j11=3.14159265358979;
j10eval[0]=((-1.00411003994062)+(((-1.0)*cj12)));
j10eval[1]=IKsign(((-909065.0)+(((-905344.0)*cj12))));
if( IKabs(j10eval[0]) < 0.0000010000000000  || IKabs(j10eval[1]) < 0.0000010000000000  )
{
{
IkReal j10eval[2];
sj11=0;
cj11=-1.0;
j11=3.14159265358979;
IkReal x681=(pz*sj12);
IkReal x682=(cj9*px);
IkReal x683=(py*sj9);
IkReal x684=((643.0)*cj12);
IkReal x685=((16.6666666666667)*cj12);
j10eval[0]=((-2.13499222395023)+(((18.2477967858994)*x683))+(((18.2477967858994)*x682))+((x682*x685))+((x683*x685))+(((-16.6666666666667)*x681))+sj12+(((-1.95)*cj12)));
j10eval[1]=IKsign(((-82.368)+(((704.0)*x683))+(((704.0)*x682))+(((38.58)*sj12))+((x682*x684))+((x683*x684))+(((-643.0)*x681))+(((-75.231)*cj12))));
if( IKabs(j10eval[0]) < 0.0000010000000000  || IKabs(j10eval[1]) < 0.0000010000000000  )
{
{
IkReal j10eval[1];
sj11=0;
cj11=-1.0;
j11=3.14159265358979;
IkReal x686=((16.6666666666667)*sj12);
j10eval[0]=((-1.09486780715397)+((cj9*px*x686))+(((18.2477967858994)*pz))+(((16.6666666666667)*cj12*pz))+(((-1.95)*sj12))+(((-1.0)*cj12))+((py*sj9*x686)));
if( IKabs(j10eval[0]) < 0.0000010000000000  )
{
continue; // no branches [j10]

} else
{
{
IkReal j10array[1], cj10array[1], sj10array[1];
bool j10valid[1]={false};
_nj10 = 1;
IkReal x687=(cj9*px);
IkReal x688=((2000.0)*pz);
IkReal x689=(py*sj9);
IkReal x690=(cj12*pz);
IkReal x691=((643.0)*sj12);
IkReal x692=((1286000.0)*sj12);
CheckValue<IkReal> x693=IKPowWithIntegerCheck(((-84480.0)+(((-150462.0)*sj12))+(((1286000.0)*x690))+(((1408000.0)*pz))+((x687*x692))+((x689*x692))+(((-77160.0)*cj12))),-1);
if(!x693.valid){
continue;
}
CheckValue<IkReal> x694=IKPowWithIntegerCheck(((42.24)+(((-1.0)*x687*x691))+(((-643.0)*x690))+(((-704.0)*pz))+(((-1.0)*x689*x691))+(((75.231)*sj12))+(((38.58)*cj12))),-1);
if(!x694.valid){
continue;
}
if( IKabs(((x693.value)*(((399049.0)+(((-4000000.0)*(pz*pz)))+(((-413449.0)*(cj12*cj12)))+(((480000.0)*pz)))))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((x694.value)*(((-14.04)+(((-206.7245)*cj12*sj12))+(((-1.0)*x687*x688))+(((-1.0)*x688*x689))+(((120.0)*x689))+(((120.0)*x687))+(((234.0)*pz))+(((-226.336)*sj12)))))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((x693.value)*(((399049.0)+(((-4000000.0)*(pz*pz)))+(((-413449.0)*(cj12*cj12)))+(((480000.0)*pz))))))+IKsqr(((x694.value)*(((-14.04)+(((-206.7245)*cj12*sj12))+(((-1.0)*x687*x688))+(((-1.0)*x688*x689))+(((120.0)*x689))+(((120.0)*x687))+(((234.0)*pz))+(((-226.336)*sj12))))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j10array[0]=IKatan2(((x693.value)*(((399049.0)+(((-4000000.0)*(pz*pz)))+(((-413449.0)*(cj12*cj12)))+(((480000.0)*pz))))), ((x694.value)*(((-14.04)+(((-206.7245)*cj12*sj12))+(((-1.0)*x687*x688))+(((-1.0)*x688*x689))+(((120.0)*x689))+(((120.0)*x687))+(((234.0)*pz))+(((-226.336)*sj12))))));
sj10array[0]=IKsin(j10array[0]);
cj10array[0]=IKcos(j10array[0]);
if( j10array[0] > IKPI )
{
    j10array[0]-=IK2PI;
}
else if( j10array[0] < -IKPI )
{    j10array[0]+=IK2PI;
}
j10valid[0] = true;
for(int ij10 = 0; ij10 < 1; ++ij10)
{
if( !j10valid[ij10] )
{
    continue;
}
_ij10[0] = ij10; _ij10[1] = -1;
for(int iij10 = ij10+1; iij10 < 1; ++iij10)
{
if( j10valid[iij10] && IKabs(cj10array[ij10]-cj10array[iij10]) < IKFAST_SOLUTION_THRESH && IKabs(sj10array[ij10]-sj10array[iij10]) < IKFAST_SOLUTION_THRESH )
{
    j10valid[iij10]=false; _ij10[1] = iij10; break; 
}
}
j10 = j10array[ij10]; cj10 = cj10array[ij10]; sj10 = sj10array[ij10];
{
IkReal evalcond[5];
IkReal x695=IKsin(j10);
IkReal x696=IKcos(j10);
IkReal x697=((0.3215)*cj12);
IkReal x698=((0.3215)*sj12);
IkReal x699=(py*sj9);
IkReal x700=(cj9*px);
IkReal x701=(pz*x695);
IkReal x702=((1.0)*x696);
IkReal x703=((0.704)*x696);
IkReal x704=((1.0)*x695);
evalcond[0]=((-0.06)+((x695*x697))+(((-1.0)*x696*x698))+(((0.352)*x695))+pz);
evalcond[1]=((0.117)+((x695*x698))+((x696*x697))+(((0.352)*x696))+(((-1.0)*x700))+(((-1.0)*x699)));
evalcond[2]=((0.352)+(((-0.06)*x695))+(((-1.0)*x699*x702))+x697+x701+(((0.117)*x696))+(((-1.0)*x700*x702)));
evalcond[3]=((((-1.0)*pz*x702))+(((0.06)*x696))+(((-1.0)*x699*x704))+x698+(((0.117)*x695))+(((-1.0)*x700*x704)));
evalcond[4]=((-0.03783075)+(((0.12)*pz))+(((0.234)*x699))+((x700*x703))+(((0.234)*x700))+(((-1.0)*pp))+(((0.04224)*x695))+(((-0.082368)*x696))+(((-0.704)*x701))+((x699*x703)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}

}

} else
{
{
IkReal j10array[1], cj10array[1], sj10array[1];
bool j10valid[1]={false};
_nj10 = 1;
IkReal x705=(cj9*px);
IkReal x706=((2000.0)*pz);
IkReal x707=(py*sj9);
IkReal x708=((643.0)*cj12);
CheckValue<IkReal> x709 = IKatan2WithCheck(IkReal(((-14.04)+(((-1.0)*x706*x707))+(((120.0)*x705))+(((120.0)*x707))+(((234.0)*pz))+(((-1.0)*x705*x706))+(((206.7245)*cj12*sj12))+(((226.336)*sj12)))),IkReal(((240.608)+(((240.0)*pz))+(((-1.0)*pz*x706))+(((206.7245)*(cj12*cj12)))+(((452.672)*cj12)))),IKFAST_ATAN2_MAGTHRESH);
if(!x709.valid){
continue;
}
CheckValue<IkReal> x710=IKPowWithIntegerCheck(IKsign(((-82.368)+(((38.58)*sj12))+((x707*x708))+(((704.0)*x707))+(((704.0)*x705))+((x705*x708))+(((-643.0)*pz*sj12))+(((-75.231)*cj12)))),-1);
if(!x710.valid){
continue;
}
j10array[0]=((-1.5707963267949)+(x709.value)+(((1.5707963267949)*(x710.value))));
sj10array[0]=IKsin(j10array[0]);
cj10array[0]=IKcos(j10array[0]);
if( j10array[0] > IKPI )
{
    j10array[0]-=IK2PI;
}
else if( j10array[0] < -IKPI )
{    j10array[0]+=IK2PI;
}
j10valid[0] = true;
for(int ij10 = 0; ij10 < 1; ++ij10)
{
if( !j10valid[ij10] )
{
    continue;
}
_ij10[0] = ij10; _ij10[1] = -1;
for(int iij10 = ij10+1; iij10 < 1; ++iij10)
{
if( j10valid[iij10] && IKabs(cj10array[ij10]-cj10array[iij10]) < IKFAST_SOLUTION_THRESH && IKabs(sj10array[ij10]-sj10array[iij10]) < IKFAST_SOLUTION_THRESH )
{
    j10valid[iij10]=false; _ij10[1] = iij10; break; 
}
}
j10 = j10array[ij10]; cj10 = cj10array[ij10]; sj10 = sj10array[ij10];
{
IkReal evalcond[5];
IkReal x711=IKsin(j10);
IkReal x712=IKcos(j10);
IkReal x713=((0.3215)*cj12);
IkReal x714=((0.3215)*sj12);
IkReal x715=(py*sj9);
IkReal x716=(cj9*px);
IkReal x717=(pz*x711);
IkReal x718=((1.0)*x712);
IkReal x719=((0.704)*x712);
IkReal x720=((1.0)*x711);
evalcond[0]=((-0.06)+((x711*x713))+(((0.352)*x711))+pz+(((-1.0)*x712*x714)));
evalcond[1]=((0.117)+((x711*x714))+(((-1.0)*x716))+(((-1.0)*x715))+(((0.352)*x712))+((x712*x713)));
evalcond[2]=((0.352)+(((0.117)*x712))+(((-0.06)*x711))+(((-1.0)*x716*x718))+x713+x717+(((-1.0)*x715*x718)));
evalcond[3]=((((-1.0)*pz*x718))+(((0.117)*x711))+(((0.06)*x712))+(((-1.0)*x716*x720))+x714+(((-1.0)*x715*x720)));
evalcond[4]=((-0.03783075)+(((0.12)*pz))+((x715*x719))+(((0.234)*x715))+(((0.234)*x716))+(((-0.082368)*x712))+(((-1.0)*pp))+(((0.04224)*x711))+((x716*x719))+(((-0.704)*x717)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}

}

} else
{
{
IkReal j10array[1], cj10array[1], sj10array[1];
bool j10valid[1]={false};
_nj10 = 1;
IkReal x721=((1286000.0)*cj12);
IkReal x722=(cj9*px);
IkReal x723=(py*sj9);
IkReal x724=((1286000.0)*sj12);
CheckValue<IkReal> x725=IKPowWithIntegerCheck(IKsign(((-909065.0)+(((-905344.0)*cj12)))),-1);
if(!x725.valid){
continue;
}
CheckValue<IkReal> x726 = IKatan2WithCheck(IkReal(((-84480.0)+(((1408000.0)*pz))+(((-1.0)*x723*x724))+(((-1.0)*x722*x724))+(((150462.0)*sj12))+((pz*x721))+(((-77160.0)*cj12)))),IkReal(((164736.0)+(((77160.0)*sj12))+(((-1408000.0)*x722))+(((-1408000.0)*x723))+(((-1.0)*x721*x723))+(((-1.0)*x721*x722))+(((150462.0)*cj12))+(((-1.0)*pz*x724)))),IKFAST_ATAN2_MAGTHRESH);
if(!x726.valid){
continue;
}
j10array[0]=((-1.5707963267949)+(((1.5707963267949)*(x725.value)))+(x726.value));
sj10array[0]=IKsin(j10array[0]);
cj10array[0]=IKcos(j10array[0]);
if( j10array[0] > IKPI )
{
    j10array[0]-=IK2PI;
}
else if( j10array[0] < -IKPI )
{    j10array[0]+=IK2PI;
}
j10valid[0] = true;
for(int ij10 = 0; ij10 < 1; ++ij10)
{
if( !j10valid[ij10] )
{
    continue;
}
_ij10[0] = ij10; _ij10[1] = -1;
for(int iij10 = ij10+1; iij10 < 1; ++iij10)
{
if( j10valid[iij10] && IKabs(cj10array[ij10]-cj10array[iij10]) < IKFAST_SOLUTION_THRESH && IKabs(sj10array[ij10]-sj10array[iij10]) < IKFAST_SOLUTION_THRESH )
{
    j10valid[iij10]=false; _ij10[1] = iij10; break; 
}
}
j10 = j10array[ij10]; cj10 = cj10array[ij10]; sj10 = sj10array[ij10];
{
IkReal evalcond[5];
IkReal x727=IKsin(j10);
IkReal x728=IKcos(j10);
IkReal x729=((0.3215)*cj12);
IkReal x730=((0.3215)*sj12);
IkReal x731=(py*sj9);
IkReal x732=(cj9*px);
IkReal x733=(pz*x727);
IkReal x734=((1.0)*x728);
IkReal x735=((0.704)*x728);
IkReal x736=((1.0)*x727);
evalcond[0]=((-0.06)+((x727*x729))+(((0.352)*x727))+pz+(((-1.0)*x728*x730)));
evalcond[1]=((0.117)+((x727*x730))+((x728*x729))+(((0.352)*x728))+(((-1.0)*x732))+(((-1.0)*x731)));
evalcond[2]=((0.352)+(((-1.0)*x732*x734))+(((-1.0)*x731*x734))+(((0.117)*x728))+(((-0.06)*x727))+x733+x729);
evalcond[3]=((((-1.0)*x732*x736))+(((-1.0)*x731*x736))+(((0.117)*x727))+(((0.06)*x728))+x730+(((-1.0)*pz*x734)));
evalcond[4]=((-0.03783075)+(((0.12)*pz))+((x731*x735))+(((-0.082368)*x728))+(((0.234)*x732))+(((0.234)*x731))+(((0.04224)*x727))+(((-1.0)*pp))+(((-0.704)*x733))+((x732*x735)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}

}
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
if( 1 )
{
bgotonextstatement=false;
continue; // branch miss [j10, j12]

}
} while(0);
if( bgotonextstatement )
{
}
}
}
}

} else
{
{
IkReal j12array[1], cj12array[1], sj12array[1];
bool j12valid[1]={false};
_nj12 = 1;
CheckValue<IkReal> x737=IKPowWithIntegerCheck(sj11,-1);
if(!x737.valid){
continue;
}
if( IKabs(((0.0015552099533437)*(x737.value)*(((((-2000.0)*px*sj9))+(((2000.0)*cj9*py)))))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((-0.927723605612894)+(((-0.530185211367171)*pz))+(((-1.03386116216598)*cj9*px))+(((4.41821009472642)*pp))+(((-1.03386116216598)*py*sj9)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((0.0015552099533437)*(x737.value)*(((((-2000.0)*px*sj9))+(((2000.0)*cj9*py))))))+IKsqr(((-0.927723605612894)+(((-0.530185211367171)*pz))+(((-1.03386116216598)*cj9*px))+(((4.41821009472642)*pp))+(((-1.03386116216598)*py*sj9))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j12array[0]=IKatan2(((0.0015552099533437)*(x737.value)*(((((-2000.0)*px*sj9))+(((2000.0)*cj9*py))))), ((-0.927723605612894)+(((-0.530185211367171)*pz))+(((-1.03386116216598)*cj9*px))+(((4.41821009472642)*pp))+(((-1.03386116216598)*py*sj9))));
sj12array[0]=IKsin(j12array[0]);
cj12array[0]=IKcos(j12array[0]);
if( j12array[0] > IKPI )
{
    j12array[0]-=IK2PI;
}
else if( j12array[0] < -IKPI )
{    j12array[0]+=IK2PI;
}
j12valid[0] = true;
for(int ij12 = 0; ij12 < 1; ++ij12)
{
if( !j12valid[ij12] )
{
    continue;
}
_ij12[0] = ij12; _ij12[1] = -1;
for(int iij12 = ij12+1; iij12 < 1; ++iij12)
{
if( j12valid[iij12] && IKabs(cj12array[ij12]-cj12array[iij12]) < IKFAST_SOLUTION_THRESH && IKabs(sj12array[ij12]-sj12array[iij12]) < IKFAST_SOLUTION_THRESH )
{
    j12valid[iij12]=false; _ij12[1] = iij12; break; 
}
}
j12 = j12array[ij12]; cj12 = cj12array[ij12]; sj12 = sj12array[ij12];
{
IkReal evalcond[2];
evalcond[0]=((((0.3215)*sj11*(IKsin(j12))))+((px*sj9))+(((-1.0)*cj9*py)));
evalcond[1]=((0.20997725)+(((0.12)*pz))+(((0.226336)*(IKcos(j12))))+(((0.234)*cj9*px))+(((-1.0)*pp))+(((0.234)*py*sj9)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
IkReal j10eval[2];
IkReal x738=(cj9*px);
IkReal x739=(py*sj9);
IkReal x740=((643.0)*cj12);
IkReal x741=(cj11*sj12);
IkReal x742=((16.6666666666667)*cj12);
IkReal x743=(pz*x741);
j10eval[0]=((-2.13499222395023)+(((18.2477967858994)*x739))+(((18.2477967858994)*x738))+((x738*x742))+((x739*x742))+(((16.6666666666667)*x743))+(((-1.0)*x741))+(((-1.95)*cj12)));
j10eval[1]=IKsign(((-82.368)+((x738*x740))+((x739*x740))+(((-38.58)*x741))+(((643.0)*x743))+(((704.0)*x739))+(((704.0)*x738))+(((-75.231)*cj12))));
if( IKabs(j10eval[0]) < 0.0000010000000000  || IKabs(j10eval[1]) < 0.0000010000000000  )
{
{
IkReal j10eval[2];
IkReal x744=cj11*cj11;
IkReal x745=cj12*cj12;
IkReal x746=((413449.0)*x745);
j10eval[0]=((1.19873551514213)+(((-1.0)*x744*x745))+x744+x745+(((2.18973561430793)*cj12)));
j10eval[1]=IKsign(((495616.0)+(((905344.0)*cj12))+(((-1.0)*x744*x746))+x746+(((413449.0)*x744))));
if( IKabs(j10eval[0]) < 0.0000010000000000  || IKabs(j10eval[1]) < 0.0000010000000000  )
{
{
IkReal j10eval[2];
IkReal x747=(cj11*sj12);
IkReal x748=(cj9*px);
IkReal x749=(cj12*pz);
IkReal x750=(py*sj9*x747);
j10eval[0]=((-1.09486780715397)+(((1.95)*x747))+(((-16.6666666666667)*x750))+(((16.6666666666667)*x749))+(((18.2477967858994)*pz))+(((-1.0)*cj12))+(((-16.6666666666667)*x747*x748)));
j10eval[1]=IKsign(((-42.24)+(((75.231)*x747))+(((-643.0)*x750))+(((643.0)*x749))+(((-643.0)*x747*x748))+(((-38.58)*cj12))+(((704.0)*pz))));
if( IKabs(j10eval[0]) < 0.0000010000000000  || IKabs(j10eval[1]) < 0.0000010000000000  )
{
continue; // no branches [j10]

} else
{
{
IkReal j10array[1], cj10array[1], sj10array[1];
bool j10valid[1]={false};
_nj10 = 1;
IkReal x751=cj9*cj9;
IkReal x752=py*py;
IkReal x753=(cj9*px);
IkReal x754=((2000.0)*pz);
IkReal x755=(cj11*sj12);
IkReal x756=(py*sj9);
IkReal x757=((2000.0)*x751);
CheckValue<IkReal> x758=IKPowWithIntegerCheck(IKsign(((-42.24)+(((643.0)*cj12*pz))+(((75.231)*x755))+(((-643.0)*x755*x756))+(((-38.58)*cj12))+(((-643.0)*x753*x755))+(((704.0)*pz)))),-1);
if(!x758.valid){
continue;
}
CheckValue<IkReal> x759 = IKatan2WithCheck(IkReal(((-220.43)+(((4000.0)*x753*x756))+(((-452.672)*cj12))+((x757*(px*px)))+(((-468.0)*x753))+(((-468.0)*x756))+(((-206.7245)*(cj12*cj12)))+(((2000.0)*x752))+(((-1.0)*x752*x757)))),IkReal(((14.04)+(((-206.7245)*cj12*x755))+(((-120.0)*x756))+(((-120.0)*x753))+(((-226.336)*x755))+(((-234.0)*pz))+((x753*x754))+((x754*x756)))),IKFAST_ATAN2_MAGTHRESH);
if(!x759.valid){
continue;
}
j10array[0]=((-1.5707963267949)+(((1.5707963267949)*(x758.value)))+(x759.value));
sj10array[0]=IKsin(j10array[0]);
cj10array[0]=IKcos(j10array[0]);
if( j10array[0] > IKPI )
{
    j10array[0]-=IK2PI;
}
else if( j10array[0] < -IKPI )
{    j10array[0]+=IK2PI;
}
j10valid[0] = true;
for(int ij10 = 0; ij10 < 1; ++ij10)
{
if( !j10valid[ij10] )
{
    continue;
}
_ij10[0] = ij10; _ij10[1] = -1;
for(int iij10 = ij10+1; iij10 < 1; ++iij10)
{
if( j10valid[iij10] && IKabs(cj10array[ij10]-cj10array[iij10]) < IKFAST_SOLUTION_THRESH && IKabs(sj10array[ij10]-sj10array[iij10]) < IKFAST_SOLUTION_THRESH )
{
    j10valid[iij10]=false; _ij10[1] = iij10; break; 
}
}
j10 = j10array[ij10]; cj10 = cj10array[ij10]; sj10 = sj10array[ij10];
{
IkReal evalcond[6];
IkReal x760=IKsin(j10);
IkReal x761=IKcos(j10);
IkReal x762=((0.3215)*cj12);
IkReal x763=(px*sj9);
IkReal x764=((0.3215)*sj12);
IkReal x765=(py*sj9);
IkReal x766=(cj11*cj9);
IkReal x767=(cj9*px);
IkReal x768=((1.0)*cj9*sj11);
IkReal x769=(pz*x760);
IkReal x770=((0.06)*x761);
IkReal x771=(px*x760);
IkReal x772=((1.0)*x761);
IkReal x773=((0.704)*x761);
IkReal x774=(sj11*x760);
IkReal x775=(cj11*x760);
IkReal x776=(cj11*x761);
evalcond[0]=((-0.06)+(((0.352)*x760))+((x764*x776))+((x760*x762))+pz);
evalcond[1]=((0.117)+(((0.352)*x761))+(((-1.0)*x764*x775))+((x761*x762))+(((-1.0)*x765))+(((-1.0)*x767)));
evalcond[2]=((0.352)+(((0.117)*x761))+(((-1.0)*x767*x772))+(((-1.0)*x765*x772))+(((-0.06)*x760))+x769+x762);
evalcond[3]=((((-1.0)*pz*sj11*x772))+((cj11*x763))+(((0.117)*x774))+((sj11*x770))+(((-1.0)*py*x766))+(((-1.0)*x765*x774))+(((-1.0)*x767*x774)));
evalcond[4]=((((-1.0)*py*x768))+((sj11*x763))+((pz*x776))+(((-0.117)*x775))+((x766*x771))+(((-1.0)*cj11*x770))+((x765*x775))+x764);
evalcond[5]=((-0.03783075)+(((0.12)*pz))+(((-0.704)*x769))+((x767*x773))+(((-1.0)*pp))+((x765*x773))+(((0.234)*x767))+(((0.234)*x765))+(((0.04224)*x760))+(((-0.082368)*x761)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}

}

} else
{
{
IkReal j10array[1], cj10array[1], sj10array[1];
bool j10valid[1]={false};
_nj10 = 1;
IkReal x777=cj11*cj11;
IkReal x778=cj12*cj12;
IkReal x779=(cj11*sj12);
IkReal x780=((1286000.0)*pz);
IkReal x781=((1286000.0)*cj12);
IkReal x782=(py*sj9);
IkReal x783=(cj9*px);
IkReal x784=((413449.0)*x778);
CheckValue<IkReal> x785 = IKatan2WithCheck(IkReal(((84480.0)+(((-1.0)*cj12*x780))+(((-1286000.0)*x779*x783))+(((-1286000.0)*x779*x782))+(((150462.0)*x779))+(((77160.0)*cj12))+(((-1408000.0)*pz)))),IkReal(((-164736.0)+((x781*x782))+((x781*x783))+(((77160.0)*x779))+(((-150462.0)*cj12))+(((1408000.0)*x782))+(((1408000.0)*x783))+(((-1.0)*x779*x780)))),IKFAST_ATAN2_MAGTHRESH);
if(!x785.valid){
continue;
}
CheckValue<IkReal> x786=IKPowWithIntegerCheck(IKsign(((495616.0)+(((905344.0)*cj12))+(((-1.0)*x777*x784))+x784+(((413449.0)*x777)))),-1);
if(!x786.valid){
continue;
}
j10array[0]=((-1.5707963267949)+(x785.value)+(((1.5707963267949)*(x786.value))));
sj10array[0]=IKsin(j10array[0]);
cj10array[0]=IKcos(j10array[0]);
if( j10array[0] > IKPI )
{
    j10array[0]-=IK2PI;
}
else if( j10array[0] < -IKPI )
{    j10array[0]+=IK2PI;
}
j10valid[0] = true;
for(int ij10 = 0; ij10 < 1; ++ij10)
{
if( !j10valid[ij10] )
{
    continue;
}
_ij10[0] = ij10; _ij10[1] = -1;
for(int iij10 = ij10+1; iij10 < 1; ++iij10)
{
if( j10valid[iij10] && IKabs(cj10array[ij10]-cj10array[iij10]) < IKFAST_SOLUTION_THRESH && IKabs(sj10array[ij10]-sj10array[iij10]) < IKFAST_SOLUTION_THRESH )
{
    j10valid[iij10]=false; _ij10[1] = iij10; break; 
}
}
j10 = j10array[ij10]; cj10 = cj10array[ij10]; sj10 = sj10array[ij10];
{
IkReal evalcond[6];
IkReal x787=IKsin(j10);
IkReal x788=IKcos(j10);
IkReal x789=((0.3215)*cj12);
IkReal x790=(px*sj9);
IkReal x791=((0.3215)*sj12);
IkReal x792=(py*sj9);
IkReal x793=(cj11*cj9);
IkReal x794=(cj9*px);
IkReal x795=((1.0)*cj9*sj11);
IkReal x796=(pz*x787);
IkReal x797=((0.06)*x788);
IkReal x798=(px*x787);
IkReal x799=((1.0)*x788);
IkReal x800=((0.704)*x788);
IkReal x801=(sj11*x787);
IkReal x802=(cj11*x787);
IkReal x803=(cj11*x788);
evalcond[0]=((-0.06)+((x787*x789))+((x791*x803))+pz+(((0.352)*x787)));
evalcond[1]=((0.117)+(((-1.0)*x791*x802))+((x788*x789))+(((-1.0)*x792))+(((-1.0)*x794))+(((0.352)*x788)));
evalcond[2]=((0.352)+(((-1.0)*x794*x799))+(((-1.0)*x792*x799))+(((0.117)*x788))+(((-0.06)*x787))+x796+x789);
evalcond[3]=((((-1.0)*pz*sj11*x799))+((cj11*x790))+(((-1.0)*x792*x801))+(((0.117)*x801))+(((-1.0)*py*x793))+((sj11*x797))+(((-1.0)*x794*x801)));
evalcond[4]=((((-1.0)*cj11*x797))+((x793*x798))+(((-0.117)*x802))+((x792*x802))+x791+((pz*x803))+(((-1.0)*py*x795))+((sj11*x790)));
evalcond[5]=((-0.03783075)+(((0.12)*pz))+(((-0.704)*x796))+(((-1.0)*pp))+((x794*x800))+((x792*x800))+(((0.04224)*x787))+(((0.234)*x794))+(((0.234)*x792))+(((-0.082368)*x788)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}

}

} else
{
{
IkReal j10array[1], cj10array[1], sj10array[1];
bool j10valid[1]={false};
_nj10 = 1;
IkReal x804=(cj11*sj12);
IkReal x805=(cj9*px);
IkReal x806=((2000.0)*pz);
IkReal x807=(py*sj9);
IkReal x808=((643.0)*cj12);
CheckValue<IkReal> x809=IKPowWithIntegerCheck(IKsign(((-82.368)+(((643.0)*pz*x804))+((x805*x808))+(((704.0)*x807))+(((704.0)*x805))+(((-38.58)*x804))+(((-75.231)*cj12))+((x807*x808)))),-1);
if(!x809.valid){
continue;
}
CheckValue<IkReal> x810 = IKatan2WithCheck(IkReal(((-14.04)+(((-226.336)*x804))+(((-1.0)*x805*x806))+(((-1.0)*x806*x807))+(((234.0)*pz))+(((120.0)*x805))+(((120.0)*x807))+(((-206.7245)*cj12*x804)))),IkReal(((240.608)+(((240.0)*pz))+(((206.7245)*(cj12*cj12)))+(((452.672)*cj12))+(((-1.0)*pz*x806)))),IKFAST_ATAN2_MAGTHRESH);
if(!x810.valid){
continue;
}
j10array[0]=((-1.5707963267949)+(((1.5707963267949)*(x809.value)))+(x810.value));
sj10array[0]=IKsin(j10array[0]);
cj10array[0]=IKcos(j10array[0]);
if( j10array[0] > IKPI )
{
    j10array[0]-=IK2PI;
}
else if( j10array[0] < -IKPI )
{    j10array[0]+=IK2PI;
}
j10valid[0] = true;
for(int ij10 = 0; ij10 < 1; ++ij10)
{
if( !j10valid[ij10] )
{
    continue;
}
_ij10[0] = ij10; _ij10[1] = -1;
for(int iij10 = ij10+1; iij10 < 1; ++iij10)
{
if( j10valid[iij10] && IKabs(cj10array[ij10]-cj10array[iij10]) < IKFAST_SOLUTION_THRESH && IKabs(sj10array[ij10]-sj10array[iij10]) < IKFAST_SOLUTION_THRESH )
{
    j10valid[iij10]=false; _ij10[1] = iij10; break; 
}
}
j10 = j10array[ij10]; cj10 = cj10array[ij10]; sj10 = sj10array[ij10];
{
IkReal evalcond[6];
IkReal x811=IKsin(j10);
IkReal x812=IKcos(j10);
IkReal x813=((0.3215)*cj12);
IkReal x814=(px*sj9);
IkReal x815=((0.3215)*sj12);
IkReal x816=(py*sj9);
IkReal x817=(cj11*cj9);
IkReal x818=(cj9*px);
IkReal x819=((1.0)*cj9*sj11);
IkReal x820=(pz*x811);
IkReal x821=((0.06)*x812);
IkReal x822=(px*x811);
IkReal x823=((1.0)*x812);
IkReal x824=((0.704)*x812);
IkReal x825=(sj11*x811);
IkReal x826=(cj11*x811);
IkReal x827=(cj11*x812);
evalcond[0]=((-0.06)+((x815*x827))+(((0.352)*x811))+((x811*x813))+pz);
evalcond[1]=((0.117)+((x812*x813))+(((-1.0)*x815*x826))+(((-1.0)*x818))+(((-1.0)*x816))+(((0.352)*x812)));
evalcond[2]=((0.352)+(((-1.0)*x816*x823))+(((0.117)*x812))+(((-1.0)*x818*x823))+(((-0.06)*x811))+x813+x820);
evalcond[3]=(((sj11*x821))+(((-1.0)*x818*x825))+((cj11*x814))+(((0.117)*x825))+(((-1.0)*x816*x825))+(((-1.0)*py*x817))+(((-1.0)*pz*sj11*x823)));
evalcond[4]=(((pz*x827))+((sj11*x814))+(((-1.0)*py*x819))+((x817*x822))+((x816*x826))+x815+(((-1.0)*cj11*x821))+(((-0.117)*x826)));
evalcond[5]=((-0.03783075)+(((0.12)*pz))+((x816*x824))+(((-1.0)*pp))+(((-0.082368)*x812))+((x818*x824))+(((0.04224)*x811))+(((0.234)*x816))+(((0.234)*x818))+(((-0.704)*x820)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}

}
}
}

}

}

} else
{
{
IkReal j10array[1], cj10array[1], sj10array[1];
bool j10valid[1]={false};
_nj10 = 1;
IkReal x828=cj9*cj9;
IkReal x829=py*py;
IkReal x830=px*px;
IkReal x831=pz*pz;
IkReal x832=((0.234)*pz);
IkReal x833=(pp*sj11);
IkReal x834=(cj9*px);
IkReal x835=((0.704)*pz);
IkReal x836=((0.234)*sj11);
IkReal x837=(pz*sj11);
IkReal x838=(py*sj11*sj9);
IkReal x839=(cj11*cj9*py);
IkReal x840=(sj11*x831);
IkReal x841=(cj11*px*sj9);
IkReal x842=(cj11*px*py);
IkReal x843=((0.704)*sj11*x829);
IkReal x844=(x828*x830);
IkReal x845=((0.704)*cj11*cj9*sj9);
CheckValue<IkReal> x846=IKPowWithIntegerCheck(IKsign(((((-1.0)*x828*x843))+(((-0.164736)*sj11*x834))+(((-0.08448)*x837))+(((0.704)*x840))+(((0.012171456)*sj11))+(((-0.164736)*x838))+x843+(((1.408)*x834*x838))+(((0.704)*sj11*x844)))),-1);
if(!x846.valid){
continue;
}
CheckValue<IkReal> x847 = IKatan2WithCheck(IkReal(((((0.002269845)*sj11))+(((-0.01404)*x838))+(((-0.01404)*sj11*x834))+(((0.06)*x833))+((sj11*x832*x834))+((x832*x838))+(((-0.04503075)*x837))+((x830*x845))+(((0.704)*x842))+(((0.12)*x840))+(((-1.0)*pz*x833))+(((0.082368)*x839))+(((-1.408)*x828*x842))+(((-1.0)*x829*x845))+(((-0.082368)*x841)))),IkReal(((((-0.12)*x834*x837))+(((0.06520875)*sj11*x834))+(((-1.0)*x835*x839))+(((-1.0)*x836*x844))+(((0.01404)*x837))+(((-0.468)*x834*x838))+((x835*x841))+((x833*x834))+((x828*x829*x836))+(((-0.04224)*x841))+(((0.04224)*x839))+(((-0.12)*py*sj9*x837))+(((0.06520875)*x838))+((py*sj9*x833))+(((-1.0)*x829*x836))+(((-0.117)*x833))+(((-0.00442619775)*sj11)))),IKFAST_ATAN2_MAGTHRESH);
if(!x847.valid){
continue;
}
j10array[0]=((-1.5707963267949)+(((1.5707963267949)*(x846.value)))+(x847.value));
sj10array[0]=IKsin(j10array[0]);
cj10array[0]=IKcos(j10array[0]);
if( j10array[0] > IKPI )
{
    j10array[0]-=IK2PI;
}
else if( j10array[0] < -IKPI )
{    j10array[0]+=IK2PI;
}
j10valid[0] = true;
for(int ij10 = 0; ij10 < 1; ++ij10)
{
if( !j10valid[ij10] )
{
    continue;
}
_ij10[0] = ij10; _ij10[1] = -1;
for(int iij10 = ij10+1; iij10 < 1; ++iij10)
{
if( j10valid[iij10] && IKabs(cj10array[ij10]-cj10array[iij10]) < IKFAST_SOLUTION_THRESH && IKabs(sj10array[ij10]-sj10array[iij10]) < IKFAST_SOLUTION_THRESH )
{
    j10valid[iij10]=false; _ij10[1] = iij10; break; 
}
}
j10 = j10array[ij10]; cj10 = cj10array[ij10]; sj10 = sj10array[ij10];
{
IkReal evalcond[2];
IkReal x848=IKsin(j10);
IkReal x849=IKcos(j10);
IkReal x850=(cj9*px);
IkReal x851=(py*sj9);
IkReal x852=((0.704)*x849);
IkReal x853=(sj11*x848);
IkReal x854=(sj11*x849);
evalcond[0]=((((-1.0)*x850*x853))+(((-1.0)*x851*x853))+(((-1.0)*cj11*cj9*py))+(((-1.0)*pz*x854))+(((0.06)*x854))+((cj11*px*sj9))+(((0.117)*x853)));
evalcond[1]=((-0.03783075)+((x850*x852))+(((0.12)*pz))+(((0.234)*x850))+(((0.234)*x851))+(((-0.704)*pz*x848))+(((-1.0)*pp))+(((0.04224)*x848))+((x851*x852))+(((-0.082368)*x849)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
IkReal j12eval[1];
j12eval[0]=sj11;
if( IKabs(j12eval[0]) < 0.0000010000000000  )
{
{
IkReal j12eval[2];
j12eval[0]=cj10;
j12eval[1]=cj11;
if( IKabs(j12eval[0]) < 0.0000010000000000  || IKabs(j12eval[1]) < 0.0000010000000000  )
{
{
IkReal j12eval[2];
j12eval[0]=sj11;
j12eval[1]=sj10;
if( IKabs(j12eval[0]) < 0.0000010000000000  || IKabs(j12eval[1]) < 0.0000010000000000  )
{
{
IkReal evalcond[1];
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(j11))), 6.28318530717959)));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j12array[1], cj12array[1], sj12array[1];
bool j12valid[1]={false};
_nj12 = 1;
IkReal x855=((3.1104199066874)*sj10);
IkReal x856=((3.1104199066874)*cj10);
IkReal x857=(py*sj9);
IkReal x858=(cj9*px);
if( IKabs(((((0.363919129082426)*sj10))+(((0.186625194401244)*cj10))+(((-1.0)*pz*x856))+(((-1.0)*x855*x858))+(((-1.0)*x855*x857)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((-1.09486780715397)+(((-0.363919129082426)*cj10))+((x856*x858))+((x856*x857))+(((0.186625194401244)*sj10))+(((-1.0)*pz*x855)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((((0.363919129082426)*sj10))+(((0.186625194401244)*cj10))+(((-1.0)*pz*x856))+(((-1.0)*x855*x858))+(((-1.0)*x855*x857))))+IKsqr(((-1.09486780715397)+(((-0.363919129082426)*cj10))+((x856*x858))+((x856*x857))+(((0.186625194401244)*sj10))+(((-1.0)*pz*x855))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j12array[0]=IKatan2(((((0.363919129082426)*sj10))+(((0.186625194401244)*cj10))+(((-1.0)*pz*x856))+(((-1.0)*x855*x858))+(((-1.0)*x855*x857))), ((-1.09486780715397)+(((-0.363919129082426)*cj10))+((x856*x858))+((x856*x857))+(((0.186625194401244)*sj10))+(((-1.0)*pz*x855))));
sj12array[0]=IKsin(j12array[0]);
cj12array[0]=IKcos(j12array[0]);
if( j12array[0] > IKPI )
{
    j12array[0]-=IK2PI;
}
else if( j12array[0] < -IKPI )
{    j12array[0]+=IK2PI;
}
j12valid[0] = true;
for(int ij12 = 0; ij12 < 1; ++ij12)
{
if( !j12valid[ij12] )
{
    continue;
}
_ij12[0] = ij12; _ij12[1] = -1;
for(int iij12 = ij12+1; iij12 < 1; ++iij12)
{
if( j12valid[iij12] && IKabs(cj12array[ij12]-cj12array[iij12]) < IKFAST_SOLUTION_THRESH && IKabs(sj12array[ij12]-sj12array[iij12]) < IKFAST_SOLUTION_THRESH )
{
    j12valid[iij12]=false; _ij12[1] = iij12; break; 
}
}
j12 = j12array[ij12]; cj12 = cj12array[ij12]; sj12 = sj12array[ij12];
{
IkReal evalcond[5];
IkReal x859=IKcos(j12);
IkReal x860=IKsin(j12);
IkReal x861=(cj9*px);
IkReal x862=((1.0)*cj10);
IkReal x863=(py*sj9);
IkReal x864=((0.3215)*x860);
IkReal x865=((0.3215)*x859);
evalcond[0]=((-0.06)+((sj10*x865))+(((0.352)*sj10))+((cj10*x864))+pz);
evalcond[1]=((0.20997725)+(((0.12)*pz))+(((0.234)*x861))+(((0.234)*x863))+(((-1.0)*pp))+(((0.226336)*x859)));
evalcond[2]=((((-0.117)*sj10))+((sj10*x861))+((sj10*x863))+((cj10*pz))+(((-0.06)*cj10))+x864);
evalcond[3]=((0.117)+(((0.352)*cj10))+(((-1.0)*x863))+(((-1.0)*x861))+((cj10*x865))+(((-1.0)*sj10*x864)));
evalcond[4]=((0.352)+(((-0.06)*sj10))+(((0.117)*cj10))+(((-1.0)*x862*x863))+(((-1.0)*x861*x862))+((pz*sj10))+x865);
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((-3.14159265358979)+j11)))), 6.28318530717959)));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j12array[1], cj12array[1], sj12array[1];
bool j12valid[1]={false};
_nj12 = 1;
IkReal x866=((3.1104199066874)*sj10);
IkReal x867=((3.1104199066874)*cj10);
IkReal x868=(py*sj9);
IkReal x869=(cj9*px);
if( IKabs(((((-0.186625194401244)*cj10))+((x866*x869))+((x866*x868))+(((-0.363919129082426)*sj10))+((pz*x867)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((-1.09486780715397)+(((-0.363919129082426)*cj10))+((x867*x868))+((x867*x869))+(((-1.0)*pz*x866))+(((0.186625194401244)*sj10)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((((-0.186625194401244)*cj10))+((x866*x869))+((x866*x868))+(((-0.363919129082426)*sj10))+((pz*x867))))+IKsqr(((-1.09486780715397)+(((-0.363919129082426)*cj10))+((x867*x868))+((x867*x869))+(((-1.0)*pz*x866))+(((0.186625194401244)*sj10))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j12array[0]=IKatan2(((((-0.186625194401244)*cj10))+((x866*x869))+((x866*x868))+(((-0.363919129082426)*sj10))+((pz*x867))), ((-1.09486780715397)+(((-0.363919129082426)*cj10))+((x867*x868))+((x867*x869))+(((-1.0)*pz*x866))+(((0.186625194401244)*sj10))));
sj12array[0]=IKsin(j12array[0]);
cj12array[0]=IKcos(j12array[0]);
if( j12array[0] > IKPI )
{
    j12array[0]-=IK2PI;
}
else if( j12array[0] < -IKPI )
{    j12array[0]+=IK2PI;
}
j12valid[0] = true;
for(int ij12 = 0; ij12 < 1; ++ij12)
{
if( !j12valid[ij12] )
{
    continue;
}
_ij12[0] = ij12; _ij12[1] = -1;
for(int iij12 = ij12+1; iij12 < 1; ++iij12)
{
if( j12valid[iij12] && IKabs(cj12array[ij12]-cj12array[iij12]) < IKFAST_SOLUTION_THRESH && IKabs(sj12array[ij12]-sj12array[iij12]) < IKFAST_SOLUTION_THRESH )
{
    j12valid[iij12]=false; _ij12[1] = iij12; break; 
}
}
j12 = j12array[ij12]; cj12 = cj12array[ij12]; sj12 = sj12array[ij12];
{
IkReal evalcond[5];
IkReal x870=IKcos(j12);
IkReal x871=IKsin(j12);
IkReal x872=((1.0)*sj10);
IkReal x873=(py*sj9);
IkReal x874=((1.0)*cj10);
IkReal x875=(cj9*px);
IkReal x876=((0.3215)*x871);
IkReal x877=((0.3215)*x870);
evalcond[0]=((-0.06)+(((0.352)*sj10))+((sj10*x877))+pz+(((-1.0)*cj10*x876)));
evalcond[1]=((0.20997725)+(((0.12)*pz))+(((0.226336)*x870))+(((-1.0)*pp))+(((0.234)*x875))+(((0.234)*x873)));
evalcond[2]=((0.117)+(((0.352)*cj10))+((sj10*x876))+(((-1.0)*x873))+(((-1.0)*x875))+((cj10*x877)));
evalcond[3]=((0.352)+(((-0.06)*sj10))+(((0.117)*cj10))+(((-1.0)*x873*x874))+((pz*sj10))+(((-1.0)*x874*x875))+x877);
evalcond[4]=((((-1.0)*x872*x875))+(((-1.0)*x872*x873))+(((0.06)*cj10))+(((-1.0)*pz*x874))+x876+(((0.117)*sj10)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(j10))), 6.28318530717959)));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j12eval[1];
sj10=0;
cj10=1.0;
j10=0;
j12eval[0]=cj11;
if( IKabs(j12eval[0]) < 0.0000010000000000  )
{
{
IkReal j12eval[1];
sj10=0;
cj10=1.0;
j10=0;
j12eval[0]=sj11;
if( IKabs(j12eval[0]) < 0.0000010000000000  )
{
{
IkReal evalcond[1];
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(j11))), 6.28318530717959)));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j12array[1], cj12array[1], sj12array[1];
bool j12valid[1]={false};
_nj12 = 1;
if( IKabs(((0.186625194401244)+(((-3.1104199066874)*pz)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((-1.45878693623639)+(((3.1104199066874)*py*sj9))+(((3.1104199066874)*cj9*px)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((0.186625194401244)+(((-3.1104199066874)*pz))))+IKsqr(((-1.45878693623639)+(((3.1104199066874)*py*sj9))+(((3.1104199066874)*cj9*px))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j12array[0]=IKatan2(((0.186625194401244)+(((-3.1104199066874)*pz))), ((-1.45878693623639)+(((3.1104199066874)*py*sj9))+(((3.1104199066874)*cj9*px))));
sj12array[0]=IKsin(j12array[0]);
cj12array[0]=IKcos(j12array[0]);
if( j12array[0] > IKPI )
{
    j12array[0]-=IK2PI;
}
else if( j12array[0] < -IKPI )
{    j12array[0]+=IK2PI;
}
j12valid[0] = true;
for(int ij12 = 0; ij12 < 1; ++ij12)
{
if( !j12valid[ij12] )
{
    continue;
}
_ij12[0] = ij12; _ij12[1] = -1;
for(int iij12 = ij12+1; iij12 < 1; ++iij12)
{
if( j12valid[iij12] && IKabs(cj12array[ij12]-cj12array[iij12]) < IKFAST_SOLUTION_THRESH && IKabs(sj12array[ij12]-sj12array[iij12]) < IKFAST_SOLUTION_THRESH )
{
    j12valid[iij12]=false; _ij12[1] = iij12; break; 
}
}
j12 = j12array[ij12]; cj12 = cj12array[ij12]; sj12 = sj12array[ij12];
{
IkReal evalcond[3];
IkReal x878=IKcos(j12);
IkReal x879=(py*sj9);
IkReal x880=(cj9*px);
evalcond[0]=((-0.06)+pz+(((0.3215)*(IKsin(j12)))));
evalcond[1]=((0.330176)+(((-0.704)*x880))+(((-0.704)*x879))+(((0.226336)*x878)));
evalcond[2]=((0.469)+(((-1.0)*x879))+(((-1.0)*x880))+(((0.3215)*x878)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((-3.14159265358979)+j11)))), 6.28318530717959)));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j12array[1], cj12array[1], sj12array[1];
bool j12valid[1]={false};
_nj12 = 1;
if( IKabs(((-0.186625194401244)+(((3.1104199066874)*pz)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((-1.45878693623639)+(((3.1104199066874)*py*sj9))+(((3.1104199066874)*cj9*px)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((-0.186625194401244)+(((3.1104199066874)*pz))))+IKsqr(((-1.45878693623639)+(((3.1104199066874)*py*sj9))+(((3.1104199066874)*cj9*px))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j12array[0]=IKatan2(((-0.186625194401244)+(((3.1104199066874)*pz))), ((-1.45878693623639)+(((3.1104199066874)*py*sj9))+(((3.1104199066874)*cj9*px))));
sj12array[0]=IKsin(j12array[0]);
cj12array[0]=IKcos(j12array[0]);
if( j12array[0] > IKPI )
{
    j12array[0]-=IK2PI;
}
else if( j12array[0] < -IKPI )
{    j12array[0]+=IK2PI;
}
j12valid[0] = true;
for(int ij12 = 0; ij12 < 1; ++ij12)
{
if( !j12valid[ij12] )
{
    continue;
}
_ij12[0] = ij12; _ij12[1] = -1;
for(int iij12 = ij12+1; iij12 < 1; ++iij12)
{
if( j12valid[iij12] && IKabs(cj12array[ij12]-cj12array[iij12]) < IKFAST_SOLUTION_THRESH && IKabs(sj12array[ij12]-sj12array[iij12]) < IKFAST_SOLUTION_THRESH )
{
    j12valid[iij12]=false; _ij12[1] = iij12; break; 
}
}
j12 = j12array[ij12]; cj12 = cj12array[ij12]; sj12 = sj12array[ij12];
{
IkReal evalcond[3];
IkReal x881=IKcos(j12);
IkReal x882=(py*sj9);
IkReal x883=(cj9*px);
evalcond[0]=((-0.06)+(((-0.3215)*(IKsin(j12))))+pz);
evalcond[1]=((0.330176)+(((-0.704)*x883))+(((-0.704)*x882))+(((0.226336)*x881)));
evalcond[2]=((0.469)+(((0.3215)*x881))+(((-1.0)*x883))+(((-1.0)*x882)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((-1.5707963267949)+j11)))), 6.28318530717959)));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j12array[1], cj12array[1], sj12array[1];
bool j12valid[1]={false};
_nj12 = 1;
IkReal x884=((3.1104199066874)*px);
IkReal x885=((3.1104199066874)*py);
if( IKabs(((((-1.0)*sj9*x884))+((cj9*x885)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((-1.45878693623639)+((sj9*x885))+((cj9*x884)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((((-1.0)*sj9*x884))+((cj9*x885))))+IKsqr(((-1.45878693623639)+((sj9*x885))+((cj9*x884))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j12array[0]=IKatan2(((((-1.0)*sj9*x884))+((cj9*x885))), ((-1.45878693623639)+((sj9*x885))+((cj9*x884))));
sj12array[0]=IKsin(j12array[0]);
cj12array[0]=IKcos(j12array[0]);
if( j12array[0] > IKPI )
{
    j12array[0]-=IK2PI;
}
else if( j12array[0] < -IKPI )
{    j12array[0]+=IK2PI;
}
j12valid[0] = true;
for(int ij12 = 0; ij12 < 1; ++ij12)
{
if( !j12valid[ij12] )
{
    continue;
}
_ij12[0] = ij12; _ij12[1] = -1;
for(int iij12 = ij12+1; iij12 < 1; ++iij12)
{
if( j12valid[iij12] && IKabs(cj12array[ij12]-cj12array[iij12]) < IKFAST_SOLUTION_THRESH && IKabs(sj12array[ij12]-sj12array[iij12]) < IKFAST_SOLUTION_THRESH )
{
    j12valid[iij12]=false; _ij12[1] = iij12; break; 
}
}
j12 = j12array[ij12]; cj12 = cj12array[ij12]; sj12 = sj12array[ij12];
{
IkReal evalcond[3];
IkReal x886=IKcos(j12);
IkReal x887=((1.0)*cj9);
IkReal x888=(py*sj9);
evalcond[0]=((((-1.0)*py*x887))+(((0.3215)*(IKsin(j12))))+((px*sj9)));
evalcond[1]=((0.330176)+(((-0.704)*x888))+(((0.226336)*x886))+(((-0.704)*cj9*px)));
evalcond[2]=((0.469)+(((0.3215)*x886))+(((-1.0)*x888))+(((-1.0)*px*x887)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((1.5707963267949)+j11)))), 6.28318530717959)));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j12array[1], cj12array[1], sj12array[1];
bool j12valid[1]={false};
_nj12 = 1;
IkReal x889=((3.1104199066874)*px);
IkReal x890=((3.1104199066874)*py);
if( IKabs((((sj9*x889))+(((-1.0)*cj9*x890)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((-1.45878693623639)+((sj9*x890))+((cj9*x889)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr((((sj9*x889))+(((-1.0)*cj9*x890))))+IKsqr(((-1.45878693623639)+((sj9*x890))+((cj9*x889))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j12array[0]=IKatan2((((sj9*x889))+(((-1.0)*cj9*x890))), ((-1.45878693623639)+((sj9*x890))+((cj9*x889))));
sj12array[0]=IKsin(j12array[0]);
cj12array[0]=IKcos(j12array[0]);
if( j12array[0] > IKPI )
{
    j12array[0]-=IK2PI;
}
else if( j12array[0] < -IKPI )
{    j12array[0]+=IK2PI;
}
j12valid[0] = true;
for(int ij12 = 0; ij12 < 1; ++ij12)
{
if( !j12valid[ij12] )
{
    continue;
}
_ij12[0] = ij12; _ij12[1] = -1;
for(int iij12 = ij12+1; iij12 < 1; ++iij12)
{
if( j12valid[iij12] && IKabs(cj12array[ij12]-cj12array[iij12]) < IKFAST_SOLUTION_THRESH && IKabs(sj12array[ij12]-sj12array[iij12]) < IKFAST_SOLUTION_THRESH )
{
    j12valid[iij12]=false; _ij12[1] = iij12; break; 
}
}
j12 = j12array[ij12]; cj12 = cj12array[ij12]; sj12 = sj12array[ij12];
{
IkReal evalcond[3];
IkReal x891=IKcos(j12);
IkReal x892=((1.0)*cj9);
IkReal x893=(py*sj9);
evalcond[0]=((((-0.3215)*(IKsin(j12))))+(((-1.0)*py*x892))+((px*sj9)));
evalcond[1]=((0.330176)+(((-0.704)*x893))+(((0.226336)*x891))+(((-0.704)*cj9*px)));
evalcond[2]=((0.469)+(((0.3215)*x891))+(((-1.0)*x893))+(((-1.0)*px*x892)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
if( 1 )
{
bgotonextstatement=false;
continue; // branch miss [j12]

}
} while(0);
if( bgotonextstatement )
{
}
}
}
}
}
}

} else
{
{
IkReal j12array[1], cj12array[1], sj12array[1];
bool j12valid[1]={false};
_nj12 = 1;
CheckValue<IkReal> x894=IKPowWithIntegerCheck(sj11,-1);
if(!x894.valid){
continue;
}
if( IKabs(((0.0015552099533437)*(x894.value)*(((((-2000.0)*px*sj9))+(((2000.0)*cj9*py)))))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((-1.45878693623639)+(((3.1104199066874)*py*sj9))+(((3.1104199066874)*cj9*px)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((0.0015552099533437)*(x894.value)*(((((-2000.0)*px*sj9))+(((2000.0)*cj9*py))))))+IKsqr(((-1.45878693623639)+(((3.1104199066874)*py*sj9))+(((3.1104199066874)*cj9*px))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j12array[0]=IKatan2(((0.0015552099533437)*(x894.value)*(((((-2000.0)*px*sj9))+(((2000.0)*cj9*py))))), ((-1.45878693623639)+(((3.1104199066874)*py*sj9))+(((3.1104199066874)*cj9*px))));
sj12array[0]=IKsin(j12array[0]);
cj12array[0]=IKcos(j12array[0]);
if( j12array[0] > IKPI )
{
    j12array[0]-=IK2PI;
}
else if( j12array[0] < -IKPI )
{    j12array[0]+=IK2PI;
}
j12valid[0] = true;
for(int ij12 = 0; ij12 < 1; ++ij12)
{
if( !j12valid[ij12] )
{
    continue;
}
_ij12[0] = ij12; _ij12[1] = -1;
for(int iij12 = ij12+1; iij12 < 1; ++iij12)
{
if( j12valid[iij12] && IKabs(cj12array[ij12]-cj12array[iij12]) < IKFAST_SOLUTION_THRESH && IKabs(sj12array[ij12]-sj12array[iij12]) < IKFAST_SOLUTION_THRESH )
{
    j12valid[iij12]=false; _ij12[1] = iij12; break; 
}
}
j12 = j12array[ij12]; cj12 = cj12array[ij12]; sj12 = sj12array[ij12];
{
IkReal evalcond[5];
IkReal x895=IKsin(j12);
IkReal x896=IKcos(j12);
IkReal x897=(py*sj9);
IkReal x898=(cj9*px);
IkReal x899=(px*sj9);
IkReal x900=((1.0)*cj9*py);
IkReal x901=((0.3215)*x895);
evalcond[0]=((-0.06)+pz+((cj11*x901)));
evalcond[1]=((((-1.0)*x900))+((sj11*x901))+x899);
evalcond[2]=((0.330176)+(((-0.704)*x897))+(((-0.704)*x898))+(((0.226336)*x896)));
evalcond[3]=((0.469)+(((0.3215)*x896))+(((-1.0)*x898))+(((-1.0)*x897)));
evalcond[4]=(((sj11*x899))+(((-0.06)*cj11))+(((-1.0)*sj11*x900))+x901+((cj11*pz)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}

}

} else
{
{
IkReal j12array[1], cj12array[1], sj12array[1];
bool j12valid[1]={false};
_nj12 = 1;
CheckValue<IkReal> x902=IKPowWithIntegerCheck(cj11,-1);
if(!x902.valid){
continue;
}
if( IKabs(((0.0015552099533437)*(x902.value)*(((120.0)+(((-2000.0)*pz)))))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((-1.45878693623639)+(((3.1104199066874)*py*sj9))+(((3.1104199066874)*cj9*px)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((0.0015552099533437)*(x902.value)*(((120.0)+(((-2000.0)*pz))))))+IKsqr(((-1.45878693623639)+(((3.1104199066874)*py*sj9))+(((3.1104199066874)*cj9*px))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j12array[0]=IKatan2(((0.0015552099533437)*(x902.value)*(((120.0)+(((-2000.0)*pz))))), ((-1.45878693623639)+(((3.1104199066874)*py*sj9))+(((3.1104199066874)*cj9*px))));
sj12array[0]=IKsin(j12array[0]);
cj12array[0]=IKcos(j12array[0]);
if( j12array[0] > IKPI )
{
    j12array[0]-=IK2PI;
}
else if( j12array[0] < -IKPI )
{    j12array[0]+=IK2PI;
}
j12valid[0] = true;
for(int ij12 = 0; ij12 < 1; ++ij12)
{
if( !j12valid[ij12] )
{
    continue;
}
_ij12[0] = ij12; _ij12[1] = -1;
for(int iij12 = ij12+1; iij12 < 1; ++iij12)
{
if( j12valid[iij12] && IKabs(cj12array[ij12]-cj12array[iij12]) < IKFAST_SOLUTION_THRESH && IKabs(sj12array[ij12]-sj12array[iij12]) < IKFAST_SOLUTION_THRESH )
{
    j12valid[iij12]=false; _ij12[1] = iij12; break; 
}
}
j12 = j12array[ij12]; cj12 = cj12array[ij12]; sj12 = sj12array[ij12];
{
IkReal evalcond[5];
IkReal x903=IKsin(j12);
IkReal x904=IKcos(j12);
IkReal x905=(py*sj9);
IkReal x906=(cj9*px);
IkReal x907=(px*sj9);
IkReal x908=((1.0)*cj9*py);
IkReal x909=((0.3215)*x903);
evalcond[0]=((-0.06)+pz+((cj11*x909)));
evalcond[1]=((((-1.0)*x908))+((sj11*x909))+x907);
evalcond[2]=((0.330176)+(((-0.704)*x905))+(((-0.704)*x906))+(((0.226336)*x904)));
evalcond[3]=((0.469)+(((0.3215)*x904))+(((-1.0)*x906))+(((-1.0)*x905)));
evalcond[4]=(((sj11*x907))+(((-0.06)*cj11))+(((-1.0)*sj11*x908))+x909+((cj11*pz)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}

}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((-3.14159265358979)+j10)))), 6.28318530717959)));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j12eval[1];
sj10=0;
cj10=-1.0;
j10=3.14159265358979;
j12eval[0]=cj11;
if( IKabs(j12eval[0]) < 0.0000010000000000  )
{
{
IkReal j12eval[1];
sj10=0;
cj10=-1.0;
j10=3.14159265358979;
j12eval[0]=sj11;
if( IKabs(j12eval[0]) < 0.0000010000000000  )
{
{
IkReal evalcond[1];
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(j11))), 6.28318530717959)));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j12array[1], cj12array[1], sj12array[1];
bool j12valid[1]={false};
_nj12 = 1;
if( IKabs(((-0.186625194401244)+(((3.1104199066874)*pz)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((-0.73094867807154)+(((-3.1104199066874)*cj9*px))+(((-3.1104199066874)*py*sj9)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((-0.186625194401244)+(((3.1104199066874)*pz))))+IKsqr(((-0.73094867807154)+(((-3.1104199066874)*cj9*px))+(((-3.1104199066874)*py*sj9))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j12array[0]=IKatan2(((-0.186625194401244)+(((3.1104199066874)*pz))), ((-0.73094867807154)+(((-3.1104199066874)*cj9*px))+(((-3.1104199066874)*py*sj9))));
sj12array[0]=IKsin(j12array[0]);
cj12array[0]=IKcos(j12array[0]);
if( j12array[0] > IKPI )
{
    j12array[0]-=IK2PI;
}
else if( j12array[0] < -IKPI )
{    j12array[0]+=IK2PI;
}
j12valid[0] = true;
for(int ij12 = 0; ij12 < 1; ++ij12)
{
if( !j12valid[ij12] )
{
    continue;
}
_ij12[0] = ij12; _ij12[1] = -1;
for(int iij12 = ij12+1; iij12 < 1; ++iij12)
{
if( j12valid[iij12] && IKabs(cj12array[ij12]-cj12array[iij12]) < IKFAST_SOLUTION_THRESH && IKabs(sj12array[ij12]-sj12array[iij12]) < IKFAST_SOLUTION_THRESH )
{
    j12valid[iij12]=false; _ij12[1] = iij12; break; 
}
}
j12 = j12array[ij12]; cj12 = cj12array[ij12]; sj12 = sj12array[ij12];
{
IkReal evalcond[3];
IkReal x910=IKcos(j12);
IkReal x911=(py*sj9);
IkReal x912=(cj9*px);
evalcond[0]=((-0.06)+(((-0.3215)*(IKsin(j12))))+pz);
evalcond[1]=((0.16544)+(((0.704)*x912))+(((0.704)*x911))+(((0.226336)*x910)));
evalcond[2]=((-0.235)+(((-0.3215)*x910))+(((-1.0)*x912))+(((-1.0)*x911)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((-3.14159265358979)+j11)))), 6.28318530717959)));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j12array[1], cj12array[1], sj12array[1];
bool j12valid[1]={false};
_nj12 = 1;
if( IKabs(((0.186625194401244)+(((-3.1104199066874)*pz)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((-0.73094867807154)+(((-3.1104199066874)*cj9*px))+(((-3.1104199066874)*py*sj9)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((0.186625194401244)+(((-3.1104199066874)*pz))))+IKsqr(((-0.73094867807154)+(((-3.1104199066874)*cj9*px))+(((-3.1104199066874)*py*sj9))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j12array[0]=IKatan2(((0.186625194401244)+(((-3.1104199066874)*pz))), ((-0.73094867807154)+(((-3.1104199066874)*cj9*px))+(((-3.1104199066874)*py*sj9))));
sj12array[0]=IKsin(j12array[0]);
cj12array[0]=IKcos(j12array[0]);
if( j12array[0] > IKPI )
{
    j12array[0]-=IK2PI;
}
else if( j12array[0] < -IKPI )
{    j12array[0]+=IK2PI;
}
j12valid[0] = true;
for(int ij12 = 0; ij12 < 1; ++ij12)
{
if( !j12valid[ij12] )
{
    continue;
}
_ij12[0] = ij12; _ij12[1] = -1;
for(int iij12 = ij12+1; iij12 < 1; ++iij12)
{
if( j12valid[iij12] && IKabs(cj12array[ij12]-cj12array[iij12]) < IKFAST_SOLUTION_THRESH && IKabs(sj12array[ij12]-sj12array[iij12]) < IKFAST_SOLUTION_THRESH )
{
    j12valid[iij12]=false; _ij12[1] = iij12; break; 
}
}
j12 = j12array[ij12]; cj12 = cj12array[ij12]; sj12 = sj12array[ij12];
{
IkReal evalcond[3];
IkReal x913=IKcos(j12);
IkReal x914=(py*sj9);
IkReal x915=(cj9*px);
evalcond[0]=((-0.06)+pz+(((0.3215)*(IKsin(j12)))));
evalcond[1]=((0.16544)+(((0.704)*x914))+(((0.704)*x915))+(((0.226336)*x913)));
evalcond[2]=((-0.235)+(((-0.3215)*x913))+(((-1.0)*x914))+(((-1.0)*x915)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((-1.5707963267949)+j11)))), 6.28318530717959)));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j12array[1], cj12array[1], sj12array[1];
bool j12valid[1]={false};
_nj12 = 1;
IkReal x916=((3.1104199066874)*px);
IkReal x917=((3.1104199066874)*py);
if( IKabs(((((-1.0)*sj9*x916))+((cj9*x917)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((-0.73094867807154)+(((-1.0)*sj9*x917))+(((-1.0)*cj9*x916)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((((-1.0)*sj9*x916))+((cj9*x917))))+IKsqr(((-0.73094867807154)+(((-1.0)*sj9*x917))+(((-1.0)*cj9*x916))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j12array[0]=IKatan2(((((-1.0)*sj9*x916))+((cj9*x917))), ((-0.73094867807154)+(((-1.0)*sj9*x917))+(((-1.0)*cj9*x916))));
sj12array[0]=IKsin(j12array[0]);
cj12array[0]=IKcos(j12array[0]);
if( j12array[0] > IKPI )
{
    j12array[0]-=IK2PI;
}
else if( j12array[0] < -IKPI )
{    j12array[0]+=IK2PI;
}
j12valid[0] = true;
for(int ij12 = 0; ij12 < 1; ++ij12)
{
if( !j12valid[ij12] )
{
    continue;
}
_ij12[0] = ij12; _ij12[1] = -1;
for(int iij12 = ij12+1; iij12 < 1; ++iij12)
{
if( j12valid[iij12] && IKabs(cj12array[ij12]-cj12array[iij12]) < IKFAST_SOLUTION_THRESH && IKabs(sj12array[ij12]-sj12array[iij12]) < IKFAST_SOLUTION_THRESH )
{
    j12valid[iij12]=false; _ij12[1] = iij12; break; 
}
}
j12 = j12array[ij12]; cj12 = cj12array[ij12]; sj12 = sj12array[ij12];
{
IkReal evalcond[3];
IkReal x918=IKcos(j12);
IkReal x919=((1.0)*cj9);
IkReal x920=(py*sj9);
evalcond[0]=((((-1.0)*py*x919))+(((0.3215)*(IKsin(j12))))+((px*sj9)));
evalcond[1]=((0.16544)+(((0.704)*x920))+(((0.704)*cj9*px))+(((0.226336)*x918)));
evalcond[2]=((-0.235)+(((-0.3215)*x918))+(((-1.0)*px*x919))+(((-1.0)*x920)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((1.5707963267949)+j11)))), 6.28318530717959)));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j12array[1], cj12array[1], sj12array[1];
bool j12valid[1]={false};
_nj12 = 1;
IkReal x921=((3.1104199066874)*px);
IkReal x922=((3.1104199066874)*py);
if( IKabs(((((-1.0)*cj9*x922))+((sj9*x921)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((-0.73094867807154)+(((-1.0)*cj9*x921))+(((-1.0)*sj9*x922)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((((-1.0)*cj9*x922))+((sj9*x921))))+IKsqr(((-0.73094867807154)+(((-1.0)*cj9*x921))+(((-1.0)*sj9*x922))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j12array[0]=IKatan2(((((-1.0)*cj9*x922))+((sj9*x921))), ((-0.73094867807154)+(((-1.0)*cj9*x921))+(((-1.0)*sj9*x922))));
sj12array[0]=IKsin(j12array[0]);
cj12array[0]=IKcos(j12array[0]);
if( j12array[0] > IKPI )
{
    j12array[0]-=IK2PI;
}
else if( j12array[0] < -IKPI )
{    j12array[0]+=IK2PI;
}
j12valid[0] = true;
for(int ij12 = 0; ij12 < 1; ++ij12)
{
if( !j12valid[ij12] )
{
    continue;
}
_ij12[0] = ij12; _ij12[1] = -1;
for(int iij12 = ij12+1; iij12 < 1; ++iij12)
{
if( j12valid[iij12] && IKabs(cj12array[ij12]-cj12array[iij12]) < IKFAST_SOLUTION_THRESH && IKabs(sj12array[ij12]-sj12array[iij12]) < IKFAST_SOLUTION_THRESH )
{
    j12valid[iij12]=false; _ij12[1] = iij12; break; 
}
}
j12 = j12array[ij12]; cj12 = cj12array[ij12]; sj12 = sj12array[ij12];
{
IkReal evalcond[3];
IkReal x923=IKcos(j12);
IkReal x924=((1.0)*cj9);
IkReal x925=(py*sj9);
evalcond[0]=((((-0.3215)*(IKsin(j12))))+(((-1.0)*py*x924))+((px*sj9)));
evalcond[1]=((0.16544)+(((0.226336)*x923))+(((0.704)*x925))+(((0.704)*cj9*px)));
evalcond[2]=((-0.235)+(((-1.0)*px*x924))+(((-1.0)*x925))+(((-0.3215)*x923)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
if( 1 )
{
bgotonextstatement=false;
continue; // branch miss [j12]

}
} while(0);
if( bgotonextstatement )
{
}
}
}
}
}
}

} else
{
{
IkReal j12array[1], cj12array[1], sj12array[1];
bool j12valid[1]={false};
_nj12 = 1;
CheckValue<IkReal> x926=IKPowWithIntegerCheck(sj11,-1);
if(!x926.valid){
continue;
}
if( IKabs(((0.0015552099533437)*(x926.value)*(((((-2000.0)*px*sj9))+(((2000.0)*cj9*py)))))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((-0.73094867807154)+(((-3.1104199066874)*cj9*px))+(((-3.1104199066874)*py*sj9)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((0.0015552099533437)*(x926.value)*(((((-2000.0)*px*sj9))+(((2000.0)*cj9*py))))))+IKsqr(((-0.73094867807154)+(((-3.1104199066874)*cj9*px))+(((-3.1104199066874)*py*sj9))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j12array[0]=IKatan2(((0.0015552099533437)*(x926.value)*(((((-2000.0)*px*sj9))+(((2000.0)*cj9*py))))), ((-0.73094867807154)+(((-3.1104199066874)*cj9*px))+(((-3.1104199066874)*py*sj9))));
sj12array[0]=IKsin(j12array[0]);
cj12array[0]=IKcos(j12array[0]);
if( j12array[0] > IKPI )
{
    j12array[0]-=IK2PI;
}
else if( j12array[0] < -IKPI )
{    j12array[0]+=IK2PI;
}
j12valid[0] = true;
for(int ij12 = 0; ij12 < 1; ++ij12)
{
if( !j12valid[ij12] )
{
    continue;
}
_ij12[0] = ij12; _ij12[1] = -1;
for(int iij12 = ij12+1; iij12 < 1; ++iij12)
{
if( j12valid[iij12] && IKabs(cj12array[ij12]-cj12array[iij12]) < IKFAST_SOLUTION_THRESH && IKabs(sj12array[ij12]-sj12array[iij12]) < IKFAST_SOLUTION_THRESH )
{
    j12valid[iij12]=false; _ij12[1] = iij12; break; 
}
}
j12 = j12array[ij12]; cj12 = cj12array[ij12]; sj12 = sj12array[ij12];
{
IkReal evalcond[5];
IkReal x927=IKsin(j12);
IkReal x928=IKcos(j12);
IkReal x929=(py*sj9);
IkReal x930=(cj9*px);
IkReal x931=(px*sj9);
IkReal x932=((1.0)*cj9*py);
IkReal x933=((0.3215)*x927);
evalcond[0]=((-0.06)+(((-1.0)*cj11*x933))+pz);
evalcond[1]=(((sj11*x933))+x931+(((-1.0)*x932)));
evalcond[2]=((0.16544)+(((0.226336)*x928))+(((0.704)*x929))+(((0.704)*x930)));
evalcond[3]=((-0.235)+(((-1.0)*x929))+(((-1.0)*x930))+(((-0.3215)*x928)));
evalcond[4]=((((0.06)*cj11))+(((-1.0)*sj11*x932))+((sj11*x931))+(((-1.0)*cj11*pz))+x933);
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}

}

} else
{
{
IkReal j12array[1], cj12array[1], sj12array[1];
bool j12valid[1]={false};
_nj12 = 1;
CheckValue<IkReal> x934=IKPowWithIntegerCheck(cj11,-1);
if(!x934.valid){
continue;
}
if( IKabs(((0.0015552099533437)*(x934.value)*(((-120.0)+(((2000.0)*pz)))))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((-0.73094867807154)+(((-3.1104199066874)*cj9*px))+(((-3.1104199066874)*py*sj9)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((0.0015552099533437)*(x934.value)*(((-120.0)+(((2000.0)*pz))))))+IKsqr(((-0.73094867807154)+(((-3.1104199066874)*cj9*px))+(((-3.1104199066874)*py*sj9))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j12array[0]=IKatan2(((0.0015552099533437)*(x934.value)*(((-120.0)+(((2000.0)*pz))))), ((-0.73094867807154)+(((-3.1104199066874)*cj9*px))+(((-3.1104199066874)*py*sj9))));
sj12array[0]=IKsin(j12array[0]);
cj12array[0]=IKcos(j12array[0]);
if( j12array[0] > IKPI )
{
    j12array[0]-=IK2PI;
}
else if( j12array[0] < -IKPI )
{    j12array[0]+=IK2PI;
}
j12valid[0] = true;
for(int ij12 = 0; ij12 < 1; ++ij12)
{
if( !j12valid[ij12] )
{
    continue;
}
_ij12[0] = ij12; _ij12[1] = -1;
for(int iij12 = ij12+1; iij12 < 1; ++iij12)
{
if( j12valid[iij12] && IKabs(cj12array[ij12]-cj12array[iij12]) < IKFAST_SOLUTION_THRESH && IKabs(sj12array[ij12]-sj12array[iij12]) < IKFAST_SOLUTION_THRESH )
{
    j12valid[iij12]=false; _ij12[1] = iij12; break; 
}
}
j12 = j12array[ij12]; cj12 = cj12array[ij12]; sj12 = sj12array[ij12];
{
IkReal evalcond[5];
IkReal x935=IKsin(j12);
IkReal x936=IKcos(j12);
IkReal x937=(py*sj9);
IkReal x938=(cj9*px);
IkReal x939=(px*sj9);
IkReal x940=((1.0)*cj9*py);
IkReal x941=((0.3215)*x935);
evalcond[0]=((-0.06)+pz+(((-1.0)*cj11*x941)));
evalcond[1]=((((-1.0)*x940))+((sj11*x941))+x939);
evalcond[2]=((0.16544)+(((0.226336)*x936))+(((0.704)*x937))+(((0.704)*x938)));
evalcond[3]=((-0.235)+(((-1.0)*x937))+(((-1.0)*x938))+(((-0.3215)*x936)));
evalcond[4]=((((0.06)*cj11))+((sj11*x939))+(((-1.0)*cj11*pz))+(((-1.0)*sj11*x940))+x941);
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}

}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((-1.5707963267949)+j10)))), 6.28318530717959)));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j12array[1], cj12array[1], sj12array[1];
bool j12valid[1]={false};
_nj12 = 1;
IkReal x942=((3.1104199066874)*cj9);
IkReal x943=((3.1104199066874)*sj9);
if( IKabs((((py*sj11*x942))+(((-1.0)*px*sj11*x943))+(((-1.0)*cj11*px*x942))+(((-1.0)*cj11*py*x943))+(((0.363919129082426)*cj11)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((-0.908242612752722)+(((-3.1104199066874)*pz)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr((((py*sj11*x942))+(((-1.0)*px*sj11*x943))+(((-1.0)*cj11*px*x942))+(((-1.0)*cj11*py*x943))+(((0.363919129082426)*cj11))))+IKsqr(((-0.908242612752722)+(((-3.1104199066874)*pz))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j12array[0]=IKatan2((((py*sj11*x942))+(((-1.0)*px*sj11*x943))+(((-1.0)*cj11*px*x942))+(((-1.0)*cj11*py*x943))+(((0.363919129082426)*cj11))), ((-0.908242612752722)+(((-3.1104199066874)*pz))));
sj12array[0]=IKsin(j12array[0]);
cj12array[0]=IKcos(j12array[0]);
if( j12array[0] > IKPI )
{
    j12array[0]-=IK2PI;
}
else if( j12array[0] < -IKPI )
{    j12array[0]+=IK2PI;
}
j12valid[0] = true;
for(int ij12 = 0; ij12 < 1; ++ij12)
{
if( !j12valid[ij12] )
{
    continue;
}
_ij12[0] = ij12; _ij12[1] = -1;
for(int iij12 = ij12+1; iij12 < 1; ++iij12)
{
if( j12valid[iij12] && IKabs(cj12array[ij12]-cj12array[iij12]) < IKFAST_SOLUTION_THRESH && IKabs(sj12array[ij12]-sj12array[iij12]) < IKFAST_SOLUTION_THRESH )
{
    j12valid[iij12]=false; _ij12[1] = iij12; break; 
}
}
j12 = j12array[ij12]; cj12 = cj12array[ij12]; sj12 = sj12array[ij12];
{
IkReal evalcond[5];
IkReal x944=IKsin(j12);
IkReal x945=IKcos(j12);
IkReal x946=(cj9*px);
IkReal x947=(py*sj9);
IkReal x948=(px*sj9);
IkReal x949=((1.0)*cj9*py);
IkReal x950=((0.3215)*x944);
evalcond[0]=((0.292)+(((0.3215)*x945))+pz);
evalcond[1]=((((-1.0)*x949))+x948+((sj11*x950)));
evalcond[2]=((0.117)+(((-1.0)*x946))+(((-1.0)*x947))+(((-1.0)*cj11*x950)));
evalcond[3]=((0.210883260273973)+(((0.226336)*x945))+(((0.282082191780822)*x947))+(((0.282082191780822)*x946))+(((-1.20547945205479)*pp)));
evalcond[4]=(((cj11*x946))+((cj11*x947))+(((-0.117)*cj11))+(((-1.0)*sj11*x949))+((sj11*x948))+x950);
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((1.5707963267949)+j10)))), 6.28318530717959)));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j12eval[1];
sj10=-1.0;
cj10=0;
j10=-1.5707963267949;
j12eval[0]=sj11;
if( IKabs(j12eval[0]) < 0.0000010000000000  )
{
{
IkReal j12eval[1];
sj10=-1.0;
cj10=0;
j10=-1.5707963267949;
j12eval[0]=cj11;
if( IKabs(j12eval[0]) < 0.0000010000000000  )
{
{
IkReal evalcond[1];
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((-1.5707963267949)+j11)))), 6.28318530717959)));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j12array[1], cj12array[1], sj12array[1];
bool j12valid[1]={false};
_nj12 = 1;
if( IKabs(((((-3.1104199066874)*px*sj9))+(((3.1104199066874)*cj9*py)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((-1.28149300155521)+(((3.1104199066874)*pz)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((((-3.1104199066874)*px*sj9))+(((3.1104199066874)*cj9*py))))+IKsqr(((-1.28149300155521)+(((3.1104199066874)*pz))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j12array[0]=IKatan2(((((-3.1104199066874)*px*sj9))+(((3.1104199066874)*cj9*py))), ((-1.28149300155521)+(((3.1104199066874)*pz))));
sj12array[0]=IKsin(j12array[0]);
cj12array[0]=IKcos(j12array[0]);
if( j12array[0] > IKPI )
{
    j12array[0]-=IK2PI;
}
else if( j12array[0] < -IKPI )
{    j12array[0]+=IK2PI;
}
j12valid[0] = true;
for(int ij12 = 0; ij12 < 1; ++ij12)
{
if( !j12valid[ij12] )
{
    continue;
}
_ij12[0] = ij12; _ij12[1] = -1;
for(int iij12 = ij12+1; iij12 < 1; ++iij12)
{
if( j12valid[iij12] && IKabs(cj12array[ij12]-cj12array[iij12]) < IKFAST_SOLUTION_THRESH && IKabs(sj12array[ij12]-sj12array[iij12]) < IKFAST_SOLUTION_THRESH )
{
    j12valid[iij12]=false; _ij12[1] = iij12; break; 
}
}
j12 = j12array[ij12]; cj12 = cj12array[ij12]; sj12 = sj12array[ij12];
{
IkReal evalcond[3];
IkReal x951=IKcos(j12);
evalcond[0]=((-0.412)+pz+(((-0.3215)*x951)));
evalcond[1]=((0.245028951456311)+(((0.226336)*x951))+(((-0.854368932038835)*pp)));
evalcond[2]=((((0.3215)*(IKsin(j12))))+((px*sj9))+(((-1.0)*cj9*py)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((1.5707963267949)+j11)))), 6.28318530717959)));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j12array[1], cj12array[1], sj12array[1];
bool j12valid[1]={false};
_nj12 = 1;
if( IKabs(((((-3.1104199066874)*cj9*py))+(((3.1104199066874)*px*sj9)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((-1.28149300155521)+(((3.1104199066874)*pz)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((((-3.1104199066874)*cj9*py))+(((3.1104199066874)*px*sj9))))+IKsqr(((-1.28149300155521)+(((3.1104199066874)*pz))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j12array[0]=IKatan2(((((-3.1104199066874)*cj9*py))+(((3.1104199066874)*px*sj9))), ((-1.28149300155521)+(((3.1104199066874)*pz))));
sj12array[0]=IKsin(j12array[0]);
cj12array[0]=IKcos(j12array[0]);
if( j12array[0] > IKPI )
{
    j12array[0]-=IK2PI;
}
else if( j12array[0] < -IKPI )
{    j12array[0]+=IK2PI;
}
j12valid[0] = true;
for(int ij12 = 0; ij12 < 1; ++ij12)
{
if( !j12valid[ij12] )
{
    continue;
}
_ij12[0] = ij12; _ij12[1] = -1;
for(int iij12 = ij12+1; iij12 < 1; ++iij12)
{
if( j12valid[iij12] && IKabs(cj12array[ij12]-cj12array[iij12]) < IKFAST_SOLUTION_THRESH && IKabs(sj12array[ij12]-sj12array[iij12]) < IKFAST_SOLUTION_THRESH )
{
    j12valid[iij12]=false; _ij12[1] = iij12; break; 
}
}
j12 = j12array[ij12]; cj12 = cj12array[ij12]; sj12 = sj12array[ij12];
{
IkReal evalcond[3];
IkReal x952=IKcos(j12);
evalcond[0]=((-0.412)+pz+(((-0.3215)*x952)));
evalcond[1]=((0.245028951456311)+(((0.226336)*x952))+(((-0.854368932038835)*pp)));
evalcond[2]=((((-0.3215)*(IKsin(j12))))+((px*sj9))+(((-1.0)*cj9*py)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(j11))), 6.28318530717959)));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j12array[1], cj12array[1], sj12array[1];
bool j12valid[1]={false};
_nj12 = 1;
if( IKabs(((-0.363919129082426)+(((3.1104199066874)*py*sj9))+(((3.1104199066874)*cj9*px)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((-1.28149300155521)+(((3.1104199066874)*pz)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((-0.363919129082426)+(((3.1104199066874)*py*sj9))+(((3.1104199066874)*cj9*px))))+IKsqr(((-1.28149300155521)+(((3.1104199066874)*pz))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j12array[0]=IKatan2(((-0.363919129082426)+(((3.1104199066874)*py*sj9))+(((3.1104199066874)*cj9*px))), ((-1.28149300155521)+(((3.1104199066874)*pz))));
sj12array[0]=IKsin(j12array[0]);
cj12array[0]=IKcos(j12array[0]);
if( j12array[0] > IKPI )
{
    j12array[0]-=IK2PI;
}
else if( j12array[0] < -IKPI )
{    j12array[0]+=IK2PI;
}
j12valid[0] = true;
for(int ij12 = 0; ij12 < 1; ++ij12)
{
if( !j12valid[ij12] )
{
    continue;
}
_ij12[0] = ij12; _ij12[1] = -1;
for(int iij12 = ij12+1; iij12 < 1; ++iij12)
{
if( j12valid[iij12] && IKabs(cj12array[ij12]-cj12array[iij12]) < IKFAST_SOLUTION_THRESH && IKabs(sj12array[ij12]-sj12array[iij12]) < IKFAST_SOLUTION_THRESH )
{
    j12valid[iij12]=false; _ij12[1] = iij12; break; 
}
}
j12 = j12array[ij12]; cj12 = cj12array[ij12]; sj12 = sj12array[ij12];
{
IkReal evalcond[3];
IkReal x953=IKcos(j12);
IkReal x954=(cj9*px);
IkReal x955=(py*sj9);
evalcond[0]=((-0.412)+pz+(((-0.3215)*x953)));
evalcond[1]=((0.117)+(((-1.0)*x955))+(((-1.0)*x954))+(((0.3215)*(IKsin(j12)))));
evalcond[2]=((0.221638038834951)+(((0.226336)*x953))+(((0.199922330097087)*x954))+(((0.199922330097087)*x955))+(((-0.854368932038835)*pp)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((-3.14159265358979)+j11)))), 6.28318530717959)));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j12array[1], cj12array[1], sj12array[1];
bool j12valid[1]={false};
_nj12 = 1;
if( IKabs(((0.363919129082426)+(((-3.1104199066874)*cj9*px))+(((-3.1104199066874)*py*sj9)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((-1.28149300155521)+(((3.1104199066874)*pz)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((0.363919129082426)+(((-3.1104199066874)*cj9*px))+(((-3.1104199066874)*py*sj9))))+IKsqr(((-1.28149300155521)+(((3.1104199066874)*pz))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j12array[0]=IKatan2(((0.363919129082426)+(((-3.1104199066874)*cj9*px))+(((-3.1104199066874)*py*sj9))), ((-1.28149300155521)+(((3.1104199066874)*pz))));
sj12array[0]=IKsin(j12array[0]);
cj12array[0]=IKcos(j12array[0]);
if( j12array[0] > IKPI )
{
    j12array[0]-=IK2PI;
}
else if( j12array[0] < -IKPI )
{    j12array[0]+=IK2PI;
}
j12valid[0] = true;
for(int ij12 = 0; ij12 < 1; ++ij12)
{
if( !j12valid[ij12] )
{
    continue;
}
_ij12[0] = ij12; _ij12[1] = -1;
for(int iij12 = ij12+1; iij12 < 1; ++iij12)
{
if( j12valid[iij12] && IKabs(cj12array[ij12]-cj12array[iij12]) < IKFAST_SOLUTION_THRESH && IKabs(sj12array[ij12]-sj12array[iij12]) < IKFAST_SOLUTION_THRESH )
{
    j12valid[iij12]=false; _ij12[1] = iij12; break; 
}
}
j12 = j12array[ij12]; cj12 = cj12array[ij12]; sj12 = sj12array[ij12];
{
IkReal evalcond[3];
IkReal x956=IKcos(j12);
IkReal x957=(cj9*px);
IkReal x958=(py*sj9);
evalcond[0]=((-0.412)+pz+(((-0.3215)*x956)));
evalcond[1]=((0.117)+(((-0.3215)*(IKsin(j12))))+(((-1.0)*x958))+(((-1.0)*x957)));
evalcond[2]=((0.221638038834951)+(((0.226336)*x956))+(((0.199922330097087)*x958))+(((0.199922330097087)*x957))+(((-0.854368932038835)*pp)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
if( 1 )
{
bgotonextstatement=false;
continue; // branch miss [j12]

}
} while(0);
if( bgotonextstatement )
{
}
}
}
}
}
}

} else
{
{
IkReal j12array[1], cj12array[1], sj12array[1];
bool j12valid[1]={false};
_nj12 = 1;
CheckValue<IkReal> x959=IKPowWithIntegerCheck(cj11,-1);
if(!x959.valid){
continue;
}
if( IKabs(((0.0015552099533437)*(x959.value)*(((-234.0)+(((2000.0)*py*sj9))+(((2000.0)*cj9*px)))))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((-1.28149300155521)+(((3.1104199066874)*pz)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((0.0015552099533437)*(x959.value)*(((-234.0)+(((2000.0)*py*sj9))+(((2000.0)*cj9*px))))))+IKsqr(((-1.28149300155521)+(((3.1104199066874)*pz))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j12array[0]=IKatan2(((0.0015552099533437)*(x959.value)*(((-234.0)+(((2000.0)*py*sj9))+(((2000.0)*cj9*px))))), ((-1.28149300155521)+(((3.1104199066874)*pz))));
sj12array[0]=IKsin(j12array[0]);
cj12array[0]=IKcos(j12array[0]);
if( j12array[0] > IKPI )
{
    j12array[0]-=IK2PI;
}
else if( j12array[0] < -IKPI )
{    j12array[0]+=IK2PI;
}
j12valid[0] = true;
for(int ij12 = 0; ij12 < 1; ++ij12)
{
if( !j12valid[ij12] )
{
    continue;
}
_ij12[0] = ij12; _ij12[1] = -1;
for(int iij12 = ij12+1; iij12 < 1; ++iij12)
{
if( j12valid[iij12] && IKabs(cj12array[ij12]-cj12array[iij12]) < IKFAST_SOLUTION_THRESH && IKabs(sj12array[ij12]-sj12array[iij12]) < IKFAST_SOLUTION_THRESH )
{
    j12valid[iij12]=false; _ij12[1] = iij12; break; 
}
}
j12 = j12array[ij12]; cj12 = cj12array[ij12]; sj12 = sj12array[ij12];
{
IkReal evalcond[5];
IkReal x960=IKsin(j12);
IkReal x961=IKcos(j12);
IkReal x962=(cj9*px);
IkReal x963=(py*sj9);
IkReal x964=(px*sj9);
IkReal x965=((1.0)*cj11);
IkReal x966=((1.0)*cj9*py);
IkReal x967=((0.3215)*x960);
evalcond[0]=((-0.412)+pz+(((-0.3215)*x961)));
evalcond[1]=(((sj11*x967))+x964+(((-1.0)*x966)));
evalcond[2]=((0.117)+((cj11*x967))+(((-1.0)*x963))+(((-1.0)*x962)));
evalcond[3]=((0.221638038834951)+(((0.226336)*x961))+(((0.199922330097087)*x963))+(((0.199922330097087)*x962))+(((-0.854368932038835)*pp)));
evalcond[4]=(((sj11*x964))+(((-1.0)*x962*x965))+(((-1.0)*x963*x965))+(((0.117)*cj11))+x967+(((-1.0)*sj11*x966)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}

}

} else
{
{
IkReal j12array[1], cj12array[1], sj12array[1];
bool j12valid[1]={false};
_nj12 = 1;
CheckValue<IkReal> x968=IKPowWithIntegerCheck(sj11,-1);
if(!x968.valid){
continue;
}
if( IKabs(((0.0015552099533437)*(x968.value)*(((((-2000.0)*px*sj9))+(((2000.0)*cj9*py)))))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((-1.28149300155521)+(((3.1104199066874)*pz)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((0.0015552099533437)*(x968.value)*(((((-2000.0)*px*sj9))+(((2000.0)*cj9*py))))))+IKsqr(((-1.28149300155521)+(((3.1104199066874)*pz))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j12array[0]=IKatan2(((0.0015552099533437)*(x968.value)*(((((-2000.0)*px*sj9))+(((2000.0)*cj9*py))))), ((-1.28149300155521)+(((3.1104199066874)*pz))));
sj12array[0]=IKsin(j12array[0]);
cj12array[0]=IKcos(j12array[0]);
if( j12array[0] > IKPI )
{
    j12array[0]-=IK2PI;
}
else if( j12array[0] < -IKPI )
{    j12array[0]+=IK2PI;
}
j12valid[0] = true;
for(int ij12 = 0; ij12 < 1; ++ij12)
{
if( !j12valid[ij12] )
{
    continue;
}
_ij12[0] = ij12; _ij12[1] = -1;
for(int iij12 = ij12+1; iij12 < 1; ++iij12)
{
if( j12valid[iij12] && IKabs(cj12array[ij12]-cj12array[iij12]) < IKFAST_SOLUTION_THRESH && IKabs(sj12array[ij12]-sj12array[iij12]) < IKFAST_SOLUTION_THRESH )
{
    j12valid[iij12]=false; _ij12[1] = iij12; break; 
}
}
j12 = j12array[ij12]; cj12 = cj12array[ij12]; sj12 = sj12array[ij12];
{
IkReal evalcond[5];
IkReal x969=IKsin(j12);
IkReal x970=IKcos(j12);
IkReal x971=(cj9*px);
IkReal x972=(py*sj9);
IkReal x973=(px*sj9);
IkReal x974=((1.0)*cj11);
IkReal x975=((1.0)*cj9*py);
IkReal x976=((0.3215)*x969);
evalcond[0]=((-0.412)+(((-0.3215)*x970))+pz);
evalcond[1]=(((sj11*x976))+x973+(((-1.0)*x975)));
evalcond[2]=((0.117)+(((-1.0)*x972))+(((-1.0)*x971))+((cj11*x976)));
evalcond[3]=((0.221638038834951)+(((0.226336)*x970))+(((0.199922330097087)*x972))+(((0.199922330097087)*x971))+(((-0.854368932038835)*pp)));
evalcond[4]=(((sj11*x973))+(((0.117)*cj11))+(((-1.0)*x971*x974))+(((-1.0)*sj11*x975))+(((-1.0)*x972*x974))+x976);
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}

}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((-1.5707963267949)+j11)))), 6.28318530717959)));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j12array[1], cj12array[1], sj12array[1];
bool j12valid[1]={false};
_nj12 = 1;
if( IKabs(((((-3.1104199066874)*px*sj9))+(((3.1104199066874)*cj9*py)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((-0.927723605612894)+(((-0.530185211367171)*pz))+(((-1.03386116216598)*cj9*px))+(((4.41821009472642)*pp))+(((-1.03386116216598)*py*sj9)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((((-3.1104199066874)*px*sj9))+(((3.1104199066874)*cj9*py))))+IKsqr(((-0.927723605612894)+(((-0.530185211367171)*pz))+(((-1.03386116216598)*cj9*px))+(((4.41821009472642)*pp))+(((-1.03386116216598)*py*sj9))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j12array[0]=IKatan2(((((-3.1104199066874)*px*sj9))+(((3.1104199066874)*cj9*py))), ((-0.927723605612894)+(((-0.530185211367171)*pz))+(((-1.03386116216598)*cj9*px))+(((4.41821009472642)*pp))+(((-1.03386116216598)*py*sj9))));
sj12array[0]=IKsin(j12array[0]);
cj12array[0]=IKcos(j12array[0]);
if( j12array[0] > IKPI )
{
    j12array[0]-=IK2PI;
}
else if( j12array[0] < -IKPI )
{    j12array[0]+=IK2PI;
}
j12valid[0] = true;
for(int ij12 = 0; ij12 < 1; ++ij12)
{
if( !j12valid[ij12] )
{
    continue;
}
_ij12[0] = ij12; _ij12[1] = -1;
for(int iij12 = ij12+1; iij12 < 1; ++iij12)
{
if( j12valid[iij12] && IKabs(cj12array[ij12]-cj12array[iij12]) < IKFAST_SOLUTION_THRESH && IKabs(sj12array[ij12]-sj12array[iij12]) < IKFAST_SOLUTION_THRESH )
{
    j12valid[iij12]=false; _ij12[1] = iij12; break; 
}
}
j12 = j12array[ij12]; cj12 = cj12array[ij12]; sj12 = sj12array[ij12];
{
IkReal evalcond[5];
IkReal x977=IKcos(j12);
IkReal x978=((1.0)*cj9);
IkReal x979=(py*sj9);
IkReal x980=((0.3215)*x977);
evalcond[0]=((-0.06)+(((0.352)*sj10))+((sj10*x980))+pz);
evalcond[1]=((((-1.0)*py*x978))+(((0.3215)*(IKsin(j12))))+((px*sj9)));
evalcond[2]=((0.117)+(((-1.0)*px*x978))+(((0.352)*cj10))+(((-1.0)*x979))+((cj10*x980)));
evalcond[3]=((0.20997725)+(((0.12)*pz))+(((0.234)*cj9*px))+(((0.226336)*x977))+(((-1.0)*pp))+(((0.234)*x979)));
evalcond[4]=((0.352)+(((-1.0)*cj10*x979))+(((-1.0)*cj10*px*x978))+(((-0.06)*sj10))+(((0.117)*cj10))+((pz*sj10))+x980);
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((1.5707963267949)+j11)))), 6.28318530717959)));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j12array[1], cj12array[1], sj12array[1];
bool j12valid[1]={false};
_nj12 = 1;
if( IKabs(((((-3.1104199066874)*cj9*py))+(((3.1104199066874)*px*sj9)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((-0.927723605612894)+(((-0.530185211367171)*pz))+(((-1.03386116216598)*cj9*px))+(((4.41821009472642)*pp))+(((-1.03386116216598)*py*sj9)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((((-3.1104199066874)*cj9*py))+(((3.1104199066874)*px*sj9))))+IKsqr(((-0.927723605612894)+(((-0.530185211367171)*pz))+(((-1.03386116216598)*cj9*px))+(((4.41821009472642)*pp))+(((-1.03386116216598)*py*sj9))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j12array[0]=IKatan2(((((-3.1104199066874)*cj9*py))+(((3.1104199066874)*px*sj9))), ((-0.927723605612894)+(((-0.530185211367171)*pz))+(((-1.03386116216598)*cj9*px))+(((4.41821009472642)*pp))+(((-1.03386116216598)*py*sj9))));
sj12array[0]=IKsin(j12array[0]);
cj12array[0]=IKcos(j12array[0]);
if( j12array[0] > IKPI )
{
    j12array[0]-=IK2PI;
}
else if( j12array[0] < -IKPI )
{    j12array[0]+=IK2PI;
}
j12valid[0] = true;
for(int ij12 = 0; ij12 < 1; ++ij12)
{
if( !j12valid[ij12] )
{
    continue;
}
_ij12[0] = ij12; _ij12[1] = -1;
for(int iij12 = ij12+1; iij12 < 1; ++iij12)
{
if( j12valid[iij12] && IKabs(cj12array[ij12]-cj12array[iij12]) < IKFAST_SOLUTION_THRESH && IKabs(sj12array[ij12]-sj12array[iij12]) < IKFAST_SOLUTION_THRESH )
{
    j12valid[iij12]=false; _ij12[1] = iij12; break; 
}
}
j12 = j12array[ij12]; cj12 = cj12array[ij12]; sj12 = sj12array[ij12];
{
IkReal evalcond[5];
IkReal x981=IKcos(j12);
IkReal x982=((1.0)*cj9);
IkReal x983=(py*sj9);
IkReal x984=((0.3215)*x981);
evalcond[0]=((-0.06)+(((0.352)*sj10))+((sj10*x984))+pz);
evalcond[1]=((((-0.3215)*(IKsin(j12))))+(((-1.0)*py*x982))+((px*sj9)));
evalcond[2]=((0.117)+(((-1.0)*px*x982))+(((0.352)*cj10))+(((-1.0)*x983))+((cj10*x984)));
evalcond[3]=((0.20997725)+(((0.12)*pz))+(((0.234)*cj9*px))+(((0.226336)*x981))+(((-1.0)*pp))+(((0.234)*x983)));
evalcond[4]=((0.352)+(((-1.0)*cj10*px*x982))+(((-1.0)*cj10*x983))+(((-0.06)*sj10))+(((0.117)*cj10))+((pz*sj10))+x984);
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
if( 1 )
{
bgotonextstatement=false;
continue; // branch miss [j12]

}
} while(0);
if( bgotonextstatement )
{
}
}
}
}
}
}
}
}
}
}

} else
{
{
IkReal j12array[1], cj12array[1], sj12array[1];
bool j12valid[1]={false};
_nj12 = 1;
CheckValue<IkReal> x990=IKPowWithIntegerCheck(sj11,-1);
if(!x990.valid){
continue;
}
IkReal x985=x990.value;
IkReal x986=((0.0015552099533437)*x985);
IkReal x987=(cj10*cj11);
IkReal x988=((2000.0)*px*sj9);
IkReal x989=((2000.0)*cj9*py);
CheckValue<IkReal> x991=IKPowWithIntegerCheck(sj10,-1);
if(!x991.valid){
continue;
}
if( IKabs((x986*(((((-1.0)*x988))+x989)))) < IKFAST_ATAN2_MAGTHRESH && IKabs((x986*(x991.value)*(((((-2000.0)*pz*sj11))+(((-1.0)*x987*x989))+(((120.0)*sj11))+(((-704.0)*sj10*sj11))+((x987*x988)))))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr((x986*(((((-1.0)*x988))+x989))))+IKsqr((x986*(x991.value)*(((((-2000.0)*pz*sj11))+(((-1.0)*x987*x989))+(((120.0)*sj11))+(((-704.0)*sj10*sj11))+((x987*x988))))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j12array[0]=IKatan2((x986*(((((-1.0)*x988))+x989))), (x986*(x991.value)*(((((-2000.0)*pz*sj11))+(((-1.0)*x987*x989))+(((120.0)*sj11))+(((-704.0)*sj10*sj11))+((x987*x988))))));
sj12array[0]=IKsin(j12array[0]);
cj12array[0]=IKcos(j12array[0]);
if( j12array[0] > IKPI )
{
    j12array[0]-=IK2PI;
}
else if( j12array[0] < -IKPI )
{    j12array[0]+=IK2PI;
}
j12valid[0] = true;
for(int ij12 = 0; ij12 < 1; ++ij12)
{
if( !j12valid[ij12] )
{
    continue;
}
_ij12[0] = ij12; _ij12[1] = -1;
for(int iij12 = ij12+1; iij12 < 1; ++iij12)
{
if( j12valid[iij12] && IKabs(cj12array[ij12]-cj12array[iij12]) < IKFAST_SOLUTION_THRESH && IKabs(sj12array[ij12]-sj12array[iij12]) < IKFAST_SOLUTION_THRESH )
{
    j12valid[iij12]=false; _ij12[1] = iij12; break; 
}
}
j12 = j12array[ij12]; cj12 = cj12array[ij12]; sj12 = sj12array[ij12];
{
IkReal evalcond[6];
IkReal x992=IKsin(j12);
IkReal x993=IKcos(j12);
IkReal x994=((1.0)*py);
IkReal x995=(px*sj9);
IkReal x996=(cj9*px);
IkReal x997=(py*sj9);
IkReal x998=(cj10*cj11);
IkReal x999=(cj11*sj10);
IkReal x1000=((0.3215)*x992);
IkReal x1001=((0.3215)*x993);
evalcond[0]=(((sj11*x1000))+x995+(((-1.0)*cj9*x994)));
evalcond[1]=((-0.06)+((x1000*x998))+(((0.352)*sj10))+pz+((sj10*x1001)));
evalcond[2]=((0.20997725)+(((0.12)*pz))+(((0.226336)*x993))+(((-1.0)*pp))+(((0.234)*x996))+(((0.234)*x997)));
evalcond[3]=((0.117)+(((-1.0)*x996))+((cj10*x1001))+(((0.352)*cj10))+(((-1.0)*x1000*x999))+(((-1.0)*sj9*x994)));
evalcond[4]=((0.352)+x1001+(((-0.06)*sj10))+(((0.117)*cj10))+((pz*sj10))+(((-1.0)*cj10*sj9*x994))+(((-1.0)*cj10*x996)));
evalcond[5]=(x1000+((pz*x998))+((sj11*x995))+(((-0.117)*x999))+((x997*x999))+(((-0.06)*x998))+(((-1.0)*cj9*sj11*x994))+((x996*x999)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}

}

} else
{
{
IkReal j12array[1], cj12array[1], sj12array[1];
bool j12valid[1]={false};
_nj12 = 1;
IkReal x1002=(cj9*px);
IkReal x1003=((7312.5)*sj10);
IkReal x1004=(py*sj9);
CheckValue<IkReal> x1005=IKPowWithIntegerCheck(cj10,-1);
if(!x1005.valid){
continue;
}
CheckValue<IkReal> x1006=IKPowWithIntegerCheck(cj11,-1);
if(!x1006.valid){
continue;
}
if( IKabs(((0.000141382723031246)*(x1005.value)*(x1006.value)*(((1320.0)+(((-22000.0)*pz))+(((-1182.2109375)*sj10))+(((-31250.0)*pp*sj10))+((x1002*x1003))+(((3750.0)*pz*sj10))+((x1003*x1004)))))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((-0.927723605612894)+(((-0.530185211367171)*pz))+(((-1.03386116216598)*x1004))+(((-1.03386116216598)*x1002))+(((4.41821009472642)*pp)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((0.000141382723031246)*(x1005.value)*(x1006.value)*(((1320.0)+(((-22000.0)*pz))+(((-1182.2109375)*sj10))+(((-31250.0)*pp*sj10))+((x1002*x1003))+(((3750.0)*pz*sj10))+((x1003*x1004))))))+IKsqr(((-0.927723605612894)+(((-0.530185211367171)*pz))+(((-1.03386116216598)*x1004))+(((-1.03386116216598)*x1002))+(((4.41821009472642)*pp))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j12array[0]=IKatan2(((0.000141382723031246)*(x1005.value)*(x1006.value)*(((1320.0)+(((-22000.0)*pz))+(((-1182.2109375)*sj10))+(((-31250.0)*pp*sj10))+((x1002*x1003))+(((3750.0)*pz*sj10))+((x1003*x1004))))), ((-0.927723605612894)+(((-0.530185211367171)*pz))+(((-1.03386116216598)*x1004))+(((-1.03386116216598)*x1002))+(((4.41821009472642)*pp))));
sj12array[0]=IKsin(j12array[0]);
cj12array[0]=IKcos(j12array[0]);
if( j12array[0] > IKPI )
{
    j12array[0]-=IK2PI;
}
else if( j12array[0] < -IKPI )
{    j12array[0]+=IK2PI;
}
j12valid[0] = true;
for(int ij12 = 0; ij12 < 1; ++ij12)
{
if( !j12valid[ij12] )
{
    continue;
}
_ij12[0] = ij12; _ij12[1] = -1;
for(int iij12 = ij12+1; iij12 < 1; ++iij12)
{
if( j12valid[iij12] && IKabs(cj12array[ij12]-cj12array[iij12]) < IKFAST_SOLUTION_THRESH && IKabs(sj12array[ij12]-sj12array[iij12]) < IKFAST_SOLUTION_THRESH )
{
    j12valid[iij12]=false; _ij12[1] = iij12; break; 
}
}
j12 = j12array[ij12]; cj12 = cj12array[ij12]; sj12 = sj12array[ij12];
{
IkReal evalcond[6];
IkReal x1007=IKsin(j12);
IkReal x1008=IKcos(j12);
IkReal x1009=((1.0)*py);
IkReal x1010=(px*sj9);
IkReal x1011=(cj9*px);
IkReal x1012=(py*sj9);
IkReal x1013=(cj10*cj11);
IkReal x1014=(cj11*sj10);
IkReal x1015=((0.3215)*x1007);
IkReal x1016=((0.3215)*x1008);
evalcond[0]=(x1010+(((-1.0)*cj9*x1009))+((sj11*x1015)));
evalcond[1]=((-0.06)+(((0.352)*sj10))+((x1013*x1015))+pz+((sj10*x1016)));
evalcond[2]=((0.20997725)+(((0.12)*pz))+(((0.226336)*x1008))+(((-1.0)*pp))+(((0.234)*x1011))+(((0.234)*x1012)));
evalcond[3]=((0.117)+((cj10*x1016))+(((0.352)*cj10))+(((-1.0)*x1014*x1015))+(((-1.0)*sj9*x1009))+(((-1.0)*x1011)));
evalcond[4]=((0.352)+x1016+(((-1.0)*cj10*sj9*x1009))+(((-0.06)*sj10))+(((0.117)*cj10))+(((-1.0)*cj10*x1011))+((pz*sj10)));
evalcond[5]=(x1015+(((-0.06)*x1013))+(((-0.117)*x1014))+((x1012*x1014))+((sj11*x1010))+((pz*x1013))+(((-1.0)*cj9*sj11*x1009))+((x1011*x1014)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}

}

} else
{
{
IkReal j12array[1], cj12array[1], sj12array[1];
bool j12valid[1]={false};
_nj12 = 1;
CheckValue<IkReal> x1017=IKPowWithIntegerCheck(sj11,-1);
if(!x1017.valid){
continue;
}
if( IKabs(((0.0015552099533437)*(x1017.value)*(((((-2000.0)*px*sj9))+(((2000.0)*cj9*py)))))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((-0.927723605612894)+(((-0.530185211367171)*pz))+(((-1.03386116216598)*cj9*px))+(((4.41821009472642)*pp))+(((-1.03386116216598)*py*sj9)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((0.0015552099533437)*(x1017.value)*(((((-2000.0)*px*sj9))+(((2000.0)*cj9*py))))))+IKsqr(((-0.927723605612894)+(((-0.530185211367171)*pz))+(((-1.03386116216598)*cj9*px))+(((4.41821009472642)*pp))+(((-1.03386116216598)*py*sj9))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j12array[0]=IKatan2(((0.0015552099533437)*(x1017.value)*(((((-2000.0)*px*sj9))+(((2000.0)*cj9*py))))), ((-0.927723605612894)+(((-0.530185211367171)*pz))+(((-1.03386116216598)*cj9*px))+(((4.41821009472642)*pp))+(((-1.03386116216598)*py*sj9))));
sj12array[0]=IKsin(j12array[0]);
cj12array[0]=IKcos(j12array[0]);
if( j12array[0] > IKPI )
{
    j12array[0]-=IK2PI;
}
else if( j12array[0] < -IKPI )
{    j12array[0]+=IK2PI;
}
j12valid[0] = true;
for(int ij12 = 0; ij12 < 1; ++ij12)
{
if( !j12valid[ij12] )
{
    continue;
}
_ij12[0] = ij12; _ij12[1] = -1;
for(int iij12 = ij12+1; iij12 < 1; ++iij12)
{
if( j12valid[iij12] && IKabs(cj12array[ij12]-cj12array[iij12]) < IKFAST_SOLUTION_THRESH && IKabs(sj12array[ij12]-sj12array[iij12]) < IKFAST_SOLUTION_THRESH )
{
    j12valid[iij12]=false; _ij12[1] = iij12; break; 
}
}
j12 = j12array[ij12]; cj12 = cj12array[ij12]; sj12 = sj12array[ij12];
{
IkReal evalcond[6];
IkReal x1018=IKsin(j12);
IkReal x1019=IKcos(j12);
IkReal x1020=((1.0)*py);
IkReal x1021=(px*sj9);
IkReal x1022=(cj9*px);
IkReal x1023=(py*sj9);
IkReal x1024=(cj10*cj11);
IkReal x1025=(cj11*sj10);
IkReal x1026=((0.3215)*x1018);
IkReal x1027=((0.3215)*x1019);
evalcond[0]=(x1021+((sj11*x1026))+(((-1.0)*cj9*x1020)));
evalcond[1]=((-0.06)+(((0.352)*sj10))+pz+((x1024*x1026))+((sj10*x1027)));
evalcond[2]=((0.20997725)+(((0.12)*pz))+(((0.226336)*x1019))+(((-1.0)*pp))+(((0.234)*x1023))+(((0.234)*x1022)));
evalcond[3]=((0.117)+(((0.352)*cj10))+(((-1.0)*x1022))+((cj10*x1027))+(((-1.0)*sj9*x1020))+(((-1.0)*x1025*x1026)));
evalcond[4]=((0.352)+x1027+(((-0.06)*sj10))+(((-1.0)*cj10*sj9*x1020))+(((0.117)*cj10))+((pz*sj10))+(((-1.0)*cj10*x1022)));
evalcond[5]=((((-1.0)*cj9*sj11*x1020))+(((-0.117)*x1025))+x1026+((sj11*x1021))+((x1023*x1025))+((x1022*x1025))+(((-0.06)*x1024))+((pz*x1024)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}

}
}
}

}

}
    }
}
return solutions.GetNumSolutions()>0;
}
inline void rotationfunction0(IkSolutionListBase<IkReal>& solutions) {
for(int rotationiter = 0; rotationiter < 1; ++rotationiter) {
IkReal x193=((1.0)*sj10);
IkReal x194=((1.0)*sj12);
IkReal x195=(sj11*sj9);
IkReal x196=(cj10*cj12);
IkReal x197=(cj9*sj11);
IkReal x198=(cj10*sj11);
IkReal x199=((1.0)*cj11);
IkReal x200=((((-1.0)*x196*x199))+((sj10*sj12)));
IkReal x201=(((sj10*x195))+((cj11*cj9)));
IkReal x202=((((-1.0)*sj9*x199))+((sj10*x197)));
IkReal x203=(x196+(((-1.0)*cj11*sj12*x193)));
IkReal x204=(cj9*x203);
IkReal x205=((((-1.0)*cj10*x194))+(((-1.0)*cj11*cj12*x193)));
IkReal x206=((((-1.0)*cj10*cj11*x194))+(((-1.0)*cj12*x193)));
IkReal x207=(cj9*x205);
IkReal x208=(((sj12*x197))+((sj9*x203)));
IkReal x209=(x204+(((-1.0)*sj12*x195)));
IkReal x210=(((cj12*x197))+((sj9*x205)));
IkReal x211=((((-1.0)*cj12*x195))+x207);
new_r00=(((r00*(((((-1.0)*cj12*x195))+x207))))+((r20*x200))+((r10*x210)));
new_r01=(((r11*x210))+((r21*x200))+((r01*x211)));
new_r02=(((r22*x200))+((r12*x210))+((r02*x211)));
new_r10=(((r20*x198))+((r00*x202))+((r10*x201)));
new_r11=(((r11*x201))+((r01*x202))+((r21*x198)));
new_r12=(((r22*x198))+((r12*x201))+((r02*x202)));
new_r20=(((r00*x209))+((r10*x208))+((r20*x206)));
new_r21=(((r11*x208))+((r01*(((((-1.0)*x194*x195))+x204))))+((r21*x206)));
new_r22=(((r22*x206))+((r12*x208))+((r02*x209)));
{
IkReal j14array[2], cj14array[2], sj14array[2];
bool j14valid[2]={false};
_nj14 = 2;
cj14array[0]=new_r22;
if( cj14array[0] >= -1-IKFAST_SINCOS_THRESH && cj14array[0] <= 1+IKFAST_SINCOS_THRESH )
{
    j14valid[0] = j14valid[1] = true;
    j14array[0] = IKacos(cj14array[0]);
    sj14array[0] = IKsin(j14array[0]);
    cj14array[1] = cj14array[0];
    j14array[1] = -j14array[0];
    sj14array[1] = -sj14array[0];
}
else if( isnan(cj14array[0]) )
{
    // probably any value will work
    j14valid[0] = true;
    cj14array[0] = 1; sj14array[0] = 0; j14array[0] = 0;
}
for(int ij14 = 0; ij14 < 2; ++ij14)
{
if( !j14valid[ij14] )
{
    continue;
}
_ij14[0] = ij14; _ij14[1] = -1;
for(int iij14 = ij14+1; iij14 < 2; ++iij14)
{
if( j14valid[iij14] && IKabs(cj14array[ij14]-cj14array[iij14]) < IKFAST_SOLUTION_THRESH && IKabs(sj14array[ij14]-sj14array[iij14]) < IKFAST_SOLUTION_THRESH )
{
    j14valid[iij14]=false; _ij14[1] = iij14; break; 
}
}
j14 = j14array[ij14]; cj14 = cj14array[ij14]; sj14 = sj14array[ij14];

{
IkReal j13eval[3];
j13eval[0]=sj14;
j13eval[1]=IKsign(sj14);
j13eval[2]=((IKabs(new_r12))+(IKabs(new_r02)));
if( IKabs(j13eval[0]) < 0.0000010000000000  || IKabs(j13eval[1]) < 0.0000010000000000  || IKabs(j13eval[2]) < 0.0000010000000000  )
{
{
IkReal j15eval[3];
j15eval[0]=sj14;
j15eval[1]=IKsign(sj14);
j15eval[2]=((IKabs(new_r20))+(IKabs(new_r21)));
if( IKabs(j15eval[0]) < 0.0000010000000000  || IKabs(j15eval[1]) < 0.0000010000000000  || IKabs(j15eval[2]) < 0.0000010000000000  )
{
{
IkReal j13eval[2];
j13eval[0]=new_r12;
j13eval[1]=sj14;
if( IKabs(j13eval[0]) < 0.0000010000000000  || IKabs(j13eval[1]) < 0.0000010000000000  )
{
{
IkReal evalcond[5];
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(j14))), 6.28318530717959)));
evalcond[1]=new_r20;
evalcond[2]=new_r02;
evalcond[3]=new_r12;
evalcond[4]=new_r21;
if( IKabs(evalcond[0]) < 0.0000050000000000  && IKabs(evalcond[1]) < 0.0000050000000000  && IKabs(evalcond[2]) < 0.0000050000000000  && IKabs(evalcond[3]) < 0.0000050000000000  && IKabs(evalcond[4]) < 0.0000050000000000  )
{
bgotonextstatement=false;
IkReal j15mul = 1;
j15=0;
j13mul=-1.0;
if( IKabs(((-1.0)*new_r01)) < IKFAST_ATAN2_MAGTHRESH && IKabs(new_r00) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((-1.0)*new_r01))+IKsqr(new_r00)-1) <= IKFAST_SINCOS_THRESH )
    continue;
j13=IKatan2(((-1.0)*new_r01), new_r00);
{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(8);
vinfos[0].jointtype = 17;
vinfos[0].foffset = j5;
vinfos[0].indices[0] = _ij5[0];
vinfos[0].indices[1] = _ij5[1];
vinfos[0].maxsolutions = _nj5;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j9;
vinfos[1].indices[0] = _ij9[0];
vinfos[1].indices[1] = _ij9[1];
vinfos[1].maxsolutions = _nj9;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j10;
vinfos[2].indices[0] = _ij10[0];
vinfos[2].indices[1] = _ij10[1];
vinfos[2].maxsolutions = _nj10;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j11;
vinfos[3].indices[0] = _ij11[0];
vinfos[3].indices[1] = _ij11[1];
vinfos[3].maxsolutions = _nj11;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j12;
vinfos[4].indices[0] = _ij12[0];
vinfos[4].indices[1] = _ij12[1];
vinfos[4].maxsolutions = _nj12;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j13;
vinfos[5].fmul = j13mul;
vinfos[5].freeind = 0;
vinfos[5].maxsolutions = 0;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j14;
vinfos[6].indices[0] = _ij14[0];
vinfos[6].indices[1] = _ij14[1];
vinfos[6].maxsolutions = _nj14;
vinfos[7].jointtype = 1;
vinfos[7].foffset = j15;
vinfos[7].fmul = j15mul;
vinfos[7].freeind = 0;
vinfos[7].maxsolutions = 0;
std::vector<int> vfree(1);
vfree[0] = 7;
solutions.AddSolution(vinfos,vfree);
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((-3.14159265358979)+j14)))), 6.28318530717959)));
evalcond[1]=new_r20;
evalcond[2]=new_r02;
evalcond[3]=new_r12;
evalcond[4]=new_r21;
if( IKabs(evalcond[0]) < 0.0000050000000000  && IKabs(evalcond[1]) < 0.0000050000000000  && IKabs(evalcond[2]) < 0.0000050000000000  && IKabs(evalcond[3]) < 0.0000050000000000  && IKabs(evalcond[4]) < 0.0000050000000000  )
{
bgotonextstatement=false;
IkReal j15mul = 1;
j15=0;
j13mul=1.0;
if( IKabs(((-1.0)*new_r01)) < IKFAST_ATAN2_MAGTHRESH && IKabs(((-1.0)*new_r00)) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((-1.0)*new_r01))+IKsqr(((-1.0)*new_r00))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j13=IKatan2(((-1.0)*new_r01), ((-1.0)*new_r00));
{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(8);
vinfos[0].jointtype = 17;
vinfos[0].foffset = j5;
vinfos[0].indices[0] = _ij5[0];
vinfos[0].indices[1] = _ij5[1];
vinfos[0].maxsolutions = _nj5;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j9;
vinfos[1].indices[0] = _ij9[0];
vinfos[1].indices[1] = _ij9[1];
vinfos[1].maxsolutions = _nj9;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j10;
vinfos[2].indices[0] = _ij10[0];
vinfos[2].indices[1] = _ij10[1];
vinfos[2].maxsolutions = _nj10;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j11;
vinfos[3].indices[0] = _ij11[0];
vinfos[3].indices[1] = _ij11[1];
vinfos[3].maxsolutions = _nj11;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j12;
vinfos[4].indices[0] = _ij12[0];
vinfos[4].indices[1] = _ij12[1];
vinfos[4].maxsolutions = _nj12;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j13;
vinfos[5].fmul = j13mul;
vinfos[5].freeind = 0;
vinfos[5].maxsolutions = 0;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j14;
vinfos[6].indices[0] = _ij14[0];
vinfos[6].indices[1] = _ij14[1];
vinfos[6].maxsolutions = _nj14;
vinfos[7].jointtype = 1;
vinfos[7].foffset = j15;
vinfos[7].fmul = j15mul;
vinfos[7].freeind = 0;
vinfos[7].maxsolutions = 0;
std::vector<int> vfree(1);
vfree[0] = 7;
solutions.AddSolution(vinfos,vfree);
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((IKabs(new_r12))+(IKabs(new_r02)));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j13eval[1];
new_r02=0;
new_r12=0;
new_r20=0;
new_r21=0;
IkReal x212=new_r22*new_r22;
IkReal x213=((16.0)*new_r10);
IkReal x214=((16.0)*new_r01);
IkReal x215=((16.0)*new_r22);
IkReal x216=((8.0)*new_r11);
IkReal x217=((8.0)*new_r00);
IkReal x218=(x212*x213);
IkReal x219=(x212*x214);
j13eval[0]=((IKabs((x218+(((-1.0)*x213)))))+(IKabs((((x212*x216))+(((-1.0)*new_r22*x217)))))+(IKabs((x214+(((-1.0)*x219)))))+(IKabs((x219+(((-1.0)*x214)))))+(IKabs((((new_r22*x216))+(((-1.0)*x217)))))+(IKabs(((((-16.0)*new_r11*x212))+(((32.0)*new_r11))+(((-1.0)*new_r00*x215)))))+(IKabs((x213+(((-1.0)*x218)))))+(IKabs(((((-32.0)*new_r00*x212))+(((16.0)*new_r00))+((new_r11*x215))))));
if( IKabs(j13eval[0]) < 0.0000000100000000  )
{
continue; // no branches [j13, j15]

} else
{
IkReal op[4+1], zeror[4];
int numroots;
IkReal j13evalpoly[1];
IkReal x220=new_r22*new_r22;
IkReal x221=((16.0)*new_r10);
IkReal x222=(new_r11*new_r22);
IkReal x223=(x220*x221);
IkReal x224=((((8.0)*x222))+(((-8.0)*new_r00)));
op[0]=x224;
op[1]=(x221+(((-1.0)*x223)));
op[2]=((((16.0)*new_r00))+(((16.0)*x222))+(((-32.0)*new_r00*x220)));
op[3]=(x223+(((-1.0)*x221)));
op[4]=x224;
polyroots4(op,zeror,numroots);
IkReal j13array[4], cj13array[4], sj13array[4], tempj13array[1];
int numsolutions = 0;
for(int ij13 = 0; ij13 < numroots; ++ij13)
{
IkReal htj13 = zeror[ij13];
tempj13array[0]=((2.0)*(atan(htj13)));
for(int kj13 = 0; kj13 < 1; ++kj13)
{
j13array[numsolutions] = tempj13array[kj13];
if( j13array[numsolutions] > IKPI )
{
    j13array[numsolutions]-=IK2PI;
}
else if( j13array[numsolutions] < -IKPI )
{
    j13array[numsolutions]+=IK2PI;
}
sj13array[numsolutions] = IKsin(j13array[numsolutions]);
cj13array[numsolutions] = IKcos(j13array[numsolutions]);
numsolutions++;
}
}
bool j13valid[4]={true,true,true,true};
_nj13 = 4;
for(int ij13 = 0; ij13 < numsolutions; ++ij13)
    {
if( !j13valid[ij13] )
{
    continue;
}
    j13 = j13array[ij13]; cj13 = cj13array[ij13]; sj13 = sj13array[ij13];
htj13 = IKtan(j13/2);

IkReal x225=((16.0)*new_r01);
IkReal x226=new_r22*new_r22;
IkReal x227=(new_r00*new_r22);
IkReal x228=((8.0)*x227);
IkReal x229=(new_r11*x226);
IkReal x230=(x225*x226);
IkReal x231=((8.0)*x229);
j13evalpoly[0]=((((htj13*htj13*htj13)*((x230+(((-1.0)*x225))))))+(((htj13*htj13*htj13*htj13)*((x231+(((-1.0)*x228))))))+((htj13*(((((-1.0)*x230))+x225))))+x231+(((-1.0)*x228))+(((htj13*htj13)*(((((32.0)*new_r11))+(((-16.0)*x227))+(((-16.0)*x229)))))));
if( IKabs(j13evalpoly[0]) > 0.0000001000000000  )
{
    continue;
}
_ij13[0] = ij13; _ij13[1] = -1;
for(int iij13 = ij13+1; iij13 < numsolutions; ++iij13)
{
if( j13valid[iij13] && IKabs(cj13array[ij13]-cj13array[iij13]) < IKFAST_SOLUTION_THRESH && IKabs(sj13array[ij13]-sj13array[iij13]) < IKFAST_SOLUTION_THRESH )
{
    j13valid[iij13]=false; _ij13[1] = iij13; break; 
}
}
{
IkReal j15eval[3];
new_r02=0;
new_r12=0;
new_r20=0;
new_r21=0;
IkReal x232=cj13*cj13;
IkReal x233=(cj13*new_r22);
IkReal x234=((-1.0)+x232+(((-1.0)*x232*(new_r22*new_r22))));
j15eval[0]=x234;
j15eval[1]=((IKabs(((((-1.0)*new_r00*x233))+((new_r01*sj13)))))+(IKabs((((new_r01*x233))+((new_r00*sj13))))));
j15eval[2]=IKsign(x234);
if( IKabs(j15eval[0]) < 0.0000010000000000  || IKabs(j15eval[1]) < 0.0000010000000000  || IKabs(j15eval[2]) < 0.0000010000000000  )
{
{
IkReal j15eval[1];
new_r02=0;
new_r12=0;
new_r20=0;
new_r21=0;
j15eval[0]=new_r22;
if( IKabs(j15eval[0]) < 0.0000010000000000  )
{
{
IkReal j15eval[2];
new_r02=0;
new_r12=0;
new_r20=0;
new_r21=0;
IkReal x235=new_r22*new_r22;
j15eval[0]=(((cj13*x235))+(((-1.0)*cj13)));
j15eval[1]=(((sj13*x235))+(((-1.0)*sj13)));
if( IKabs(j15eval[0]) < 0.0000010000000000  || IKabs(j15eval[1]) < 0.0000010000000000  )
{
{
IkReal evalcond[1];
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((-1.5707963267949)+j13)))), 6.28318530717959)));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j15array[1], cj15array[1], sj15array[1];
bool j15valid[1]={false};
_nj15 = 1;
if( IKabs(((-1.0)*new_r00)) < IKFAST_ATAN2_MAGTHRESH && IKabs(((-1.0)*new_r01)) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((-1.0)*new_r00))+IKsqr(((-1.0)*new_r01))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j15array[0]=IKatan2(((-1.0)*new_r00), ((-1.0)*new_r01));
sj15array[0]=IKsin(j15array[0]);
cj15array[0]=IKcos(j15array[0]);
if( j15array[0] > IKPI )
{
    j15array[0]-=IK2PI;
}
else if( j15array[0] < -IKPI )
{    j15array[0]+=IK2PI;
}
j15valid[0] = true;
for(int ij15 = 0; ij15 < 1; ++ij15)
{
if( !j15valid[ij15] )
{
    continue;
}
_ij15[0] = ij15; _ij15[1] = -1;
for(int iij15 = ij15+1; iij15 < 1; ++iij15)
{
if( j15valid[iij15] && IKabs(cj15array[ij15]-cj15array[iij15]) < IKFAST_SOLUTION_THRESH && IKabs(sj15array[ij15]-sj15array[iij15]) < IKFAST_SOLUTION_THRESH )
{
    j15valid[iij15]=false; _ij15[1] = iij15; break; 
}
}
j15 = j15array[ij15]; cj15 = cj15array[ij15]; sj15 = sj15array[ij15];
{
IkReal evalcond[4];
IkReal x236=IKsin(j15);
IkReal x237=IKcos(j15);
evalcond[0]=x236;
evalcond[1]=((-1.0)*x237);
evalcond[2]=((((-1.0)*new_r00))+(((-1.0)*x236)));
evalcond[3]=((((-1.0)*new_r01))+(((-1.0)*x237)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(8);
vinfos[0].jointtype = 17;
vinfos[0].foffset = j5;
vinfos[0].indices[0] = _ij5[0];
vinfos[0].indices[1] = _ij5[1];
vinfos[0].maxsolutions = _nj5;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j9;
vinfos[1].indices[0] = _ij9[0];
vinfos[1].indices[1] = _ij9[1];
vinfos[1].maxsolutions = _nj9;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j10;
vinfos[2].indices[0] = _ij10[0];
vinfos[2].indices[1] = _ij10[1];
vinfos[2].maxsolutions = _nj10;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j11;
vinfos[3].indices[0] = _ij11[0];
vinfos[3].indices[1] = _ij11[1];
vinfos[3].maxsolutions = _nj11;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j12;
vinfos[4].indices[0] = _ij12[0];
vinfos[4].indices[1] = _ij12[1];
vinfos[4].maxsolutions = _nj12;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j13;
vinfos[5].indices[0] = _ij13[0];
vinfos[5].indices[1] = _ij13[1];
vinfos[5].maxsolutions = _nj13;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j14;
vinfos[6].indices[0] = _ij14[0];
vinfos[6].indices[1] = _ij14[1];
vinfos[6].maxsolutions = _nj14;
vinfos[7].jointtype = 1;
vinfos[7].foffset = j15;
vinfos[7].indices[0] = _ij15[0];
vinfos[7].indices[1] = _ij15[1];
vinfos[7].maxsolutions = _nj15;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((1.5707963267949)+j13)))), 6.28318530717959)));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j15array[1], cj15array[1], sj15array[1];
bool j15valid[1]={false};
_nj15 = 1;
if( IKabs(new_r00) < IKFAST_ATAN2_MAGTHRESH && IKabs(new_r01) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(new_r00)+IKsqr(new_r01)-1) <= IKFAST_SINCOS_THRESH )
    continue;
j15array[0]=IKatan2(new_r00, new_r01);
sj15array[0]=IKsin(j15array[0]);
cj15array[0]=IKcos(j15array[0]);
if( j15array[0] > IKPI )
{
    j15array[0]-=IK2PI;
}
else if( j15array[0] < -IKPI )
{    j15array[0]+=IK2PI;
}
j15valid[0] = true;
for(int ij15 = 0; ij15 < 1; ++ij15)
{
if( !j15valid[ij15] )
{
    continue;
}
_ij15[0] = ij15; _ij15[1] = -1;
for(int iij15 = ij15+1; iij15 < 1; ++iij15)
{
if( j15valid[iij15] && IKabs(cj15array[ij15]-cj15array[iij15]) < IKFAST_SOLUTION_THRESH && IKabs(sj15array[ij15]-sj15array[iij15]) < IKFAST_SOLUTION_THRESH )
{
    j15valid[iij15]=false; _ij15[1] = iij15; break; 
}
}
j15 = j15array[ij15]; cj15 = cj15array[ij15]; sj15 = sj15array[ij15];
{
IkReal evalcond[4];
IkReal x238=IKsin(j15);
IkReal x239=IKcos(j15);
evalcond[0]=x238;
evalcond[1]=((-1.0)*x239);
evalcond[2]=(new_r00+(((-1.0)*x238)));
evalcond[3]=(new_r01+(((-1.0)*x239)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(8);
vinfos[0].jointtype = 17;
vinfos[0].foffset = j5;
vinfos[0].indices[0] = _ij5[0];
vinfos[0].indices[1] = _ij5[1];
vinfos[0].maxsolutions = _nj5;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j9;
vinfos[1].indices[0] = _ij9[0];
vinfos[1].indices[1] = _ij9[1];
vinfos[1].maxsolutions = _nj9;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j10;
vinfos[2].indices[0] = _ij10[0];
vinfos[2].indices[1] = _ij10[1];
vinfos[2].maxsolutions = _nj10;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j11;
vinfos[3].indices[0] = _ij11[0];
vinfos[3].indices[1] = _ij11[1];
vinfos[3].maxsolutions = _nj11;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j12;
vinfos[4].indices[0] = _ij12[0];
vinfos[4].indices[1] = _ij12[1];
vinfos[4].maxsolutions = _nj12;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j13;
vinfos[5].indices[0] = _ij13[0];
vinfos[5].indices[1] = _ij13[1];
vinfos[5].maxsolutions = _nj13;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j14;
vinfos[6].indices[0] = _ij14[0];
vinfos[6].indices[1] = _ij14[1];
vinfos[6].maxsolutions = _nj14;
vinfos[7].jointtype = 1;
vinfos[7].foffset = j15;
vinfos[7].indices[0] = _ij15[0];
vinfos[7].indices[1] = _ij15[1];
vinfos[7].maxsolutions = _nj15;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(j13))), 6.28318530717959)));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j15array[1], cj15array[1], sj15array[1];
bool j15valid[1]={false};
_nj15 = 1;
if( IKabs(new_r10) < IKFAST_ATAN2_MAGTHRESH && IKabs(new_r11) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(new_r10)+IKsqr(new_r11)-1) <= IKFAST_SINCOS_THRESH )
    continue;
j15array[0]=IKatan2(new_r10, new_r11);
sj15array[0]=IKsin(j15array[0]);
cj15array[0]=IKcos(j15array[0]);
if( j15array[0] > IKPI )
{
    j15array[0]-=IK2PI;
}
else if( j15array[0] < -IKPI )
{    j15array[0]+=IK2PI;
}
j15valid[0] = true;
for(int ij15 = 0; ij15 < 1; ++ij15)
{
if( !j15valid[ij15] )
{
    continue;
}
_ij15[0] = ij15; _ij15[1] = -1;
for(int iij15 = ij15+1; iij15 < 1; ++iij15)
{
if( j15valid[iij15] && IKabs(cj15array[ij15]-cj15array[iij15]) < IKFAST_SOLUTION_THRESH && IKabs(sj15array[ij15]-sj15array[iij15]) < IKFAST_SOLUTION_THRESH )
{
    j15valid[iij15]=false; _ij15[1] = iij15; break; 
}
}
j15 = j15array[ij15]; cj15 = cj15array[ij15]; sj15 = sj15array[ij15];
{
IkReal evalcond[4];
IkReal x240=IKsin(j15);
IkReal x241=IKcos(j15);
evalcond[0]=x240;
evalcond[1]=((-1.0)*x241);
evalcond[2]=((((-1.0)*x240))+new_r10);
evalcond[3]=((((-1.0)*x241))+new_r11);
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(8);
vinfos[0].jointtype = 17;
vinfos[0].foffset = j5;
vinfos[0].indices[0] = _ij5[0];
vinfos[0].indices[1] = _ij5[1];
vinfos[0].maxsolutions = _nj5;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j9;
vinfos[1].indices[0] = _ij9[0];
vinfos[1].indices[1] = _ij9[1];
vinfos[1].maxsolutions = _nj9;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j10;
vinfos[2].indices[0] = _ij10[0];
vinfos[2].indices[1] = _ij10[1];
vinfos[2].maxsolutions = _nj10;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j11;
vinfos[3].indices[0] = _ij11[0];
vinfos[3].indices[1] = _ij11[1];
vinfos[3].maxsolutions = _nj11;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j12;
vinfos[4].indices[0] = _ij12[0];
vinfos[4].indices[1] = _ij12[1];
vinfos[4].maxsolutions = _nj12;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j13;
vinfos[5].indices[0] = _ij13[0];
vinfos[5].indices[1] = _ij13[1];
vinfos[5].maxsolutions = _nj13;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j14;
vinfos[6].indices[0] = _ij14[0];
vinfos[6].indices[1] = _ij14[1];
vinfos[6].maxsolutions = _nj14;
vinfos[7].jointtype = 1;
vinfos[7].foffset = j15;
vinfos[7].indices[0] = _ij15[0];
vinfos[7].indices[1] = _ij15[1];
vinfos[7].maxsolutions = _nj15;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((-3.14159265358979)+j13)))), 6.28318530717959)));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j15array[1], cj15array[1], sj15array[1];
bool j15valid[1]={false};
_nj15 = 1;
if( IKabs(((-1.0)*new_r10)) < IKFAST_ATAN2_MAGTHRESH && IKabs(((-1.0)*new_r11)) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((-1.0)*new_r10))+IKsqr(((-1.0)*new_r11))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j15array[0]=IKatan2(((-1.0)*new_r10), ((-1.0)*new_r11));
sj15array[0]=IKsin(j15array[0]);
cj15array[0]=IKcos(j15array[0]);
if( j15array[0] > IKPI )
{
    j15array[0]-=IK2PI;
}
else if( j15array[0] < -IKPI )
{    j15array[0]+=IK2PI;
}
j15valid[0] = true;
for(int ij15 = 0; ij15 < 1; ++ij15)
{
if( !j15valid[ij15] )
{
    continue;
}
_ij15[0] = ij15; _ij15[1] = -1;
for(int iij15 = ij15+1; iij15 < 1; ++iij15)
{
if( j15valid[iij15] && IKabs(cj15array[ij15]-cj15array[iij15]) < IKFAST_SOLUTION_THRESH && IKabs(sj15array[ij15]-sj15array[iij15]) < IKFAST_SOLUTION_THRESH )
{
    j15valid[iij15]=false; _ij15[1] = iij15; break; 
}
}
j15 = j15array[ij15]; cj15 = cj15array[ij15]; sj15 = sj15array[ij15];
{
IkReal evalcond[4];
IkReal x242=IKsin(j15);
IkReal x243=IKcos(j15);
evalcond[0]=x242;
evalcond[1]=((-1.0)*x243);
evalcond[2]=((((-1.0)*x242))+(((-1.0)*new_r10)));
evalcond[3]=((((-1.0)*x243))+(((-1.0)*new_r11)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(8);
vinfos[0].jointtype = 17;
vinfos[0].foffset = j5;
vinfos[0].indices[0] = _ij5[0];
vinfos[0].indices[1] = _ij5[1];
vinfos[0].maxsolutions = _nj5;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j9;
vinfos[1].indices[0] = _ij9[0];
vinfos[1].indices[1] = _ij9[1];
vinfos[1].maxsolutions = _nj9;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j10;
vinfos[2].indices[0] = _ij10[0];
vinfos[2].indices[1] = _ij10[1];
vinfos[2].maxsolutions = _nj10;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j11;
vinfos[3].indices[0] = _ij11[0];
vinfos[3].indices[1] = _ij11[1];
vinfos[3].maxsolutions = _nj11;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j12;
vinfos[4].indices[0] = _ij12[0];
vinfos[4].indices[1] = _ij12[1];
vinfos[4].maxsolutions = _nj12;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j13;
vinfos[5].indices[0] = _ij13[0];
vinfos[5].indices[1] = _ij13[1];
vinfos[5].maxsolutions = _nj13;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j14;
vinfos[6].indices[0] = _ij14[0];
vinfos[6].indices[1] = _ij14[1];
vinfos[6].maxsolutions = _nj14;
vinfos[7].jointtype = 1;
vinfos[7].foffset = j15;
vinfos[7].indices[0] = _ij15[0];
vinfos[7].indices[1] = _ij15[1];
vinfos[7].maxsolutions = _nj15;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
CheckValue<IkReal> x244=IKPowWithIntegerCheck(((1.0)+(((-1.0)*(new_r22*new_r22)))),-1);
if(!x244.valid){
continue;
}
if((x244.value) < -0.00001)
continue;
IkReal gconst24=((-1.0)*(IKsqrt(x244.value)));
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs((cj13+(((-1.0)*gconst24)))))+(IKabs(((-1.0)+(IKsign(sj13)))))), 6.28318530717959)));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j15eval[1];
new_r02=0;
new_r12=0;
new_r20=0;
new_r21=0;
if((((1.0)+(((-1.0)*(gconst24*gconst24))))) < -0.00001)
continue;
sj13=IKsqrt(((1.0)+(((-1.0)*(gconst24*gconst24)))));
cj13=gconst24;
if( (gconst24) < -1-IKFAST_SINCOS_THRESH || (gconst24) > 1+IKFAST_SINCOS_THRESH )
    continue;
j13=IKacos(gconst24);
CheckValue<IkReal> x245=IKPowWithIntegerCheck(((1.0)+(((-1.0)*(new_r22*new_r22)))),-1);
if(!x245.valid){
continue;
}
if((x245.value) < -0.00001)
continue;
IkReal gconst24=((-1.0)*(IKsqrt(x245.value)));
j15eval[0]=((IKabs(new_r11))+(IKabs(new_r10)));
if( IKabs(j15eval[0]) < 0.0000010000000000  )
{
{
IkReal j15array[1], cj15array[1], sj15array[1];
bool j15valid[1]={false};
_nj15 = 1;
if((((1.0)+(((-1.0)*(gconst24*gconst24))))) < -0.00001)
continue;
CheckValue<IkReal> x246=IKPowWithIntegerCheck(gconst24,-1);
if(!x246.valid){
continue;
}
if( IKabs(((((-1.0)*new_r00*(IKsqrt(((1.0)+(((-1.0)*(gconst24*gconst24))))))))+((gconst24*new_r10)))) < IKFAST_ATAN2_MAGTHRESH && IKabs((new_r11*(x246.value))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((((-1.0)*new_r00*(IKsqrt(((1.0)+(((-1.0)*(gconst24*gconst24))))))))+((gconst24*new_r10))))+IKsqr((new_r11*(x246.value)))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j15array[0]=IKatan2(((((-1.0)*new_r00*(IKsqrt(((1.0)+(((-1.0)*(gconst24*gconst24))))))))+((gconst24*new_r10))), (new_r11*(x246.value)));
sj15array[0]=IKsin(j15array[0]);
cj15array[0]=IKcos(j15array[0]);
if( j15array[0] > IKPI )
{
    j15array[0]-=IK2PI;
}
else if( j15array[0] < -IKPI )
{    j15array[0]+=IK2PI;
}
j15valid[0] = true;
for(int ij15 = 0; ij15 < 1; ++ij15)
{
if( !j15valid[ij15] )
{
    continue;
}
_ij15[0] = ij15; _ij15[1] = -1;
for(int iij15 = ij15+1; iij15 < 1; ++iij15)
{
if( j15valid[iij15] && IKabs(cj15array[ij15]-cj15array[iij15]) < IKFAST_SOLUTION_THRESH && IKabs(sj15array[ij15]-sj15array[iij15]) < IKFAST_SOLUTION_THRESH )
{
    j15valid[iij15]=false; _ij15[1] = iij15; break; 
}
}
j15 = j15array[ij15]; cj15 = cj15array[ij15]; sj15 = sj15array[ij15];
{
IkReal evalcond[8];
IkReal x247=IKcos(j15);
IkReal x248=IKsin(j15);
IkReal x249=((1.0)*x247);
IkReal x250=((1.0)*x248);
if((((1.0)+(((-1.0)*(gconst24*gconst24))))) < -0.00001)
continue;
IkReal x251=IKsqrt(((1.0)+(((-1.0)*(gconst24*gconst24)))));
IkReal x252=((1.0)*x251);
evalcond[0]=x248;
evalcond[1]=((-1.0)*x247);
evalcond[2]=(new_r11+(((-1.0)*gconst24*x249)));
evalcond[3]=((((-1.0)*gconst24*x250))+new_r10);
evalcond[4]=(new_r01+((x247*x251)));
evalcond[5]=(((x248*x251))+new_r00);
evalcond[6]=(((gconst24*new_r10))+(((-1.0)*new_r00*x252))+(((-1.0)*x250)));
evalcond[7]=((((-1.0)*new_r01*x252))+((gconst24*new_r11))+(((-1.0)*x249)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(8);
vinfos[0].jointtype = 17;
vinfos[0].foffset = j5;
vinfos[0].indices[0] = _ij5[0];
vinfos[0].indices[1] = _ij5[1];
vinfos[0].maxsolutions = _nj5;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j9;
vinfos[1].indices[0] = _ij9[0];
vinfos[1].indices[1] = _ij9[1];
vinfos[1].maxsolutions = _nj9;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j10;
vinfos[2].indices[0] = _ij10[0];
vinfos[2].indices[1] = _ij10[1];
vinfos[2].maxsolutions = _nj10;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j11;
vinfos[3].indices[0] = _ij11[0];
vinfos[3].indices[1] = _ij11[1];
vinfos[3].maxsolutions = _nj11;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j12;
vinfos[4].indices[0] = _ij12[0];
vinfos[4].indices[1] = _ij12[1];
vinfos[4].maxsolutions = _nj12;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j13;
vinfos[5].indices[0] = _ij13[0];
vinfos[5].indices[1] = _ij13[1];
vinfos[5].maxsolutions = _nj13;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j14;
vinfos[6].indices[0] = _ij14[0];
vinfos[6].indices[1] = _ij14[1];
vinfos[6].maxsolutions = _nj14;
vinfos[7].jointtype = 1;
vinfos[7].foffset = j15;
vinfos[7].indices[0] = _ij15[0];
vinfos[7].indices[1] = _ij15[1];
vinfos[7].maxsolutions = _nj15;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

} else
{
{
IkReal j15array[1], cj15array[1], sj15array[1];
bool j15valid[1]={false};
_nj15 = 1;
CheckValue<IkReal> x253=IKPowWithIntegerCheck(IKsign(gconst24),-1);
if(!x253.valid){
continue;
}
CheckValue<IkReal> x254 = IKatan2WithCheck(IkReal(new_r10),IkReal(new_r11),IKFAST_ATAN2_MAGTHRESH);
if(!x254.valid){
continue;
}
j15array[0]=((-1.5707963267949)+(((1.5707963267949)*(x253.value)))+(x254.value));
sj15array[0]=IKsin(j15array[0]);
cj15array[0]=IKcos(j15array[0]);
if( j15array[0] > IKPI )
{
    j15array[0]-=IK2PI;
}
else if( j15array[0] < -IKPI )
{    j15array[0]+=IK2PI;
}
j15valid[0] = true;
for(int ij15 = 0; ij15 < 1; ++ij15)
{
if( !j15valid[ij15] )
{
    continue;
}
_ij15[0] = ij15; _ij15[1] = -1;
for(int iij15 = ij15+1; iij15 < 1; ++iij15)
{
if( j15valid[iij15] && IKabs(cj15array[ij15]-cj15array[iij15]) < IKFAST_SOLUTION_THRESH && IKabs(sj15array[ij15]-sj15array[iij15]) < IKFAST_SOLUTION_THRESH )
{
    j15valid[iij15]=false; _ij15[1] = iij15; break; 
}
}
j15 = j15array[ij15]; cj15 = cj15array[ij15]; sj15 = sj15array[ij15];
{
IkReal evalcond[8];
IkReal x255=IKcos(j15);
IkReal x256=IKsin(j15);
IkReal x257=((1.0)*x255);
IkReal x258=((1.0)*x256);
if((((1.0)+(((-1.0)*(gconst24*gconst24))))) < -0.00001)
continue;
IkReal x259=IKsqrt(((1.0)+(((-1.0)*(gconst24*gconst24)))));
IkReal x260=((1.0)*x259);
evalcond[0]=x256;
evalcond[1]=((-1.0)*x255);
evalcond[2]=((((-1.0)*gconst24*x257))+new_r11);
evalcond[3]=((((-1.0)*gconst24*x258))+new_r10);
evalcond[4]=(new_r01+((x255*x259)));
evalcond[5]=(((x256*x259))+new_r00);
evalcond[6]=((((-1.0)*new_r00*x260))+((gconst24*new_r10))+(((-1.0)*x258)));
evalcond[7]=((((-1.0)*new_r01*x260))+((gconst24*new_r11))+(((-1.0)*x257)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(8);
vinfos[0].jointtype = 17;
vinfos[0].foffset = j5;
vinfos[0].indices[0] = _ij5[0];
vinfos[0].indices[1] = _ij5[1];
vinfos[0].maxsolutions = _nj5;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j9;
vinfos[1].indices[0] = _ij9[0];
vinfos[1].indices[1] = _ij9[1];
vinfos[1].maxsolutions = _nj9;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j10;
vinfos[2].indices[0] = _ij10[0];
vinfos[2].indices[1] = _ij10[1];
vinfos[2].maxsolutions = _nj10;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j11;
vinfos[3].indices[0] = _ij11[0];
vinfos[3].indices[1] = _ij11[1];
vinfos[3].maxsolutions = _nj11;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j12;
vinfos[4].indices[0] = _ij12[0];
vinfos[4].indices[1] = _ij12[1];
vinfos[4].maxsolutions = _nj12;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j13;
vinfos[5].indices[0] = _ij13[0];
vinfos[5].indices[1] = _ij13[1];
vinfos[5].maxsolutions = _nj13;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j14;
vinfos[6].indices[0] = _ij14[0];
vinfos[6].indices[1] = _ij14[1];
vinfos[6].maxsolutions = _nj14;
vinfos[7].jointtype = 1;
vinfos[7].foffset = j15;
vinfos[7].indices[0] = _ij15[0];
vinfos[7].indices[1] = _ij15[1];
vinfos[7].maxsolutions = _nj15;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
CheckValue<IkReal> x261=IKPowWithIntegerCheck(((1.0)+(((-1.0)*(new_r22*new_r22)))),-1);
if(!x261.valid){
continue;
}
if((x261.value) < -0.00001)
continue;
IkReal gconst24=((-1.0)*(IKsqrt(x261.value)));
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((1.0)+(IKsign(sj13)))))+(IKabs((cj13+(((-1.0)*gconst24)))))), 6.28318530717959)));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j15eval[1];
new_r02=0;
new_r12=0;
new_r20=0;
new_r21=0;
if((((1.0)+(((-1.0)*(gconst24*gconst24))))) < -0.00001)
continue;
sj13=((-1.0)*(IKsqrt(((1.0)+(((-1.0)*(gconst24*gconst24)))))));
cj13=gconst24;
if( (gconst24) < -1-IKFAST_SINCOS_THRESH || (gconst24) > 1+IKFAST_SINCOS_THRESH )
    continue;
j13=((-1.0)*(IKacos(gconst24)));
CheckValue<IkReal> x262=IKPowWithIntegerCheck(((1.0)+(((-1.0)*(new_r22*new_r22)))),-1);
if(!x262.valid){
continue;
}
if((x262.value) < -0.00001)
continue;
IkReal gconst24=((-1.0)*(IKsqrt(x262.value)));
j15eval[0]=((IKabs(new_r11))+(IKabs(new_r10)));
if( IKabs(j15eval[0]) < 0.0000010000000000  )
{
{
IkReal j15array[1], cj15array[1], sj15array[1];
bool j15valid[1]={false};
_nj15 = 1;
if((((1.0)+(((-1.0)*(gconst24*gconst24))))) < -0.00001)
continue;
CheckValue<IkReal> x263=IKPowWithIntegerCheck(gconst24,-1);
if(!x263.valid){
continue;
}
if( IKabs((((new_r00*(IKsqrt(((1.0)+(((-1.0)*(gconst24*gconst24))))))))+((gconst24*new_r10)))) < IKFAST_ATAN2_MAGTHRESH && IKabs((new_r11*(x263.value))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr((((new_r00*(IKsqrt(((1.0)+(((-1.0)*(gconst24*gconst24))))))))+((gconst24*new_r10))))+IKsqr((new_r11*(x263.value)))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j15array[0]=IKatan2((((new_r00*(IKsqrt(((1.0)+(((-1.0)*(gconst24*gconst24))))))))+((gconst24*new_r10))), (new_r11*(x263.value)));
sj15array[0]=IKsin(j15array[0]);
cj15array[0]=IKcos(j15array[0]);
if( j15array[0] > IKPI )
{
    j15array[0]-=IK2PI;
}
else if( j15array[0] < -IKPI )
{    j15array[0]+=IK2PI;
}
j15valid[0] = true;
for(int ij15 = 0; ij15 < 1; ++ij15)
{
if( !j15valid[ij15] )
{
    continue;
}
_ij15[0] = ij15; _ij15[1] = -1;
for(int iij15 = ij15+1; iij15 < 1; ++iij15)
{
if( j15valid[iij15] && IKabs(cj15array[ij15]-cj15array[iij15]) < IKFAST_SOLUTION_THRESH && IKabs(sj15array[ij15]-sj15array[iij15]) < IKFAST_SOLUTION_THRESH )
{
    j15valid[iij15]=false; _ij15[1] = iij15; break; 
}
}
j15 = j15array[ij15]; cj15 = cj15array[ij15]; sj15 = sj15array[ij15];
{
IkReal evalcond[8];
IkReal x264=IKcos(j15);
IkReal x265=IKsin(j15);
IkReal x266=((1.0)*x264);
IkReal x267=((1.0)*x265);
if((((1.0)+(((-1.0)*(gconst24*gconst24))))) < -0.00001)
continue;
IkReal x268=IKsqrt(((1.0)+(((-1.0)*(gconst24*gconst24)))));
evalcond[0]=x265;
evalcond[1]=((-1.0)*x264);
evalcond[2]=(new_r11+(((-1.0)*gconst24*x266)));
evalcond[3]=(new_r10+(((-1.0)*gconst24*x267)));
evalcond[4]=(new_r01+(((-1.0)*x266*x268)));
evalcond[5]=((((-1.0)*x267*x268))+new_r00);
evalcond[6]=(((new_r00*x268))+((gconst24*new_r10))+(((-1.0)*x267)));
evalcond[7]=(((new_r01*x268))+((gconst24*new_r11))+(((-1.0)*x266)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(8);
vinfos[0].jointtype = 17;
vinfos[0].foffset = j5;
vinfos[0].indices[0] = _ij5[0];
vinfos[0].indices[1] = _ij5[1];
vinfos[0].maxsolutions = _nj5;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j9;
vinfos[1].indices[0] = _ij9[0];
vinfos[1].indices[1] = _ij9[1];
vinfos[1].maxsolutions = _nj9;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j10;
vinfos[2].indices[0] = _ij10[0];
vinfos[2].indices[1] = _ij10[1];
vinfos[2].maxsolutions = _nj10;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j11;
vinfos[3].indices[0] = _ij11[0];
vinfos[3].indices[1] = _ij11[1];
vinfos[3].maxsolutions = _nj11;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j12;
vinfos[4].indices[0] = _ij12[0];
vinfos[4].indices[1] = _ij12[1];
vinfos[4].maxsolutions = _nj12;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j13;
vinfos[5].indices[0] = _ij13[0];
vinfos[5].indices[1] = _ij13[1];
vinfos[5].maxsolutions = _nj13;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j14;
vinfos[6].indices[0] = _ij14[0];
vinfos[6].indices[1] = _ij14[1];
vinfos[6].maxsolutions = _nj14;
vinfos[7].jointtype = 1;
vinfos[7].foffset = j15;
vinfos[7].indices[0] = _ij15[0];
vinfos[7].indices[1] = _ij15[1];
vinfos[7].maxsolutions = _nj15;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

} else
{
{
IkReal j15array[1], cj15array[1], sj15array[1];
bool j15valid[1]={false};
_nj15 = 1;
CheckValue<IkReal> x269=IKPowWithIntegerCheck(IKsign(gconst24),-1);
if(!x269.valid){
continue;
}
CheckValue<IkReal> x270 = IKatan2WithCheck(IkReal(new_r10),IkReal(new_r11),IKFAST_ATAN2_MAGTHRESH);
if(!x270.valid){
continue;
}
j15array[0]=((-1.5707963267949)+(((1.5707963267949)*(x269.value)))+(x270.value));
sj15array[0]=IKsin(j15array[0]);
cj15array[0]=IKcos(j15array[0]);
if( j15array[0] > IKPI )
{
    j15array[0]-=IK2PI;
}
else if( j15array[0] < -IKPI )
{    j15array[0]+=IK2PI;
}
j15valid[0] = true;
for(int ij15 = 0; ij15 < 1; ++ij15)
{
if( !j15valid[ij15] )
{
    continue;
}
_ij15[0] = ij15; _ij15[1] = -1;
for(int iij15 = ij15+1; iij15 < 1; ++iij15)
{
if( j15valid[iij15] && IKabs(cj15array[ij15]-cj15array[iij15]) < IKFAST_SOLUTION_THRESH && IKabs(sj15array[ij15]-sj15array[iij15]) < IKFAST_SOLUTION_THRESH )
{
    j15valid[iij15]=false; _ij15[1] = iij15; break; 
}
}
j15 = j15array[ij15]; cj15 = cj15array[ij15]; sj15 = sj15array[ij15];
{
IkReal evalcond[8];
IkReal x271=IKcos(j15);
IkReal x272=IKsin(j15);
IkReal x273=((1.0)*x271);
IkReal x274=((1.0)*x272);
if((((1.0)+(((-1.0)*(gconst24*gconst24))))) < -0.00001)
continue;
IkReal x275=IKsqrt(((1.0)+(((-1.0)*(gconst24*gconst24)))));
evalcond[0]=x272;
evalcond[1]=((-1.0)*x271);
evalcond[2]=(new_r11+(((-1.0)*gconst24*x273)));
evalcond[3]=(new_r10+(((-1.0)*gconst24*x274)));
evalcond[4]=((((-1.0)*x273*x275))+new_r01);
evalcond[5]=((((-1.0)*x274*x275))+new_r00);
evalcond[6]=(((new_r00*x275))+((gconst24*new_r10))+(((-1.0)*x274)));
evalcond[7]=(((new_r01*x275))+((gconst24*new_r11))+(((-1.0)*x273)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(8);
vinfos[0].jointtype = 17;
vinfos[0].foffset = j5;
vinfos[0].indices[0] = _ij5[0];
vinfos[0].indices[1] = _ij5[1];
vinfos[0].maxsolutions = _nj5;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j9;
vinfos[1].indices[0] = _ij9[0];
vinfos[1].indices[1] = _ij9[1];
vinfos[1].maxsolutions = _nj9;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j10;
vinfos[2].indices[0] = _ij10[0];
vinfos[2].indices[1] = _ij10[1];
vinfos[2].maxsolutions = _nj10;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j11;
vinfos[3].indices[0] = _ij11[0];
vinfos[3].indices[1] = _ij11[1];
vinfos[3].maxsolutions = _nj11;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j12;
vinfos[4].indices[0] = _ij12[0];
vinfos[4].indices[1] = _ij12[1];
vinfos[4].maxsolutions = _nj12;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j13;
vinfos[5].indices[0] = _ij13[0];
vinfos[5].indices[1] = _ij13[1];
vinfos[5].maxsolutions = _nj13;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j14;
vinfos[6].indices[0] = _ij14[0];
vinfos[6].indices[1] = _ij14[1];
vinfos[6].maxsolutions = _nj14;
vinfos[7].jointtype = 1;
vinfos[7].foffset = j15;
vinfos[7].indices[0] = _ij15[0];
vinfos[7].indices[1] = _ij15[1];
vinfos[7].maxsolutions = _nj15;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
CheckValue<IkReal> x276=IKPowWithIntegerCheck(((1.0)+(((-1.0)*(new_r22*new_r22)))),-1);
if(!x276.valid){
continue;
}
if((x276.value) < -0.00001)
continue;
IkReal gconst25=IKsqrt(x276.value);
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs((cj13+(((-1.0)*gconst25)))))+(IKabs(((-1.0)+(IKsign(sj13)))))), 6.28318530717959)));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j15eval[1];
new_r02=0;
new_r12=0;
new_r20=0;
new_r21=0;
if((((1.0)+(((-1.0)*(gconst25*gconst25))))) < -0.00001)
continue;
sj13=IKsqrt(((1.0)+(((-1.0)*(gconst25*gconst25)))));
cj13=gconst25;
if( (gconst25) < -1-IKFAST_SINCOS_THRESH || (gconst25) > 1+IKFAST_SINCOS_THRESH )
    continue;
j13=IKacos(gconst25);
CheckValue<IkReal> x277=IKPowWithIntegerCheck(((1.0)+(((-1.0)*(new_r22*new_r22)))),-1);
if(!x277.valid){
continue;
}
if((x277.value) < -0.00001)
continue;
IkReal gconst25=IKsqrt(x277.value);
j15eval[0]=((IKabs(new_r11))+(IKabs(new_r10)));
if( IKabs(j15eval[0]) < 0.0000010000000000  )
{
{
IkReal j15array[1], cj15array[1], sj15array[1];
bool j15valid[1]={false};
_nj15 = 1;
if((((1.0)+(((-1.0)*(gconst25*gconst25))))) < -0.00001)
continue;
CheckValue<IkReal> x278=IKPowWithIntegerCheck(gconst25,-1);
if(!x278.valid){
continue;
}
if( IKabs((((gconst25*new_r10))+(((-1.0)*new_r00*(IKsqrt(((1.0)+(((-1.0)*(gconst25*gconst25)))))))))) < IKFAST_ATAN2_MAGTHRESH && IKabs((new_r11*(x278.value))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr((((gconst25*new_r10))+(((-1.0)*new_r00*(IKsqrt(((1.0)+(((-1.0)*(gconst25*gconst25))))))))))+IKsqr((new_r11*(x278.value)))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j15array[0]=IKatan2((((gconst25*new_r10))+(((-1.0)*new_r00*(IKsqrt(((1.0)+(((-1.0)*(gconst25*gconst25))))))))), (new_r11*(x278.value)));
sj15array[0]=IKsin(j15array[0]);
cj15array[0]=IKcos(j15array[0]);
if( j15array[0] > IKPI )
{
    j15array[0]-=IK2PI;
}
else if( j15array[0] < -IKPI )
{    j15array[0]+=IK2PI;
}
j15valid[0] = true;
for(int ij15 = 0; ij15 < 1; ++ij15)
{
if( !j15valid[ij15] )
{
    continue;
}
_ij15[0] = ij15; _ij15[1] = -1;
for(int iij15 = ij15+1; iij15 < 1; ++iij15)
{
if( j15valid[iij15] && IKabs(cj15array[ij15]-cj15array[iij15]) < IKFAST_SOLUTION_THRESH && IKabs(sj15array[ij15]-sj15array[iij15]) < IKFAST_SOLUTION_THRESH )
{
    j15valid[iij15]=false; _ij15[1] = iij15; break; 
}
}
j15 = j15array[ij15]; cj15 = cj15array[ij15]; sj15 = sj15array[ij15];
{
IkReal evalcond[8];
IkReal x279=IKcos(j15);
IkReal x280=IKsin(j15);
IkReal x281=((1.0)*gconst25);
if((((1.0)+(((-1.0)*gconst25*x281)))) < -0.00001)
continue;
IkReal x282=IKsqrt(((1.0)+(((-1.0)*gconst25*x281))));
IkReal x283=((1.0)*x282);
evalcond[0]=x280;
evalcond[1]=((-1.0)*x279);
evalcond[2]=(new_r11+(((-1.0)*x279*x281)));
evalcond[3]=((((-1.0)*x280*x281))+new_r10);
evalcond[4]=(((x279*x282))+new_r01);
evalcond[5]=(new_r00+((x280*x282)));
evalcond[6]=(((gconst25*new_r10))+(((-1.0)*new_r00*x283))+(((-1.0)*x280)));
evalcond[7]=(((gconst25*new_r11))+(((-1.0)*x279))+(((-1.0)*new_r01*x283)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(8);
vinfos[0].jointtype = 17;
vinfos[0].foffset = j5;
vinfos[0].indices[0] = _ij5[0];
vinfos[0].indices[1] = _ij5[1];
vinfos[0].maxsolutions = _nj5;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j9;
vinfos[1].indices[0] = _ij9[0];
vinfos[1].indices[1] = _ij9[1];
vinfos[1].maxsolutions = _nj9;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j10;
vinfos[2].indices[0] = _ij10[0];
vinfos[2].indices[1] = _ij10[1];
vinfos[2].maxsolutions = _nj10;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j11;
vinfos[3].indices[0] = _ij11[0];
vinfos[3].indices[1] = _ij11[1];
vinfos[3].maxsolutions = _nj11;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j12;
vinfos[4].indices[0] = _ij12[0];
vinfos[4].indices[1] = _ij12[1];
vinfos[4].maxsolutions = _nj12;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j13;
vinfos[5].indices[0] = _ij13[0];
vinfos[5].indices[1] = _ij13[1];
vinfos[5].maxsolutions = _nj13;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j14;
vinfos[6].indices[0] = _ij14[0];
vinfos[6].indices[1] = _ij14[1];
vinfos[6].maxsolutions = _nj14;
vinfos[7].jointtype = 1;
vinfos[7].foffset = j15;
vinfos[7].indices[0] = _ij15[0];
vinfos[7].indices[1] = _ij15[1];
vinfos[7].maxsolutions = _nj15;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

} else
{
{
IkReal j15array[1], cj15array[1], sj15array[1];
bool j15valid[1]={false};
_nj15 = 1;
CheckValue<IkReal> x284=IKPowWithIntegerCheck(IKsign(gconst25),-1);
if(!x284.valid){
continue;
}
CheckValue<IkReal> x285 = IKatan2WithCheck(IkReal(new_r10),IkReal(new_r11),IKFAST_ATAN2_MAGTHRESH);
if(!x285.valid){
continue;
}
j15array[0]=((-1.5707963267949)+(((1.5707963267949)*(x284.value)))+(x285.value));
sj15array[0]=IKsin(j15array[0]);
cj15array[0]=IKcos(j15array[0]);
if( j15array[0] > IKPI )
{
    j15array[0]-=IK2PI;
}
else if( j15array[0] < -IKPI )
{    j15array[0]+=IK2PI;
}
j15valid[0] = true;
for(int ij15 = 0; ij15 < 1; ++ij15)
{
if( !j15valid[ij15] )
{
    continue;
}
_ij15[0] = ij15; _ij15[1] = -1;
for(int iij15 = ij15+1; iij15 < 1; ++iij15)
{
if( j15valid[iij15] && IKabs(cj15array[ij15]-cj15array[iij15]) < IKFAST_SOLUTION_THRESH && IKabs(sj15array[ij15]-sj15array[iij15]) < IKFAST_SOLUTION_THRESH )
{
    j15valid[iij15]=false; _ij15[1] = iij15; break; 
}
}
j15 = j15array[ij15]; cj15 = cj15array[ij15]; sj15 = sj15array[ij15];
{
IkReal evalcond[8];
IkReal x286=IKcos(j15);
IkReal x287=IKsin(j15);
IkReal x288=((1.0)*gconst25);
if((((1.0)+(((-1.0)*gconst25*x288)))) < -0.00001)
continue;
IkReal x289=IKsqrt(((1.0)+(((-1.0)*gconst25*x288))));
IkReal x290=((1.0)*x289);
evalcond[0]=x287;
evalcond[1]=((-1.0)*x286);
evalcond[2]=(new_r11+(((-1.0)*x286*x288)));
evalcond[3]=((((-1.0)*x287*x288))+new_r10);
evalcond[4]=(((x286*x289))+new_r01);
evalcond[5]=(new_r00+((x287*x289)));
evalcond[6]=(((gconst25*new_r10))+(((-1.0)*x287))+(((-1.0)*new_r00*x290)));
evalcond[7]=((((-1.0)*new_r01*x290))+((gconst25*new_r11))+(((-1.0)*x286)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(8);
vinfos[0].jointtype = 17;
vinfos[0].foffset = j5;
vinfos[0].indices[0] = _ij5[0];
vinfos[0].indices[1] = _ij5[1];
vinfos[0].maxsolutions = _nj5;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j9;
vinfos[1].indices[0] = _ij9[0];
vinfos[1].indices[1] = _ij9[1];
vinfos[1].maxsolutions = _nj9;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j10;
vinfos[2].indices[0] = _ij10[0];
vinfos[2].indices[1] = _ij10[1];
vinfos[2].maxsolutions = _nj10;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j11;
vinfos[3].indices[0] = _ij11[0];
vinfos[3].indices[1] = _ij11[1];
vinfos[3].maxsolutions = _nj11;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j12;
vinfos[4].indices[0] = _ij12[0];
vinfos[4].indices[1] = _ij12[1];
vinfos[4].maxsolutions = _nj12;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j13;
vinfos[5].indices[0] = _ij13[0];
vinfos[5].indices[1] = _ij13[1];
vinfos[5].maxsolutions = _nj13;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j14;
vinfos[6].indices[0] = _ij14[0];
vinfos[6].indices[1] = _ij14[1];
vinfos[6].maxsolutions = _nj14;
vinfos[7].jointtype = 1;
vinfos[7].foffset = j15;
vinfos[7].indices[0] = _ij15[0];
vinfos[7].indices[1] = _ij15[1];
vinfos[7].maxsolutions = _nj15;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
CheckValue<IkReal> x291=IKPowWithIntegerCheck(((1.0)+(((-1.0)*(new_r22*new_r22)))),-1);
if(!x291.valid){
continue;
}
if((x291.value) < -0.00001)
continue;
IkReal gconst25=IKsqrt(x291.value);
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((1.0)+(IKsign(sj13)))))+(IKabs((cj13+(((-1.0)*gconst25)))))), 6.28318530717959)));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j15eval[1];
new_r02=0;
new_r12=0;
new_r20=0;
new_r21=0;
if((((1.0)+(((-1.0)*(gconst25*gconst25))))) < -0.00001)
continue;
sj13=((-1.0)*(IKsqrt(((1.0)+(((-1.0)*(gconst25*gconst25)))))));
cj13=gconst25;
if( (gconst25) < -1-IKFAST_SINCOS_THRESH || (gconst25) > 1+IKFAST_SINCOS_THRESH )
    continue;
j13=((-1.0)*(IKacos(gconst25)));
CheckValue<IkReal> x292=IKPowWithIntegerCheck(((1.0)+(((-1.0)*(new_r22*new_r22)))),-1);
if(!x292.valid){
continue;
}
if((x292.value) < -0.00001)
continue;
IkReal gconst25=IKsqrt(x292.value);
j15eval[0]=((IKabs(new_r11))+(IKabs(new_r10)));
if( IKabs(j15eval[0]) < 0.0000010000000000  )
{
{
IkReal j15array[1], cj15array[1], sj15array[1];
bool j15valid[1]={false};
_nj15 = 1;
if((((1.0)+(((-1.0)*(gconst25*gconst25))))) < -0.00001)
continue;
CheckValue<IkReal> x293=IKPowWithIntegerCheck(gconst25,-1);
if(!x293.valid){
continue;
}
if( IKabs((((gconst25*new_r10))+((new_r00*(IKsqrt(((1.0)+(((-1.0)*(gconst25*gconst25)))))))))) < IKFAST_ATAN2_MAGTHRESH && IKabs((new_r11*(x293.value))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr((((gconst25*new_r10))+((new_r00*(IKsqrt(((1.0)+(((-1.0)*(gconst25*gconst25))))))))))+IKsqr((new_r11*(x293.value)))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j15array[0]=IKatan2((((gconst25*new_r10))+((new_r00*(IKsqrt(((1.0)+(((-1.0)*(gconst25*gconst25))))))))), (new_r11*(x293.value)));
sj15array[0]=IKsin(j15array[0]);
cj15array[0]=IKcos(j15array[0]);
if( j15array[0] > IKPI )
{
    j15array[0]-=IK2PI;
}
else if( j15array[0] < -IKPI )
{    j15array[0]+=IK2PI;
}
j15valid[0] = true;
for(int ij15 = 0; ij15 < 1; ++ij15)
{
if( !j15valid[ij15] )
{
    continue;
}
_ij15[0] = ij15; _ij15[1] = -1;
for(int iij15 = ij15+1; iij15 < 1; ++iij15)
{
if( j15valid[iij15] && IKabs(cj15array[ij15]-cj15array[iij15]) < IKFAST_SOLUTION_THRESH && IKabs(sj15array[ij15]-sj15array[iij15]) < IKFAST_SOLUTION_THRESH )
{
    j15valid[iij15]=false; _ij15[1] = iij15; break; 
}
}
j15 = j15array[ij15]; cj15 = cj15array[ij15]; sj15 = sj15array[ij15];
{
IkReal evalcond[8];
IkReal x294=IKcos(j15);
IkReal x295=IKsin(j15);
IkReal x296=((1.0)*gconst25);
IkReal x297=((1.0)*x294);
IkReal x298=((1.0)*x295);
if((((1.0)+(((-1.0)*gconst25*x296)))) < -0.00001)
continue;
IkReal x299=IKsqrt(((1.0)+(((-1.0)*gconst25*x296))));
evalcond[0]=x295;
evalcond[1]=((-1.0)*x294);
evalcond[2]=(new_r11+(((-1.0)*x294*x296)));
evalcond[3]=((((-1.0)*x295*x296))+new_r10);
evalcond[4]=((((-1.0)*x297*x299))+new_r01);
evalcond[5]=((((-1.0)*x298*x299))+new_r00);
evalcond[6]=(((gconst25*new_r10))+(((-1.0)*x298))+((new_r00*x299)));
evalcond[7]=(((gconst25*new_r11))+(((-1.0)*x297))+((new_r01*x299)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(8);
vinfos[0].jointtype = 17;
vinfos[0].foffset = j5;
vinfos[0].indices[0] = _ij5[0];
vinfos[0].indices[1] = _ij5[1];
vinfos[0].maxsolutions = _nj5;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j9;
vinfos[1].indices[0] = _ij9[0];
vinfos[1].indices[1] = _ij9[1];
vinfos[1].maxsolutions = _nj9;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j10;
vinfos[2].indices[0] = _ij10[0];
vinfos[2].indices[1] = _ij10[1];
vinfos[2].maxsolutions = _nj10;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j11;
vinfos[3].indices[0] = _ij11[0];
vinfos[3].indices[1] = _ij11[1];
vinfos[3].maxsolutions = _nj11;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j12;
vinfos[4].indices[0] = _ij12[0];
vinfos[4].indices[1] = _ij12[1];
vinfos[4].maxsolutions = _nj12;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j13;
vinfos[5].indices[0] = _ij13[0];
vinfos[5].indices[1] = _ij13[1];
vinfos[5].maxsolutions = _nj13;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j14;
vinfos[6].indices[0] = _ij14[0];
vinfos[6].indices[1] = _ij14[1];
vinfos[6].maxsolutions = _nj14;
vinfos[7].jointtype = 1;
vinfos[7].foffset = j15;
vinfos[7].indices[0] = _ij15[0];
vinfos[7].indices[1] = _ij15[1];
vinfos[7].maxsolutions = _nj15;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

} else
{
{
IkReal j15array[1], cj15array[1], sj15array[1];
bool j15valid[1]={false};
_nj15 = 1;
CheckValue<IkReal> x300=IKPowWithIntegerCheck(IKsign(gconst25),-1);
if(!x300.valid){
continue;
}
CheckValue<IkReal> x301 = IKatan2WithCheck(IkReal(new_r10),IkReal(new_r11),IKFAST_ATAN2_MAGTHRESH);
if(!x301.valid){
continue;
}
j15array[0]=((-1.5707963267949)+(((1.5707963267949)*(x300.value)))+(x301.value));
sj15array[0]=IKsin(j15array[0]);
cj15array[0]=IKcos(j15array[0]);
if( j15array[0] > IKPI )
{
    j15array[0]-=IK2PI;
}
else if( j15array[0] < -IKPI )
{    j15array[0]+=IK2PI;
}
j15valid[0] = true;
for(int ij15 = 0; ij15 < 1; ++ij15)
{
if( !j15valid[ij15] )
{
    continue;
}
_ij15[0] = ij15; _ij15[1] = -1;
for(int iij15 = ij15+1; iij15 < 1; ++iij15)
{
if( j15valid[iij15] && IKabs(cj15array[ij15]-cj15array[iij15]) < IKFAST_SOLUTION_THRESH && IKabs(sj15array[ij15]-sj15array[iij15]) < IKFAST_SOLUTION_THRESH )
{
    j15valid[iij15]=false; _ij15[1] = iij15; break; 
}
}
j15 = j15array[ij15]; cj15 = cj15array[ij15]; sj15 = sj15array[ij15];
{
IkReal evalcond[8];
IkReal x302=IKcos(j15);
IkReal x303=IKsin(j15);
IkReal x304=((1.0)*gconst25);
IkReal x305=((1.0)*x302);
IkReal x306=((1.0)*x303);
if((((1.0)+(((-1.0)*gconst25*x304)))) < -0.00001)
continue;
IkReal x307=IKsqrt(((1.0)+(((-1.0)*gconst25*x304))));
evalcond[0]=x303;
evalcond[1]=((-1.0)*x302);
evalcond[2]=((((-1.0)*x302*x304))+new_r11);
evalcond[3]=((((-1.0)*x303*x304))+new_r10);
evalcond[4]=((((-1.0)*x305*x307))+new_r01);
evalcond[5]=((((-1.0)*x306*x307))+new_r00);
evalcond[6]=(((new_r00*x307))+((gconst25*new_r10))+(((-1.0)*x306)));
evalcond[7]=(((gconst25*new_r11))+((new_r01*x307))+(((-1.0)*x305)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(8);
vinfos[0].jointtype = 17;
vinfos[0].foffset = j5;
vinfos[0].indices[0] = _ij5[0];
vinfos[0].indices[1] = _ij5[1];
vinfos[0].maxsolutions = _nj5;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j9;
vinfos[1].indices[0] = _ij9[0];
vinfos[1].indices[1] = _ij9[1];
vinfos[1].maxsolutions = _nj9;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j10;
vinfos[2].indices[0] = _ij10[0];
vinfos[2].indices[1] = _ij10[1];
vinfos[2].maxsolutions = _nj10;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j11;
vinfos[3].indices[0] = _ij11[0];
vinfos[3].indices[1] = _ij11[1];
vinfos[3].maxsolutions = _nj11;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j12;
vinfos[4].indices[0] = _ij12[0];
vinfos[4].indices[1] = _ij12[1];
vinfos[4].maxsolutions = _nj12;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j13;
vinfos[5].indices[0] = _ij13[0];
vinfos[5].indices[1] = _ij13[1];
vinfos[5].maxsolutions = _nj13;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j14;
vinfos[6].indices[0] = _ij14[0];
vinfos[6].indices[1] = _ij14[1];
vinfos[6].maxsolutions = _nj14;
vinfos[7].jointtype = 1;
vinfos[7].foffset = j15;
vinfos[7].indices[0] = _ij15[0];
vinfos[7].indices[1] = _ij15[1];
vinfos[7].maxsolutions = _nj15;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
if( 1 )
{
bgotonextstatement=false;
continue; // branch miss [j15]

}
} while(0);
if( bgotonextstatement )
{
}
}
}
}
}
}
}
}
}
}

} else
{
{
IkReal j15array[1], cj15array[1], sj15array[1];
bool j15valid[1]={false};
_nj15 = 1;
IkReal x308=new_r22*new_r22;
CheckValue<IkReal> x309=IKPowWithIntegerCheck(((((-1.0)*cj13))+((cj13*x308))),-1);
if(!x309.valid){
continue;
}
CheckValue<IkReal> x310=IKPowWithIntegerCheck(((((-1.0)*sj13))+((sj13*x308))),-1);
if(!x310.valid){
continue;
}
if( IKabs(((x309.value)*(((((-1.0)*new_r01*new_r22))+(((-1.0)*new_r10)))))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((x310.value)*((((new_r10*new_r22))+new_r01)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((x309.value)*(((((-1.0)*new_r01*new_r22))+(((-1.0)*new_r10))))))+IKsqr(((x310.value)*((((new_r10*new_r22))+new_r01))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j15array[0]=IKatan2(((x309.value)*(((((-1.0)*new_r01*new_r22))+(((-1.0)*new_r10))))), ((x310.value)*((((new_r10*new_r22))+new_r01))));
sj15array[0]=IKsin(j15array[0]);
cj15array[0]=IKcos(j15array[0]);
if( j15array[0] > IKPI )
{
    j15array[0]-=IK2PI;
}
else if( j15array[0] < -IKPI )
{    j15array[0]+=IK2PI;
}
j15valid[0] = true;
for(int ij15 = 0; ij15 < 1; ++ij15)
{
if( !j15valid[ij15] )
{
    continue;
}
_ij15[0] = ij15; _ij15[1] = -1;
for(int iij15 = ij15+1; iij15 < 1; ++iij15)
{
if( j15valid[iij15] && IKabs(cj15array[ij15]-cj15array[iij15]) < IKFAST_SOLUTION_THRESH && IKabs(sj15array[ij15]-sj15array[iij15]) < IKFAST_SOLUTION_THRESH )
{
    j15valid[iij15]=false; _ij15[1] = iij15; break; 
}
}
j15 = j15array[ij15]; cj15 = cj15array[ij15]; sj15 = sj15array[ij15];
{
IkReal evalcond[10];
IkReal x311=IKsin(j15);
IkReal x312=IKcos(j15);
IkReal x313=(cj13*new_r22);
IkReal x314=((1.0)*sj13);
IkReal x315=(new_r22*sj13);
IkReal x316=((1.0)*x312);
IkReal x317=((1.0)*x311);
IkReal x318=(new_r22*x311);
evalcond[0]=(((cj13*new_r01))+x318+((new_r11*sj13)));
evalcond[1]=(((new_r01*x313))+x311+((new_r11*x315)));
evalcond[2]=((((-1.0)*new_r00*x314))+((cj13*new_r10))+(((-1.0)*x317)));
evalcond[3]=(((cj13*new_r11))+(((-1.0)*x316))+(((-1.0)*new_r01*x314)));
evalcond[4]=(((x311*x313))+new_r01+((sj13*x312)));
evalcond[5]=(((cj13*new_r00))+(((-1.0)*new_r22*x316))+((new_r10*sj13)));
evalcond[6]=((((-1.0)*x313*x316))+new_r00+((sj13*x311)));
evalcond[7]=((((-1.0)*cj13*x316))+((x311*x315))+new_r11);
evalcond[8]=(((new_r00*x313))+(((-1.0)*x316))+((new_r10*x315)));
evalcond[9]=((((-1.0)*cj13*x317))+(((-1.0)*new_r22*x312*x314))+new_r10);
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[8]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[9]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(8);
vinfos[0].jointtype = 17;
vinfos[0].foffset = j5;
vinfos[0].indices[0] = _ij5[0];
vinfos[0].indices[1] = _ij5[1];
vinfos[0].maxsolutions = _nj5;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j9;
vinfos[1].indices[0] = _ij9[0];
vinfos[1].indices[1] = _ij9[1];
vinfos[1].maxsolutions = _nj9;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j10;
vinfos[2].indices[0] = _ij10[0];
vinfos[2].indices[1] = _ij10[1];
vinfos[2].maxsolutions = _nj10;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j11;
vinfos[3].indices[0] = _ij11[0];
vinfos[3].indices[1] = _ij11[1];
vinfos[3].maxsolutions = _nj11;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j12;
vinfos[4].indices[0] = _ij12[0];
vinfos[4].indices[1] = _ij12[1];
vinfos[4].maxsolutions = _nj12;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j13;
vinfos[5].indices[0] = _ij13[0];
vinfos[5].indices[1] = _ij13[1];
vinfos[5].maxsolutions = _nj13;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j14;
vinfos[6].indices[0] = _ij14[0];
vinfos[6].indices[1] = _ij14[1];
vinfos[6].maxsolutions = _nj14;
vinfos[7].jointtype = 1;
vinfos[7].foffset = j15;
vinfos[7].indices[0] = _ij15[0];
vinfos[7].indices[1] = _ij15[1];
vinfos[7].maxsolutions = _nj15;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

} else
{
{
IkReal j15array[1], cj15array[1], sj15array[1];
bool j15valid[1]={false};
_nj15 = 1;
IkReal x319=((1.0)*new_r01);
CheckValue<IkReal> x320=IKPowWithIntegerCheck(new_r22,-1);
if(!x320.valid){
continue;
}
if( IKabs(((x320.value)*(((((-1.0)*cj13*x319))+(((-1.0)*new_r11*sj13)))))) < IKFAST_ATAN2_MAGTHRESH && IKabs((((cj13*new_r11))+(((-1.0)*sj13*x319)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((x320.value)*(((((-1.0)*cj13*x319))+(((-1.0)*new_r11*sj13))))))+IKsqr((((cj13*new_r11))+(((-1.0)*sj13*x319))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j15array[0]=IKatan2(((x320.value)*(((((-1.0)*cj13*x319))+(((-1.0)*new_r11*sj13))))), (((cj13*new_r11))+(((-1.0)*sj13*x319))));
sj15array[0]=IKsin(j15array[0]);
cj15array[0]=IKcos(j15array[0]);
if( j15array[0] > IKPI )
{
    j15array[0]-=IK2PI;
}
else if( j15array[0] < -IKPI )
{    j15array[0]+=IK2PI;
}
j15valid[0] = true;
for(int ij15 = 0; ij15 < 1; ++ij15)
{
if( !j15valid[ij15] )
{
    continue;
}
_ij15[0] = ij15; _ij15[1] = -1;
for(int iij15 = ij15+1; iij15 < 1; ++iij15)
{
if( j15valid[iij15] && IKabs(cj15array[ij15]-cj15array[iij15]) < IKFAST_SOLUTION_THRESH && IKabs(sj15array[ij15]-sj15array[iij15]) < IKFAST_SOLUTION_THRESH )
{
    j15valid[iij15]=false; _ij15[1] = iij15; break; 
}
}
j15 = j15array[ij15]; cj15 = cj15array[ij15]; sj15 = sj15array[ij15];
{
IkReal evalcond[10];
IkReal x321=IKsin(j15);
IkReal x322=IKcos(j15);
IkReal x323=(cj13*new_r22);
IkReal x324=((1.0)*sj13);
IkReal x325=(new_r22*sj13);
IkReal x326=((1.0)*x322);
IkReal x327=((1.0)*x321);
IkReal x328=(new_r22*x321);
evalcond[0]=(((cj13*new_r01))+x328+((new_r11*sj13)));
evalcond[1]=(((new_r01*x323))+x321+((new_r11*x325)));
evalcond[2]=(((cj13*new_r10))+(((-1.0)*x327))+(((-1.0)*new_r00*x324)));
evalcond[3]=(((cj13*new_r11))+(((-1.0)*x326))+(((-1.0)*new_r01*x324)));
evalcond[4]=(((sj13*x322))+new_r01+((x321*x323)));
evalcond[5]=(((cj13*new_r00))+(((-1.0)*new_r22*x326))+((new_r10*sj13)));
evalcond[6]=(((sj13*x321))+(((-1.0)*x323*x326))+new_r00);
evalcond[7]=(new_r11+(((-1.0)*cj13*x326))+((x321*x325)));
evalcond[8]=(((new_r00*x323))+(((-1.0)*x326))+((new_r10*x325)));
evalcond[9]=(new_r10+(((-1.0)*cj13*x327))+(((-1.0)*new_r22*x322*x324)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[8]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[9]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(8);
vinfos[0].jointtype = 17;
vinfos[0].foffset = j5;
vinfos[0].indices[0] = _ij5[0];
vinfos[0].indices[1] = _ij5[1];
vinfos[0].maxsolutions = _nj5;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j9;
vinfos[1].indices[0] = _ij9[0];
vinfos[1].indices[1] = _ij9[1];
vinfos[1].maxsolutions = _nj9;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j10;
vinfos[2].indices[0] = _ij10[0];
vinfos[2].indices[1] = _ij10[1];
vinfos[2].maxsolutions = _nj10;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j11;
vinfos[3].indices[0] = _ij11[0];
vinfos[3].indices[1] = _ij11[1];
vinfos[3].maxsolutions = _nj11;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j12;
vinfos[4].indices[0] = _ij12[0];
vinfos[4].indices[1] = _ij12[1];
vinfos[4].maxsolutions = _nj12;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j13;
vinfos[5].indices[0] = _ij13[0];
vinfos[5].indices[1] = _ij13[1];
vinfos[5].maxsolutions = _nj13;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j14;
vinfos[6].indices[0] = _ij14[0];
vinfos[6].indices[1] = _ij14[1];
vinfos[6].maxsolutions = _nj14;
vinfos[7].jointtype = 1;
vinfos[7].foffset = j15;
vinfos[7].indices[0] = _ij15[0];
vinfos[7].indices[1] = _ij15[1];
vinfos[7].maxsolutions = _nj15;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

} else
{
{
IkReal j15array[1], cj15array[1], sj15array[1];
bool j15valid[1]={false};
_nj15 = 1;
IkReal x329=cj13*cj13;
IkReal x330=(cj13*new_r22);
CheckValue<IkReal> x331 = IKatan2WithCheck(IkReal((((new_r01*x330))+((new_r00*sj13)))),IkReal((((new_r01*sj13))+(((-1.0)*new_r00*x330)))),IKFAST_ATAN2_MAGTHRESH);
if(!x331.valid){
continue;
}
CheckValue<IkReal> x332=IKPowWithIntegerCheck(IKsign(((-1.0)+(((-1.0)*x329*(new_r22*new_r22)))+x329)),-1);
if(!x332.valid){
continue;
}
j15array[0]=((-1.5707963267949)+(x331.value)+(((1.5707963267949)*(x332.value))));
sj15array[0]=IKsin(j15array[0]);
cj15array[0]=IKcos(j15array[0]);
if( j15array[0] > IKPI )
{
    j15array[0]-=IK2PI;
}
else if( j15array[0] < -IKPI )
{    j15array[0]+=IK2PI;
}
j15valid[0] = true;
for(int ij15 = 0; ij15 < 1; ++ij15)
{
if( !j15valid[ij15] )
{
    continue;
}
_ij15[0] = ij15; _ij15[1] = -1;
for(int iij15 = ij15+1; iij15 < 1; ++iij15)
{
if( j15valid[iij15] && IKabs(cj15array[ij15]-cj15array[iij15]) < IKFAST_SOLUTION_THRESH && IKabs(sj15array[ij15]-sj15array[iij15]) < IKFAST_SOLUTION_THRESH )
{
    j15valid[iij15]=false; _ij15[1] = iij15; break; 
}
}
j15 = j15array[ij15]; cj15 = cj15array[ij15]; sj15 = sj15array[ij15];
{
IkReal evalcond[10];
IkReal x333=IKsin(j15);
IkReal x334=IKcos(j15);
IkReal x335=(cj13*new_r22);
IkReal x336=((1.0)*sj13);
IkReal x337=(new_r22*sj13);
IkReal x338=((1.0)*x334);
IkReal x339=((1.0)*x333);
IkReal x340=(new_r22*x333);
evalcond[0]=(((cj13*new_r01))+x340+((new_r11*sj13)));
evalcond[1]=(((new_r01*x335))+((new_r11*x337))+x333);
evalcond[2]=(((cj13*new_r10))+(((-1.0)*new_r00*x336))+(((-1.0)*x339)));
evalcond[3]=(((cj13*new_r11))+(((-1.0)*x338))+(((-1.0)*new_r01*x336)));
evalcond[4]=(((x333*x335))+new_r01+((sj13*x334)));
evalcond[5]=((((-1.0)*new_r22*x338))+((cj13*new_r00))+((new_r10*sj13)));
evalcond[6]=(new_r00+((sj13*x333))+(((-1.0)*x335*x338)));
evalcond[7]=((((-1.0)*cj13*x338))+((x333*x337))+new_r11);
evalcond[8]=(((new_r00*x335))+((new_r10*x337))+(((-1.0)*x338)));
evalcond[9]=((((-1.0)*cj13*x339))+(((-1.0)*new_r22*x334*x336))+new_r10);
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[8]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[9]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(8);
vinfos[0].jointtype = 17;
vinfos[0].foffset = j5;
vinfos[0].indices[0] = _ij5[0];
vinfos[0].indices[1] = _ij5[1];
vinfos[0].maxsolutions = _nj5;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j9;
vinfos[1].indices[0] = _ij9[0];
vinfos[1].indices[1] = _ij9[1];
vinfos[1].maxsolutions = _nj9;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j10;
vinfos[2].indices[0] = _ij10[0];
vinfos[2].indices[1] = _ij10[1];
vinfos[2].maxsolutions = _nj10;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j11;
vinfos[3].indices[0] = _ij11[0];
vinfos[3].indices[1] = _ij11[1];
vinfos[3].maxsolutions = _nj11;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j12;
vinfos[4].indices[0] = _ij12[0];
vinfos[4].indices[1] = _ij12[1];
vinfos[4].maxsolutions = _nj12;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j13;
vinfos[5].indices[0] = _ij13[0];
vinfos[5].indices[1] = _ij13[1];
vinfos[5].maxsolutions = _nj13;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j14;
vinfos[6].indices[0] = _ij14[0];
vinfos[6].indices[1] = _ij14[1];
vinfos[6].maxsolutions = _nj14;
vinfos[7].jointtype = 1;
vinfos[7].foffset = j15;
vinfos[7].indices[0] = _ij15[0];
vinfos[7].indices[1] = _ij15[1];
vinfos[7].maxsolutions = _nj15;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}
    }

}

}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
if( 1 )
{
bgotonextstatement=false;
continue; // branch miss [j13, j15]

}
} while(0);
if( bgotonextstatement )
{
}
}
}
}
}

} else
{
{
IkReal j13array[1], cj13array[1], sj13array[1];
bool j13valid[1]={false};
_nj13 = 1;
CheckValue<IkReal> x342=IKPowWithIntegerCheck(sj14,-1);
if(!x342.valid){
continue;
}
IkReal x341=x342.value;
CheckValue<IkReal> x343=IKPowWithIntegerCheck(new_r12,-1);
if(!x343.valid){
continue;
}
if( IKabs((x341*(x343.value)*(((1.0)+(((-1.0)*(new_r02*new_r02)))+(((-1.0)*(cj14*cj14))))))) < IKFAST_ATAN2_MAGTHRESH && IKabs((new_r02*x341)) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr((x341*(x343.value)*(((1.0)+(((-1.0)*(new_r02*new_r02)))+(((-1.0)*(cj14*cj14)))))))+IKsqr((new_r02*x341))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j13array[0]=IKatan2((x341*(x343.value)*(((1.0)+(((-1.0)*(new_r02*new_r02)))+(((-1.0)*(cj14*cj14)))))), (new_r02*x341));
sj13array[0]=IKsin(j13array[0]);
cj13array[0]=IKcos(j13array[0]);
if( j13array[0] > IKPI )
{
    j13array[0]-=IK2PI;
}
else if( j13array[0] < -IKPI )
{    j13array[0]+=IK2PI;
}
j13valid[0] = true;
for(int ij13 = 0; ij13 < 1; ++ij13)
{
if( !j13valid[ij13] )
{
    continue;
}
_ij13[0] = ij13; _ij13[1] = -1;
for(int iij13 = ij13+1; iij13 < 1; ++iij13)
{
if( j13valid[iij13] && IKabs(cj13array[ij13]-cj13array[iij13]) < IKFAST_SOLUTION_THRESH && IKabs(sj13array[ij13]-sj13array[iij13]) < IKFAST_SOLUTION_THRESH )
{
    j13valid[iij13]=false; _ij13[1] = iij13; break; 
}
}
j13 = j13array[ij13]; cj13 = cj13array[ij13]; sj13 = sj13array[ij13];
{
IkReal evalcond[8];
IkReal x344=IKcos(j13);
IkReal x345=IKsin(j13);
IkReal x346=((1.0)*sj14);
IkReal x347=(new_r12*x345);
IkReal x348=(new_r02*x344);
IkReal x349=(sj14*x344);
IkReal x350=(sj14*x345);
evalcond[0]=((((-1.0)*x344*x346))+new_r02);
evalcond[1]=((((-1.0)*x345*x346))+new_r12);
evalcond[2]=(((new_r12*x344))+(((-1.0)*new_r02*x345)));
evalcond[3]=(x347+x348+(((-1.0)*x346)));
evalcond[4]=(((new_r00*x349))+((cj14*new_r20))+((new_r10*x350)));
evalcond[5]=(((new_r01*x349))+((cj14*new_r21))+((new_r11*x350)));
evalcond[6]=((-1.0)+((sj14*x348))+((sj14*x347))+((cj14*new_r22)));
evalcond[7]=(((cj14*x348))+((cj14*x347))+(((-1.0)*new_r22*x346)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
IkReal j15eval[3];
j15eval[0]=sj14;
j15eval[1]=IKsign(sj14);
j15eval[2]=((IKabs(new_r20))+(IKabs(new_r21)));
if( IKabs(j15eval[0]) < 0.0000010000000000  || IKabs(j15eval[1]) < 0.0000010000000000  || IKabs(j15eval[2]) < 0.0000010000000000  )
{
{
IkReal j15eval[2];
j15eval[0]=sj14;
j15eval[1]=sj13;
if( IKabs(j15eval[0]) < 0.0000010000000000  || IKabs(j15eval[1]) < 0.0000010000000000  )
{
{
IkReal j15eval[3];
j15eval[0]=cj14;
j15eval[1]=sj13;
j15eval[2]=sj14;
if( IKabs(j15eval[0]) < 0.0000010000000000  || IKabs(j15eval[1]) < 0.0000010000000000  || IKabs(j15eval[2]) < 0.0000010000000000  )
{
{
IkReal evalcond[5];
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((-1.5707963267949)+j14)))), 6.28318530717959)));
evalcond[1]=new_r22;
if( IKabs(evalcond[0]) < 0.0000050000000000  && IKabs(evalcond[1]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j15array[1], cj15array[1], sj15array[1];
bool j15valid[1]={false};
_nj15 = 1;
if( IKabs(new_r21) < IKFAST_ATAN2_MAGTHRESH && IKabs(((-1.0)*new_r20)) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(new_r21)+IKsqr(((-1.0)*new_r20))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j15array[0]=IKatan2(new_r21, ((-1.0)*new_r20));
sj15array[0]=IKsin(j15array[0]);
cj15array[0]=IKcos(j15array[0]);
if( j15array[0] > IKPI )
{
    j15array[0]-=IK2PI;
}
else if( j15array[0] < -IKPI )
{    j15array[0]+=IK2PI;
}
j15valid[0] = true;
for(int ij15 = 0; ij15 < 1; ++ij15)
{
if( !j15valid[ij15] )
{
    continue;
}
_ij15[0] = ij15; _ij15[1] = -1;
for(int iij15 = ij15+1; iij15 < 1; ++iij15)
{
if( j15valid[iij15] && IKabs(cj15array[ij15]-cj15array[iij15]) < IKFAST_SOLUTION_THRESH && IKabs(sj15array[ij15]-sj15array[iij15]) < IKFAST_SOLUTION_THRESH )
{
    j15valid[iij15]=false; _ij15[1] = iij15; break; 
}
}
j15 = j15array[ij15]; cj15 = cj15array[ij15]; sj15 = sj15array[ij15];
{
IkReal evalcond[8];
IkReal x351=IKcos(j15);
IkReal x352=IKsin(j15);
IkReal x353=((1.0)*cj13);
IkReal x354=((1.0)*sj13);
IkReal x355=((1.0)*x352);
evalcond[0]=(x351+new_r20);
evalcond[1]=((((-1.0)*x355))+new_r21);
evalcond[2]=(((sj13*x351))+new_r01);
evalcond[3]=(((sj13*x352))+new_r00);
evalcond[4]=((((-1.0)*x351*x353))+new_r11);
evalcond[5]=(new_r10+(((-1.0)*x352*x353)));
evalcond[6]=(((cj13*new_r10))+(((-1.0)*x355))+(((-1.0)*new_r00*x354)));
evalcond[7]=(((cj13*new_r11))+(((-1.0)*x351))+(((-1.0)*new_r01*x354)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(8);
vinfos[0].jointtype = 17;
vinfos[0].foffset = j5;
vinfos[0].indices[0] = _ij5[0];
vinfos[0].indices[1] = _ij5[1];
vinfos[0].maxsolutions = _nj5;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j9;
vinfos[1].indices[0] = _ij9[0];
vinfos[1].indices[1] = _ij9[1];
vinfos[1].maxsolutions = _nj9;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j10;
vinfos[2].indices[0] = _ij10[0];
vinfos[2].indices[1] = _ij10[1];
vinfos[2].maxsolutions = _nj10;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j11;
vinfos[3].indices[0] = _ij11[0];
vinfos[3].indices[1] = _ij11[1];
vinfos[3].maxsolutions = _nj11;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j12;
vinfos[4].indices[0] = _ij12[0];
vinfos[4].indices[1] = _ij12[1];
vinfos[4].maxsolutions = _nj12;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j13;
vinfos[5].indices[0] = _ij13[0];
vinfos[5].indices[1] = _ij13[1];
vinfos[5].maxsolutions = _nj13;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j14;
vinfos[6].indices[0] = _ij14[0];
vinfos[6].indices[1] = _ij14[1];
vinfos[6].maxsolutions = _nj14;
vinfos[7].jointtype = 1;
vinfos[7].foffset = j15;
vinfos[7].indices[0] = _ij15[0];
vinfos[7].indices[1] = _ij15[1];
vinfos[7].maxsolutions = _nj15;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((1.5707963267949)+j14)))), 6.28318530717959)));
evalcond[1]=new_r22;
if( IKabs(evalcond[0]) < 0.0000050000000000  && IKabs(evalcond[1]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j15array[1], cj15array[1], sj15array[1];
bool j15valid[1]={false};
_nj15 = 1;
if( IKabs(((-1.0)*new_r21)) < IKFAST_ATAN2_MAGTHRESH && IKabs(new_r20) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((-1.0)*new_r21))+IKsqr(new_r20)-1) <= IKFAST_SINCOS_THRESH )
    continue;
j15array[0]=IKatan2(((-1.0)*new_r21), new_r20);
sj15array[0]=IKsin(j15array[0]);
cj15array[0]=IKcos(j15array[0]);
if( j15array[0] > IKPI )
{
    j15array[0]-=IK2PI;
}
else if( j15array[0] < -IKPI )
{    j15array[0]+=IK2PI;
}
j15valid[0] = true;
for(int ij15 = 0; ij15 < 1; ++ij15)
{
if( !j15valid[ij15] )
{
    continue;
}
_ij15[0] = ij15; _ij15[1] = -1;
for(int iij15 = ij15+1; iij15 < 1; ++iij15)
{
if( j15valid[iij15] && IKabs(cj15array[ij15]-cj15array[iij15]) < IKFAST_SOLUTION_THRESH && IKabs(sj15array[ij15]-sj15array[iij15]) < IKFAST_SOLUTION_THRESH )
{
    j15valid[iij15]=false; _ij15[1] = iij15; break; 
}
}
j15 = j15array[ij15]; cj15 = cj15array[ij15]; sj15 = sj15array[ij15];
{
IkReal evalcond[8];
IkReal x356=IKcos(j15);
IkReal x357=IKsin(j15);
IkReal x358=((1.0)*cj13);
IkReal x359=((1.0)*sj13);
IkReal x360=((1.0)*x356);
evalcond[0]=(x357+new_r21);
evalcond[1]=((((-1.0)*x360))+new_r20);
evalcond[2]=(((sj13*x356))+new_r01);
evalcond[3]=(((sj13*x357))+new_r00);
evalcond[4]=((((-1.0)*x356*x358))+new_r11);
evalcond[5]=((((-1.0)*x357*x358))+new_r10);
evalcond[6]=(((cj13*new_r10))+(((-1.0)*x357))+(((-1.0)*new_r00*x359)));
evalcond[7]=(((cj13*new_r11))+(((-1.0)*x360))+(((-1.0)*new_r01*x359)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(8);
vinfos[0].jointtype = 17;
vinfos[0].foffset = j5;
vinfos[0].indices[0] = _ij5[0];
vinfos[0].indices[1] = _ij5[1];
vinfos[0].maxsolutions = _nj5;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j9;
vinfos[1].indices[0] = _ij9[0];
vinfos[1].indices[1] = _ij9[1];
vinfos[1].maxsolutions = _nj9;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j10;
vinfos[2].indices[0] = _ij10[0];
vinfos[2].indices[1] = _ij10[1];
vinfos[2].maxsolutions = _nj10;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j11;
vinfos[3].indices[0] = _ij11[0];
vinfos[3].indices[1] = _ij11[1];
vinfos[3].maxsolutions = _nj11;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j12;
vinfos[4].indices[0] = _ij12[0];
vinfos[4].indices[1] = _ij12[1];
vinfos[4].maxsolutions = _nj12;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j13;
vinfos[5].indices[0] = _ij13[0];
vinfos[5].indices[1] = _ij13[1];
vinfos[5].maxsolutions = _nj13;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j14;
vinfos[6].indices[0] = _ij14[0];
vinfos[6].indices[1] = _ij14[1];
vinfos[6].maxsolutions = _nj14;
vinfos[7].jointtype = 1;
vinfos[7].foffset = j15;
vinfos[7].indices[0] = _ij15[0];
vinfos[7].indices[1] = _ij15[1];
vinfos[7].maxsolutions = _nj15;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(j13))), 6.28318530717959)));
evalcond[1]=new_r12;
if( IKabs(evalcond[0]) < 0.0000050000000000  && IKabs(evalcond[1]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j15array[1], cj15array[1], sj15array[1];
bool j15valid[1]={false};
_nj15 = 1;
if( IKabs(new_r10) < IKFAST_ATAN2_MAGTHRESH && IKabs(new_r11) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(new_r10)+IKsqr(new_r11)-1) <= IKFAST_SINCOS_THRESH )
    continue;
j15array[0]=IKatan2(new_r10, new_r11);
sj15array[0]=IKsin(j15array[0]);
cj15array[0]=IKcos(j15array[0]);
if( j15array[0] > IKPI )
{
    j15array[0]-=IK2PI;
}
else if( j15array[0] < -IKPI )
{    j15array[0]+=IK2PI;
}
j15valid[0] = true;
for(int ij15 = 0; ij15 < 1; ++ij15)
{
if( !j15valid[ij15] )
{
    continue;
}
_ij15[0] = ij15; _ij15[1] = -1;
for(int iij15 = ij15+1; iij15 < 1; ++iij15)
{
if( j15valid[iij15] && IKabs(cj15array[ij15]-cj15array[iij15]) < IKFAST_SOLUTION_THRESH && IKabs(sj15array[ij15]-sj15array[iij15]) < IKFAST_SOLUTION_THRESH )
{
    j15valid[iij15]=false; _ij15[1] = iij15; break; 
}
}
j15 = j15array[ij15]; cj15 = cj15array[ij15]; sj15 = sj15array[ij15];
{
IkReal evalcond[8];
IkReal x361=IKcos(j15);
IkReal x362=IKsin(j15);
IkReal x363=((1.0)*sj14);
IkReal x364=((1.0)*x361);
evalcond[0]=(((sj14*x361))+new_r20);
evalcond[1]=((((-1.0)*x362))+new_r10);
evalcond[2]=((((-1.0)*x364))+new_r11);
evalcond[3]=(new_r01+((cj14*x362)));
evalcond[4]=((((-1.0)*x362*x363))+new_r21);
evalcond[5]=((((-1.0)*cj14*x364))+new_r00);
evalcond[6]=(((cj14*new_r01))+x362+(((-1.0)*new_r21*x363)));
evalcond[7]=(((cj14*new_r00))+(((-1.0)*new_r20*x363))+(((-1.0)*x364)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(8);
vinfos[0].jointtype = 17;
vinfos[0].foffset = j5;
vinfos[0].indices[0] = _ij5[0];
vinfos[0].indices[1] = _ij5[1];
vinfos[0].maxsolutions = _nj5;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j9;
vinfos[1].indices[0] = _ij9[0];
vinfos[1].indices[1] = _ij9[1];
vinfos[1].maxsolutions = _nj9;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j10;
vinfos[2].indices[0] = _ij10[0];
vinfos[2].indices[1] = _ij10[1];
vinfos[2].maxsolutions = _nj10;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j11;
vinfos[3].indices[0] = _ij11[0];
vinfos[3].indices[1] = _ij11[1];
vinfos[3].maxsolutions = _nj11;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j12;
vinfos[4].indices[0] = _ij12[0];
vinfos[4].indices[1] = _ij12[1];
vinfos[4].maxsolutions = _nj12;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j13;
vinfos[5].indices[0] = _ij13[0];
vinfos[5].indices[1] = _ij13[1];
vinfos[5].maxsolutions = _nj13;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j14;
vinfos[6].indices[0] = _ij14[0];
vinfos[6].indices[1] = _ij14[1];
vinfos[6].maxsolutions = _nj14;
vinfos[7].jointtype = 1;
vinfos[7].foffset = j15;
vinfos[7].indices[0] = _ij15[0];
vinfos[7].indices[1] = _ij15[1];
vinfos[7].maxsolutions = _nj15;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((-3.14159265358979)+j13)))), 6.28318530717959)));
evalcond[1]=new_r12;
if( IKabs(evalcond[0]) < 0.0000050000000000  && IKabs(evalcond[1]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j15eval[3];
sj13=0;
cj13=-1.0;
j13=3.14159265358979;
j15eval[0]=sj14;
j15eval[1]=IKsign(sj14);
j15eval[2]=((IKabs(new_r20))+(IKabs(new_r21)));
if( IKabs(j15eval[0]) < 0.0000010000000000  || IKabs(j15eval[1]) < 0.0000010000000000  || IKabs(j15eval[2]) < 0.0000010000000000  )
{
{
IkReal j15eval[1];
sj13=0;
cj13=-1.0;
j13=3.14159265358979;
j15eval[0]=sj14;
if( IKabs(j15eval[0]) < 0.0000010000000000  )
{
{
IkReal j15eval[2];
sj13=0;
cj13=-1.0;
j13=3.14159265358979;
j15eval[0]=cj14;
j15eval[1]=sj14;
if( IKabs(j15eval[0]) < 0.0000010000000000  || IKabs(j15eval[1]) < 0.0000010000000000  )
{
{
IkReal evalcond[4];
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((-1.5707963267949)+j14)))), 6.28318530717959)));
evalcond[1]=new_r22;
evalcond[2]=new_r01;
evalcond[3]=new_r00;
if( IKabs(evalcond[0]) < 0.0000050000000000  && IKabs(evalcond[1]) < 0.0000050000000000  && IKabs(evalcond[2]) < 0.0000050000000000  && IKabs(evalcond[3]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j15array[1], cj15array[1], sj15array[1];
bool j15valid[1]={false};
_nj15 = 1;
if( IKabs(new_r21) < IKFAST_ATAN2_MAGTHRESH && IKabs(((-1.0)*new_r20)) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(new_r21)+IKsqr(((-1.0)*new_r20))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j15array[0]=IKatan2(new_r21, ((-1.0)*new_r20));
sj15array[0]=IKsin(j15array[0]);
cj15array[0]=IKcos(j15array[0]);
if( j15array[0] > IKPI )
{
    j15array[0]-=IK2PI;
}
else if( j15array[0] < -IKPI )
{    j15array[0]+=IK2PI;
}
j15valid[0] = true;
for(int ij15 = 0; ij15 < 1; ++ij15)
{
if( !j15valid[ij15] )
{
    continue;
}
_ij15[0] = ij15; _ij15[1] = -1;
for(int iij15 = ij15+1; iij15 < 1; ++iij15)
{
if( j15valid[iij15] && IKabs(cj15array[ij15]-cj15array[iij15]) < IKFAST_SOLUTION_THRESH && IKabs(sj15array[ij15]-sj15array[iij15]) < IKFAST_SOLUTION_THRESH )
{
    j15valid[iij15]=false; _ij15[1] = iij15; break; 
}
}
j15 = j15array[ij15]; cj15 = cj15array[ij15]; sj15 = sj15array[ij15];
{
IkReal evalcond[4];
IkReal x365=IKcos(j15);
IkReal x366=((1.0)*(IKsin(j15)));
evalcond[0]=(x365+new_r20);
evalcond[1]=((((-1.0)*x366))+new_r21);
evalcond[2]=((((-1.0)*x366))+(((-1.0)*new_r10)));
evalcond[3]=((((-1.0)*x365))+(((-1.0)*new_r11)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(8);
vinfos[0].jointtype = 17;
vinfos[0].foffset = j5;
vinfos[0].indices[0] = _ij5[0];
vinfos[0].indices[1] = _ij5[1];
vinfos[0].maxsolutions = _nj5;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j9;
vinfos[1].indices[0] = _ij9[0];
vinfos[1].indices[1] = _ij9[1];
vinfos[1].maxsolutions = _nj9;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j10;
vinfos[2].indices[0] = _ij10[0];
vinfos[2].indices[1] = _ij10[1];
vinfos[2].maxsolutions = _nj10;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j11;
vinfos[3].indices[0] = _ij11[0];
vinfos[3].indices[1] = _ij11[1];
vinfos[3].maxsolutions = _nj11;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j12;
vinfos[4].indices[0] = _ij12[0];
vinfos[4].indices[1] = _ij12[1];
vinfos[4].maxsolutions = _nj12;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j13;
vinfos[5].indices[0] = _ij13[0];
vinfos[5].indices[1] = _ij13[1];
vinfos[5].maxsolutions = _nj13;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j14;
vinfos[6].indices[0] = _ij14[0];
vinfos[6].indices[1] = _ij14[1];
vinfos[6].maxsolutions = _nj14;
vinfos[7].jointtype = 1;
vinfos[7].foffset = j15;
vinfos[7].indices[0] = _ij15[0];
vinfos[7].indices[1] = _ij15[1];
vinfos[7].maxsolutions = _nj15;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((1.5707963267949)+j14)))), 6.28318530717959)));
evalcond[1]=new_r22;
evalcond[2]=new_r01;
evalcond[3]=new_r00;
if( IKabs(evalcond[0]) < 0.0000050000000000  && IKabs(evalcond[1]) < 0.0000050000000000  && IKabs(evalcond[2]) < 0.0000050000000000  && IKabs(evalcond[3]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j15array[1], cj15array[1], sj15array[1];
bool j15valid[1]={false};
_nj15 = 1;
if( IKabs(((-1.0)*new_r21)) < IKFAST_ATAN2_MAGTHRESH && IKabs(new_r20) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((-1.0)*new_r21))+IKsqr(new_r20)-1) <= IKFAST_SINCOS_THRESH )
    continue;
j15array[0]=IKatan2(((-1.0)*new_r21), new_r20);
sj15array[0]=IKsin(j15array[0]);
cj15array[0]=IKcos(j15array[0]);
if( j15array[0] > IKPI )
{
    j15array[0]-=IK2PI;
}
else if( j15array[0] < -IKPI )
{    j15array[0]+=IK2PI;
}
j15valid[0] = true;
for(int ij15 = 0; ij15 < 1; ++ij15)
{
if( !j15valid[ij15] )
{
    continue;
}
_ij15[0] = ij15; _ij15[1] = -1;
for(int iij15 = ij15+1; iij15 < 1; ++iij15)
{
if( j15valid[iij15] && IKabs(cj15array[ij15]-cj15array[iij15]) < IKFAST_SOLUTION_THRESH && IKabs(sj15array[ij15]-sj15array[iij15]) < IKFAST_SOLUTION_THRESH )
{
    j15valid[iij15]=false; _ij15[1] = iij15; break; 
}
}
j15 = j15array[ij15]; cj15 = cj15array[ij15]; sj15 = sj15array[ij15];
{
IkReal evalcond[4];
IkReal x367=IKsin(j15);
IkReal x368=((1.0)*(IKcos(j15)));
evalcond[0]=(x367+new_r21);
evalcond[1]=((((-1.0)*x368))+new_r20);
evalcond[2]=((((-1.0)*x367))+(((-1.0)*new_r10)));
evalcond[3]=((((-1.0)*x368))+(((-1.0)*new_r11)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(8);
vinfos[0].jointtype = 17;
vinfos[0].foffset = j5;
vinfos[0].indices[0] = _ij5[0];
vinfos[0].indices[1] = _ij5[1];
vinfos[0].maxsolutions = _nj5;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j9;
vinfos[1].indices[0] = _ij9[0];
vinfos[1].indices[1] = _ij9[1];
vinfos[1].maxsolutions = _nj9;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j10;
vinfos[2].indices[0] = _ij10[0];
vinfos[2].indices[1] = _ij10[1];
vinfos[2].maxsolutions = _nj10;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j11;
vinfos[3].indices[0] = _ij11[0];
vinfos[3].indices[1] = _ij11[1];
vinfos[3].maxsolutions = _nj11;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j12;
vinfos[4].indices[0] = _ij12[0];
vinfos[4].indices[1] = _ij12[1];
vinfos[4].maxsolutions = _nj12;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j13;
vinfos[5].indices[0] = _ij13[0];
vinfos[5].indices[1] = _ij13[1];
vinfos[5].maxsolutions = _nj13;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j14;
vinfos[6].indices[0] = _ij14[0];
vinfos[6].indices[1] = _ij14[1];
vinfos[6].maxsolutions = _nj14;
vinfos[7].jointtype = 1;
vinfos[7].foffset = j15;
vinfos[7].indices[0] = _ij15[0];
vinfos[7].indices[1] = _ij15[1];
vinfos[7].maxsolutions = _nj15;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(j14))), 6.28318530717959)));
evalcond[1]=new_r20;
evalcond[2]=new_r02;
evalcond[3]=new_r21;
if( IKabs(evalcond[0]) < 0.0000050000000000  && IKabs(evalcond[1]) < 0.0000050000000000  && IKabs(evalcond[2]) < 0.0000050000000000  && IKabs(evalcond[3]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j15array[1], cj15array[1], sj15array[1];
bool j15valid[1]={false};
_nj15 = 1;
if( IKabs(new_r01) < IKFAST_ATAN2_MAGTHRESH && IKabs(((-1.0)*new_r11)) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(new_r01)+IKsqr(((-1.0)*new_r11))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j15array[0]=IKatan2(new_r01, ((-1.0)*new_r11));
sj15array[0]=IKsin(j15array[0]);
cj15array[0]=IKcos(j15array[0]);
if( j15array[0] > IKPI )
{
    j15array[0]-=IK2PI;
}
else if( j15array[0] < -IKPI )
{    j15array[0]+=IK2PI;
}
j15valid[0] = true;
for(int ij15 = 0; ij15 < 1; ++ij15)
{
if( !j15valid[ij15] )
{
    continue;
}
_ij15[0] = ij15; _ij15[1] = -1;
for(int iij15 = ij15+1; iij15 < 1; ++iij15)
{
if( j15valid[iij15] && IKabs(cj15array[ij15]-cj15array[iij15]) < IKFAST_SOLUTION_THRESH && IKabs(sj15array[ij15]-sj15array[iij15]) < IKFAST_SOLUTION_THRESH )
{
    j15valid[iij15]=false; _ij15[1] = iij15; break; 
}
}
j15 = j15array[ij15]; cj15 = cj15array[ij15]; sj15 = sj15array[ij15];
{
IkReal evalcond[4];
IkReal x369=IKsin(j15);
IkReal x370=((1.0)*(IKcos(j15)));
evalcond[0]=(x369+(((-1.0)*new_r01)));
evalcond[1]=((((-1.0)*x369))+(((-1.0)*new_r10)));
evalcond[2]=((((-1.0)*x370))+(((-1.0)*new_r11)));
evalcond[3]=((((-1.0)*x370))+(((-1.0)*new_r00)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(8);
vinfos[0].jointtype = 17;
vinfos[0].foffset = j5;
vinfos[0].indices[0] = _ij5[0];
vinfos[0].indices[1] = _ij5[1];
vinfos[0].maxsolutions = _nj5;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j9;
vinfos[1].indices[0] = _ij9[0];
vinfos[1].indices[1] = _ij9[1];
vinfos[1].maxsolutions = _nj9;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j10;
vinfos[2].indices[0] = _ij10[0];
vinfos[2].indices[1] = _ij10[1];
vinfos[2].maxsolutions = _nj10;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j11;
vinfos[3].indices[0] = _ij11[0];
vinfos[3].indices[1] = _ij11[1];
vinfos[3].maxsolutions = _nj11;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j12;
vinfos[4].indices[0] = _ij12[0];
vinfos[4].indices[1] = _ij12[1];
vinfos[4].maxsolutions = _nj12;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j13;
vinfos[5].indices[0] = _ij13[0];
vinfos[5].indices[1] = _ij13[1];
vinfos[5].maxsolutions = _nj13;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j14;
vinfos[6].indices[0] = _ij14[0];
vinfos[6].indices[1] = _ij14[1];
vinfos[6].maxsolutions = _nj14;
vinfos[7].jointtype = 1;
vinfos[7].foffset = j15;
vinfos[7].indices[0] = _ij15[0];
vinfos[7].indices[1] = _ij15[1];
vinfos[7].maxsolutions = _nj15;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((-3.14159265358979)+j14)))), 6.28318530717959)));
evalcond[1]=new_r20;
evalcond[2]=new_r02;
evalcond[3]=new_r21;
if( IKabs(evalcond[0]) < 0.0000050000000000  && IKabs(evalcond[1]) < 0.0000050000000000  && IKabs(evalcond[2]) < 0.0000050000000000  && IKabs(evalcond[3]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j15array[1], cj15array[1], sj15array[1];
bool j15valid[1]={false};
_nj15 = 1;
if( IKabs(((-1.0)*new_r10)) < IKFAST_ATAN2_MAGTHRESH && IKabs(new_r00) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((-1.0)*new_r10))+IKsqr(new_r00)-1) <= IKFAST_SINCOS_THRESH )
    continue;
j15array[0]=IKatan2(((-1.0)*new_r10), new_r00);
sj15array[0]=IKsin(j15array[0]);
cj15array[0]=IKcos(j15array[0]);
if( j15array[0] > IKPI )
{
    j15array[0]-=IK2PI;
}
else if( j15array[0] < -IKPI )
{    j15array[0]+=IK2PI;
}
j15valid[0] = true;
for(int ij15 = 0; ij15 < 1; ++ij15)
{
if( !j15valid[ij15] )
{
    continue;
}
_ij15[0] = ij15; _ij15[1] = -1;
for(int iij15 = ij15+1; iij15 < 1; ++iij15)
{
if( j15valid[iij15] && IKabs(cj15array[ij15]-cj15array[iij15]) < IKFAST_SOLUTION_THRESH && IKabs(sj15array[ij15]-sj15array[iij15]) < IKFAST_SOLUTION_THRESH )
{
    j15valid[iij15]=false; _ij15[1] = iij15; break; 
}
}
j15 = j15array[ij15]; cj15 = cj15array[ij15]; sj15 = sj15array[ij15];
{
IkReal evalcond[4];
IkReal x371=IKcos(j15);
IkReal x372=((1.0)*(IKsin(j15)));
evalcond[0]=(x371+(((-1.0)*new_r00)));
evalcond[1]=((((-1.0)*x372))+(((-1.0)*new_r10)));
evalcond[2]=((((-1.0)*x371))+(((-1.0)*new_r11)));
evalcond[3]=((((-1.0)*x372))+(((-1.0)*new_r01)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(8);
vinfos[0].jointtype = 17;
vinfos[0].foffset = j5;
vinfos[0].indices[0] = _ij5[0];
vinfos[0].indices[1] = _ij5[1];
vinfos[0].maxsolutions = _nj5;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j9;
vinfos[1].indices[0] = _ij9[0];
vinfos[1].indices[1] = _ij9[1];
vinfos[1].maxsolutions = _nj9;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j10;
vinfos[2].indices[0] = _ij10[0];
vinfos[2].indices[1] = _ij10[1];
vinfos[2].maxsolutions = _nj10;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j11;
vinfos[3].indices[0] = _ij11[0];
vinfos[3].indices[1] = _ij11[1];
vinfos[3].maxsolutions = _nj11;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j12;
vinfos[4].indices[0] = _ij12[0];
vinfos[4].indices[1] = _ij12[1];
vinfos[4].maxsolutions = _nj12;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j13;
vinfos[5].indices[0] = _ij13[0];
vinfos[5].indices[1] = _ij13[1];
vinfos[5].maxsolutions = _nj13;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j14;
vinfos[6].indices[0] = _ij14[0];
vinfos[6].indices[1] = _ij14[1];
vinfos[6].maxsolutions = _nj14;
vinfos[7].jointtype = 1;
vinfos[7].foffset = j15;
vinfos[7].indices[0] = _ij15[0];
vinfos[7].indices[1] = _ij15[1];
vinfos[7].maxsolutions = _nj15;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((IKabs(new_r20))+(IKabs(new_r21)));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j15array[1], cj15array[1], sj15array[1];
bool j15valid[1]={false};
_nj15 = 1;
if( IKabs(((-1.0)*new_r10)) < IKFAST_ATAN2_MAGTHRESH && IKabs(((-1.0)*new_r11)) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((-1.0)*new_r10))+IKsqr(((-1.0)*new_r11))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j15array[0]=IKatan2(((-1.0)*new_r10), ((-1.0)*new_r11));
sj15array[0]=IKsin(j15array[0]);
cj15array[0]=IKcos(j15array[0]);
if( j15array[0] > IKPI )
{
    j15array[0]-=IK2PI;
}
else if( j15array[0] < -IKPI )
{    j15array[0]+=IK2PI;
}
j15valid[0] = true;
for(int ij15 = 0; ij15 < 1; ++ij15)
{
if( !j15valid[ij15] )
{
    continue;
}
_ij15[0] = ij15; _ij15[1] = -1;
for(int iij15 = ij15+1; iij15 < 1; ++iij15)
{
if( j15valid[iij15] && IKabs(cj15array[ij15]-cj15array[iij15]) < IKFAST_SOLUTION_THRESH && IKabs(sj15array[ij15]-sj15array[iij15]) < IKFAST_SOLUTION_THRESH )
{
    j15valid[iij15]=false; _ij15[1] = iij15; break; 
}
}
j15 = j15array[ij15]; cj15 = cj15array[ij15]; sj15 = sj15array[ij15];
{
IkReal evalcond[6];
IkReal x373=IKsin(j15);
IkReal x374=IKcos(j15);
IkReal x375=((-1.0)*x374);
evalcond[0]=x373;
evalcond[1]=(new_r22*x373);
evalcond[2]=x375;
evalcond[3]=(new_r22*x375);
evalcond[4]=((((-1.0)*x373))+(((-1.0)*new_r10)));
evalcond[5]=((((-1.0)*x374))+(((-1.0)*new_r11)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(8);
vinfos[0].jointtype = 17;
vinfos[0].foffset = j5;
vinfos[0].indices[0] = _ij5[0];
vinfos[0].indices[1] = _ij5[1];
vinfos[0].maxsolutions = _nj5;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j9;
vinfos[1].indices[0] = _ij9[0];
vinfos[1].indices[1] = _ij9[1];
vinfos[1].maxsolutions = _nj9;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j10;
vinfos[2].indices[0] = _ij10[0];
vinfos[2].indices[1] = _ij10[1];
vinfos[2].maxsolutions = _nj10;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j11;
vinfos[3].indices[0] = _ij11[0];
vinfos[3].indices[1] = _ij11[1];
vinfos[3].maxsolutions = _nj11;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j12;
vinfos[4].indices[0] = _ij12[0];
vinfos[4].indices[1] = _ij12[1];
vinfos[4].maxsolutions = _nj12;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j13;
vinfos[5].indices[0] = _ij13[0];
vinfos[5].indices[1] = _ij13[1];
vinfos[5].maxsolutions = _nj13;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j14;
vinfos[6].indices[0] = _ij14[0];
vinfos[6].indices[1] = _ij14[1];
vinfos[6].maxsolutions = _nj14;
vinfos[7].jointtype = 1;
vinfos[7].foffset = j15;
vinfos[7].indices[0] = _ij15[0];
vinfos[7].indices[1] = _ij15[1];
vinfos[7].maxsolutions = _nj15;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
if( 1 )
{
bgotonextstatement=false;
continue; // branch miss [j15]

}
} while(0);
if( bgotonextstatement )
{
}
}
}
}
}
}
}

} else
{
{
IkReal j15array[1], cj15array[1], sj15array[1];
bool j15valid[1]={false};
_nj15 = 1;
CheckValue<IkReal> x376=IKPowWithIntegerCheck(cj14,-1);
if(!x376.valid){
continue;
}
CheckValue<IkReal> x377=IKPowWithIntegerCheck(sj14,-1);
if(!x377.valid){
continue;
}
if( IKabs((new_r01*(x376.value))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((-1.0)*new_r20*(x377.value))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr((new_r01*(x376.value)))+IKsqr(((-1.0)*new_r20*(x377.value)))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j15array[0]=IKatan2((new_r01*(x376.value)), ((-1.0)*new_r20*(x377.value)));
sj15array[0]=IKsin(j15array[0]);
cj15array[0]=IKcos(j15array[0]);
if( j15array[0] > IKPI )
{
    j15array[0]-=IK2PI;
}
else if( j15array[0] < -IKPI )
{    j15array[0]+=IK2PI;
}
j15valid[0] = true;
for(int ij15 = 0; ij15 < 1; ++ij15)
{
if( !j15valid[ij15] )
{
    continue;
}
_ij15[0] = ij15; _ij15[1] = -1;
for(int iij15 = ij15+1; iij15 < 1; ++iij15)
{
if( j15valid[iij15] && IKabs(cj15array[ij15]-cj15array[iij15]) < IKFAST_SOLUTION_THRESH && IKabs(sj15array[ij15]-sj15array[iij15]) < IKFAST_SOLUTION_THRESH )
{
    j15valid[iij15]=false; _ij15[1] = iij15; break; 
}
}
j15 = j15array[ij15]; cj15 = cj15array[ij15]; sj15 = sj15array[ij15];
{
IkReal evalcond[8];
IkReal x378=IKsin(j15);
IkReal x379=IKcos(j15);
IkReal x380=((1.0)*new_r00);
IkReal x381=((1.0)*sj14);
IkReal x382=((1.0)*new_r01);
IkReal x383=((1.0)*x379);
evalcond[0]=(((sj14*x379))+new_r20);
evalcond[1]=((((-1.0)*x378*x381))+new_r21);
evalcond[2]=((((-1.0)*x378))+(((-1.0)*new_r10)));
evalcond[3]=((((-1.0)*x383))+(((-1.0)*new_r11)));
evalcond[4]=((((-1.0)*x382))+((cj14*x378)));
evalcond[5]=((((-1.0)*cj14*x383))+(((-1.0)*x380)));
evalcond[6]=((((-1.0)*cj14*x382))+x378+(((-1.0)*new_r21*x381)));
evalcond[7]=((((-1.0)*cj14*x380))+(((-1.0)*new_r20*x381))+(((-1.0)*x383)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(8);
vinfos[0].jointtype = 17;
vinfos[0].foffset = j5;
vinfos[0].indices[0] = _ij5[0];
vinfos[0].indices[1] = _ij5[1];
vinfos[0].maxsolutions = _nj5;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j9;
vinfos[1].indices[0] = _ij9[0];
vinfos[1].indices[1] = _ij9[1];
vinfos[1].maxsolutions = _nj9;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j10;
vinfos[2].indices[0] = _ij10[0];
vinfos[2].indices[1] = _ij10[1];
vinfos[2].maxsolutions = _nj10;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j11;
vinfos[3].indices[0] = _ij11[0];
vinfos[3].indices[1] = _ij11[1];
vinfos[3].maxsolutions = _nj11;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j12;
vinfos[4].indices[0] = _ij12[0];
vinfos[4].indices[1] = _ij12[1];
vinfos[4].maxsolutions = _nj12;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j13;
vinfos[5].indices[0] = _ij13[0];
vinfos[5].indices[1] = _ij13[1];
vinfos[5].maxsolutions = _nj13;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j14;
vinfos[6].indices[0] = _ij14[0];
vinfos[6].indices[1] = _ij14[1];
vinfos[6].maxsolutions = _nj14;
vinfos[7].jointtype = 1;
vinfos[7].foffset = j15;
vinfos[7].indices[0] = _ij15[0];
vinfos[7].indices[1] = _ij15[1];
vinfos[7].maxsolutions = _nj15;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

} else
{
{
IkReal j15array[1], cj15array[1], sj15array[1];
bool j15valid[1]={false};
_nj15 = 1;
CheckValue<IkReal> x384=IKPowWithIntegerCheck(sj14,-1);
if(!x384.valid){
continue;
}
if( IKabs((new_r21*(x384.value))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((-1.0)*new_r11)) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr((new_r21*(x384.value)))+IKsqr(((-1.0)*new_r11))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j15array[0]=IKatan2((new_r21*(x384.value)), ((-1.0)*new_r11));
sj15array[0]=IKsin(j15array[0]);
cj15array[0]=IKcos(j15array[0]);
if( j15array[0] > IKPI )
{
    j15array[0]-=IK2PI;
}
else if( j15array[0] < -IKPI )
{    j15array[0]+=IK2PI;
}
j15valid[0] = true;
for(int ij15 = 0; ij15 < 1; ++ij15)
{
if( !j15valid[ij15] )
{
    continue;
}
_ij15[0] = ij15; _ij15[1] = -1;
for(int iij15 = ij15+1; iij15 < 1; ++iij15)
{
if( j15valid[iij15] && IKabs(cj15array[ij15]-cj15array[iij15]) < IKFAST_SOLUTION_THRESH && IKabs(sj15array[ij15]-sj15array[iij15]) < IKFAST_SOLUTION_THRESH )
{
    j15valid[iij15]=false; _ij15[1] = iij15; break; 
}
}
j15 = j15array[ij15]; cj15 = cj15array[ij15]; sj15 = sj15array[ij15];
{
IkReal evalcond[8];
IkReal x385=IKsin(j15);
IkReal x386=IKcos(j15);
IkReal x387=((1.0)*new_r00);
IkReal x388=((1.0)*sj14);
IkReal x389=((1.0)*new_r01);
IkReal x390=((1.0)*x386);
evalcond[0]=(((sj14*x386))+new_r20);
evalcond[1]=(new_r21+(((-1.0)*x385*x388)));
evalcond[2]=((((-1.0)*x385))+(((-1.0)*new_r10)));
evalcond[3]=((((-1.0)*x390))+(((-1.0)*new_r11)));
evalcond[4]=(((cj14*x385))+(((-1.0)*x389)));
evalcond[5]=((((-1.0)*x387))+(((-1.0)*cj14*x390)));
evalcond[6]=((((-1.0)*cj14*x389))+x385+(((-1.0)*new_r21*x388)));
evalcond[7]=((((-1.0)*x390))+(((-1.0)*cj14*x387))+(((-1.0)*new_r20*x388)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(8);
vinfos[0].jointtype = 17;
vinfos[0].foffset = j5;
vinfos[0].indices[0] = _ij5[0];
vinfos[0].indices[1] = _ij5[1];
vinfos[0].maxsolutions = _nj5;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j9;
vinfos[1].indices[0] = _ij9[0];
vinfos[1].indices[1] = _ij9[1];
vinfos[1].maxsolutions = _nj9;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j10;
vinfos[2].indices[0] = _ij10[0];
vinfos[2].indices[1] = _ij10[1];
vinfos[2].maxsolutions = _nj10;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j11;
vinfos[3].indices[0] = _ij11[0];
vinfos[3].indices[1] = _ij11[1];
vinfos[3].maxsolutions = _nj11;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j12;
vinfos[4].indices[0] = _ij12[0];
vinfos[4].indices[1] = _ij12[1];
vinfos[4].maxsolutions = _nj12;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j13;
vinfos[5].indices[0] = _ij13[0];
vinfos[5].indices[1] = _ij13[1];
vinfos[5].maxsolutions = _nj13;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j14;
vinfos[6].indices[0] = _ij14[0];
vinfos[6].indices[1] = _ij14[1];
vinfos[6].maxsolutions = _nj14;
vinfos[7].jointtype = 1;
vinfos[7].foffset = j15;
vinfos[7].indices[0] = _ij15[0];
vinfos[7].indices[1] = _ij15[1];
vinfos[7].maxsolutions = _nj15;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

} else
{
{
IkReal j15array[1], cj15array[1], sj15array[1];
bool j15valid[1]={false};
_nj15 = 1;
CheckValue<IkReal> x391=IKPowWithIntegerCheck(IKsign(sj14),-1);
if(!x391.valid){
continue;
}
CheckValue<IkReal> x392 = IKatan2WithCheck(IkReal(new_r21),IkReal(((-1.0)*new_r20)),IKFAST_ATAN2_MAGTHRESH);
if(!x392.valid){
continue;
}
j15array[0]=((-1.5707963267949)+(((1.5707963267949)*(x391.value)))+(x392.value));
sj15array[0]=IKsin(j15array[0]);
cj15array[0]=IKcos(j15array[0]);
if( j15array[0] > IKPI )
{
    j15array[0]-=IK2PI;
}
else if( j15array[0] < -IKPI )
{    j15array[0]+=IK2PI;
}
j15valid[0] = true;
for(int ij15 = 0; ij15 < 1; ++ij15)
{
if( !j15valid[ij15] )
{
    continue;
}
_ij15[0] = ij15; _ij15[1] = -1;
for(int iij15 = ij15+1; iij15 < 1; ++iij15)
{
if( j15valid[iij15] && IKabs(cj15array[ij15]-cj15array[iij15]) < IKFAST_SOLUTION_THRESH && IKabs(sj15array[ij15]-sj15array[iij15]) < IKFAST_SOLUTION_THRESH )
{
    j15valid[iij15]=false; _ij15[1] = iij15; break; 
}
}
j15 = j15array[ij15]; cj15 = cj15array[ij15]; sj15 = sj15array[ij15];
{
IkReal evalcond[8];
IkReal x393=IKsin(j15);
IkReal x394=IKcos(j15);
IkReal x395=((1.0)*new_r00);
IkReal x396=((1.0)*sj14);
IkReal x397=((1.0)*new_r01);
IkReal x398=((1.0)*x394);
evalcond[0]=(((sj14*x394))+new_r20);
evalcond[1]=(new_r21+(((-1.0)*x393*x396)));
evalcond[2]=((((-1.0)*x393))+(((-1.0)*new_r10)));
evalcond[3]=((((-1.0)*x398))+(((-1.0)*new_r11)));
evalcond[4]=((((-1.0)*x397))+((cj14*x393)));
evalcond[5]=((((-1.0)*x395))+(((-1.0)*cj14*x398)));
evalcond[6]=((((-1.0)*new_r21*x396))+x393+(((-1.0)*cj14*x397)));
evalcond[7]=((((-1.0)*x398))+(((-1.0)*cj14*x395))+(((-1.0)*new_r20*x396)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(8);
vinfos[0].jointtype = 17;
vinfos[0].foffset = j5;
vinfos[0].indices[0] = _ij5[0];
vinfos[0].indices[1] = _ij5[1];
vinfos[0].maxsolutions = _nj5;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j9;
vinfos[1].indices[0] = _ij9[0];
vinfos[1].indices[1] = _ij9[1];
vinfos[1].maxsolutions = _nj9;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j10;
vinfos[2].indices[0] = _ij10[0];
vinfos[2].indices[1] = _ij10[1];
vinfos[2].maxsolutions = _nj10;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j11;
vinfos[3].indices[0] = _ij11[0];
vinfos[3].indices[1] = _ij11[1];
vinfos[3].maxsolutions = _nj11;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j12;
vinfos[4].indices[0] = _ij12[0];
vinfos[4].indices[1] = _ij12[1];
vinfos[4].maxsolutions = _nj12;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j13;
vinfos[5].indices[0] = _ij13[0];
vinfos[5].indices[1] = _ij13[1];
vinfos[5].maxsolutions = _nj13;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j14;
vinfos[6].indices[0] = _ij14[0];
vinfos[6].indices[1] = _ij14[1];
vinfos[6].maxsolutions = _nj14;
vinfos[7].jointtype = 1;
vinfos[7].foffset = j15;
vinfos[7].indices[0] = _ij15[0];
vinfos[7].indices[1] = _ij15[1];
vinfos[7].maxsolutions = _nj15;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(j14))), 6.28318530717959)));
evalcond[1]=new_r20;
evalcond[2]=new_r02;
evalcond[3]=new_r12;
evalcond[4]=new_r21;
if( IKabs(evalcond[0]) < 0.0000050000000000  && IKabs(evalcond[1]) < 0.0000050000000000  && IKabs(evalcond[2]) < 0.0000050000000000  && IKabs(evalcond[3]) < 0.0000050000000000  && IKabs(evalcond[4]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j15array[1], cj15array[1], sj15array[1];
bool j15valid[1]={false};
_nj15 = 1;
IkReal x399=((1.0)*new_r01);
if( IKabs(((((-1.0)*cj13*x399))+(((-1.0)*new_r00*sj13)))) < IKFAST_ATAN2_MAGTHRESH && IKabs((((cj13*new_r00))+(((-1.0)*sj13*x399)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((((-1.0)*cj13*x399))+(((-1.0)*new_r00*sj13))))+IKsqr((((cj13*new_r00))+(((-1.0)*sj13*x399))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j15array[0]=IKatan2(((((-1.0)*cj13*x399))+(((-1.0)*new_r00*sj13))), (((cj13*new_r00))+(((-1.0)*sj13*x399))));
sj15array[0]=IKsin(j15array[0]);
cj15array[0]=IKcos(j15array[0]);
if( j15array[0] > IKPI )
{
    j15array[0]-=IK2PI;
}
else if( j15array[0] < -IKPI )
{    j15array[0]+=IK2PI;
}
j15valid[0] = true;
for(int ij15 = 0; ij15 < 1; ++ij15)
{
if( !j15valid[ij15] )
{
    continue;
}
_ij15[0] = ij15; _ij15[1] = -1;
for(int iij15 = ij15+1; iij15 < 1; ++iij15)
{
if( j15valid[iij15] && IKabs(cj15array[ij15]-cj15array[iij15]) < IKFAST_SOLUTION_THRESH && IKabs(sj15array[ij15]-sj15array[iij15]) < IKFAST_SOLUTION_THRESH )
{
    j15valid[iij15]=false; _ij15[1] = iij15; break; 
}
}
j15 = j15array[ij15]; cj15 = cj15array[ij15]; sj15 = sj15array[ij15];
{
IkReal evalcond[8];
IkReal x400=IKsin(j15);
IkReal x401=IKcos(j15);
IkReal x402=((1.0)*cj13);
IkReal x403=((1.0)*sj13);
IkReal x404=((1.0)*x401);
IkReal x405=(sj13*x400);
IkReal x406=(x401*x402);
evalcond[0]=(((cj13*new_r01))+x400+((new_r11*sj13)));
evalcond[1]=(((sj13*x401))+new_r01+((cj13*x400)));
evalcond[2]=(((cj13*new_r00))+((new_r10*sj13))+(((-1.0)*x404)));
evalcond[3]=(((cj13*new_r10))+(((-1.0)*new_r00*x403))+(((-1.0)*x400)));
evalcond[4]=(((cj13*new_r11))+(((-1.0)*new_r01*x403))+(((-1.0)*x404)));
evalcond[5]=(x405+new_r00+(((-1.0)*x406)));
evalcond[6]=(x405+new_r11+(((-1.0)*x406)));
evalcond[7]=((((-1.0)*x401*x403))+(((-1.0)*x400*x402))+new_r10);
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(8);
vinfos[0].jointtype = 17;
vinfos[0].foffset = j5;
vinfos[0].indices[0] = _ij5[0];
vinfos[0].indices[1] = _ij5[1];
vinfos[0].maxsolutions = _nj5;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j9;
vinfos[1].indices[0] = _ij9[0];
vinfos[1].indices[1] = _ij9[1];
vinfos[1].maxsolutions = _nj9;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j10;
vinfos[2].indices[0] = _ij10[0];
vinfos[2].indices[1] = _ij10[1];
vinfos[2].maxsolutions = _nj10;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j11;
vinfos[3].indices[0] = _ij11[0];
vinfos[3].indices[1] = _ij11[1];
vinfos[3].maxsolutions = _nj11;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j12;
vinfos[4].indices[0] = _ij12[0];
vinfos[4].indices[1] = _ij12[1];
vinfos[4].maxsolutions = _nj12;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j13;
vinfos[5].indices[0] = _ij13[0];
vinfos[5].indices[1] = _ij13[1];
vinfos[5].maxsolutions = _nj13;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j14;
vinfos[6].indices[0] = _ij14[0];
vinfos[6].indices[1] = _ij14[1];
vinfos[6].maxsolutions = _nj14;
vinfos[7].jointtype = 1;
vinfos[7].foffset = j15;
vinfos[7].indices[0] = _ij15[0];
vinfos[7].indices[1] = _ij15[1];
vinfos[7].maxsolutions = _nj15;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((-3.14159265358979)+j14)))), 6.28318530717959)));
evalcond[1]=new_r20;
evalcond[2]=new_r02;
evalcond[3]=new_r12;
evalcond[4]=new_r21;
if( IKabs(evalcond[0]) < 0.0000050000000000  && IKabs(evalcond[1]) < 0.0000050000000000  && IKabs(evalcond[2]) < 0.0000050000000000  && IKabs(evalcond[3]) < 0.0000050000000000  && IKabs(evalcond[4]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j15array[1], cj15array[1], sj15array[1];
bool j15valid[1]={false};
_nj15 = 1;
IkReal x407=((1.0)*new_r00);
if( IKabs((((cj13*new_r01))+(((-1.0)*sj13*x407)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((((-1.0)*new_r01*sj13))+(((-1.0)*cj13*x407)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr((((cj13*new_r01))+(((-1.0)*sj13*x407))))+IKsqr(((((-1.0)*new_r01*sj13))+(((-1.0)*cj13*x407))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j15array[0]=IKatan2((((cj13*new_r01))+(((-1.0)*sj13*x407))), ((((-1.0)*new_r01*sj13))+(((-1.0)*cj13*x407))));
sj15array[0]=IKsin(j15array[0]);
cj15array[0]=IKcos(j15array[0]);
if( j15array[0] > IKPI )
{
    j15array[0]-=IK2PI;
}
else if( j15array[0] < -IKPI )
{    j15array[0]+=IK2PI;
}
j15valid[0] = true;
for(int ij15 = 0; ij15 < 1; ++ij15)
{
if( !j15valid[ij15] )
{
    continue;
}
_ij15[0] = ij15; _ij15[1] = -1;
for(int iij15 = ij15+1; iij15 < 1; ++iij15)
{
if( j15valid[iij15] && IKabs(cj15array[ij15]-cj15array[iij15]) < IKFAST_SOLUTION_THRESH && IKabs(sj15array[ij15]-sj15array[iij15]) < IKFAST_SOLUTION_THRESH )
{
    j15valid[iij15]=false; _ij15[1] = iij15; break; 
}
}
j15 = j15array[ij15]; cj15 = cj15array[ij15]; sj15 = sj15array[ij15];
{
IkReal evalcond[8];
IkReal x408=IKsin(j15);
IkReal x409=IKcos(j15);
IkReal x410=((1.0)*cj13);
IkReal x411=((1.0)*sj13);
IkReal x412=((1.0)*x408);
IkReal x413=(sj13*x409);
IkReal x414=(x408*x410);
evalcond[0]=(((cj13*new_r00))+x409+((new_r10*sj13)));
evalcond[1]=(((cj13*new_r01))+(((-1.0)*x412))+((new_r11*sj13)));
evalcond[2]=(((sj13*x408))+new_r00+((cj13*x409)));
evalcond[3]=(((cj13*new_r10))+(((-1.0)*new_r00*x411))+(((-1.0)*x412)));
evalcond[4]=(((cj13*new_r11))+(((-1.0)*x409))+(((-1.0)*new_r01*x411)));
evalcond[5]=(x413+new_r01+(((-1.0)*x414)));
evalcond[6]=(x413+new_r10+(((-1.0)*x414)));
evalcond[7]=(new_r11+(((-1.0)*x408*x411))+(((-1.0)*x409*x410)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(8);
vinfos[0].jointtype = 17;
vinfos[0].foffset = j5;
vinfos[0].indices[0] = _ij5[0];
vinfos[0].indices[1] = _ij5[1];
vinfos[0].maxsolutions = _nj5;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j9;
vinfos[1].indices[0] = _ij9[0];
vinfos[1].indices[1] = _ij9[1];
vinfos[1].maxsolutions = _nj9;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j10;
vinfos[2].indices[0] = _ij10[0];
vinfos[2].indices[1] = _ij10[1];
vinfos[2].maxsolutions = _nj10;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j11;
vinfos[3].indices[0] = _ij11[0];
vinfos[3].indices[1] = _ij11[1];
vinfos[3].maxsolutions = _nj11;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j12;
vinfos[4].indices[0] = _ij12[0];
vinfos[4].indices[1] = _ij12[1];
vinfos[4].maxsolutions = _nj12;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j13;
vinfos[5].indices[0] = _ij13[0];
vinfos[5].indices[1] = _ij13[1];
vinfos[5].maxsolutions = _nj13;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j14;
vinfos[6].indices[0] = _ij14[0];
vinfos[6].indices[1] = _ij14[1];
vinfos[6].maxsolutions = _nj14;
vinfos[7].jointtype = 1;
vinfos[7].foffset = j15;
vinfos[7].indices[0] = _ij15[0];
vinfos[7].indices[1] = _ij15[1];
vinfos[7].maxsolutions = _nj15;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((IKabs(new_r20))+(IKabs(new_r21)));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j15eval[1];
new_r21=0;
new_r20=0;
new_r02=0;
new_r12=0;
j15eval[0]=1.0;
if( IKabs(j15eval[0]) < 0.0000000100000000  )
{
continue; // no branches [j15]

} else
{
IkReal op[2+1], zeror[2];
int numroots;
op[0]=1.0;
op[1]=0;
op[2]=-1.0;
polyroots2(op,zeror,numroots);
IkReal j15array[2], cj15array[2], sj15array[2], tempj15array[1];
int numsolutions = 0;
for(int ij15 = 0; ij15 < numroots; ++ij15)
{
IkReal htj15 = zeror[ij15];
tempj15array[0]=((2.0)*(atan(htj15)));
for(int kj15 = 0; kj15 < 1; ++kj15)
{
j15array[numsolutions] = tempj15array[kj15];
if( j15array[numsolutions] > IKPI )
{
    j15array[numsolutions]-=IK2PI;
}
else if( j15array[numsolutions] < -IKPI )
{
    j15array[numsolutions]+=IK2PI;
}
sj15array[numsolutions] = IKsin(j15array[numsolutions]);
cj15array[numsolutions] = IKcos(j15array[numsolutions]);
numsolutions++;
}
}
bool j15valid[2]={true,true};
_nj15 = 2;
for(int ij15 = 0; ij15 < numsolutions; ++ij15)
    {
if( !j15valid[ij15] )
{
    continue;
}
    j15 = j15array[ij15]; cj15 = cj15array[ij15]; sj15 = sj15array[ij15];
htj15 = IKtan(j15/2);

_ij15[0] = ij15; _ij15[1] = -1;
for(int iij15 = ij15+1; iij15 < numsolutions; ++iij15)
{
if( j15valid[iij15] && IKabs(cj15array[ij15]-cj15array[iij15]) < IKFAST_SOLUTION_THRESH && IKabs(sj15array[ij15]-sj15array[iij15]) < IKFAST_SOLUTION_THRESH )
{
    j15valid[iij15]=false; _ij15[1] = iij15; break; 
}
}
{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(8);
vinfos[0].jointtype = 17;
vinfos[0].foffset = j5;
vinfos[0].indices[0] = _ij5[0];
vinfos[0].indices[1] = _ij5[1];
vinfos[0].maxsolutions = _nj5;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j9;
vinfos[1].indices[0] = _ij9[0];
vinfos[1].indices[1] = _ij9[1];
vinfos[1].maxsolutions = _nj9;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j10;
vinfos[2].indices[0] = _ij10[0];
vinfos[2].indices[1] = _ij10[1];
vinfos[2].maxsolutions = _nj10;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j11;
vinfos[3].indices[0] = _ij11[0];
vinfos[3].indices[1] = _ij11[1];
vinfos[3].maxsolutions = _nj11;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j12;
vinfos[4].indices[0] = _ij12[0];
vinfos[4].indices[1] = _ij12[1];
vinfos[4].maxsolutions = _nj12;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j13;
vinfos[5].indices[0] = _ij13[0];
vinfos[5].indices[1] = _ij13[1];
vinfos[5].maxsolutions = _nj13;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j14;
vinfos[6].indices[0] = _ij14[0];
vinfos[6].indices[1] = _ij14[1];
vinfos[6].maxsolutions = _nj14;
vinfos[7].jointtype = 1;
vinfos[7].foffset = j15;
vinfos[7].indices[0] = _ij15[0];
vinfos[7].indices[1] = _ij15[1];
vinfos[7].maxsolutions = _nj15;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
    }

}

}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
if( 1 )
{
bgotonextstatement=false;
continue; // branch miss [j15]

}
} while(0);
if( bgotonextstatement )
{
}
}
}
}
}
}
}
}
}

} else
{
{
IkReal j15array[1], cj15array[1], sj15array[1];
bool j15valid[1]={false};
_nj15 = 1;
CheckValue<IkReal> x416=IKPowWithIntegerCheck(sj14,-1);
if(!x416.valid){
continue;
}
IkReal x415=x416.value;
CheckValue<IkReal> x417=IKPowWithIntegerCheck(cj14,-1);
if(!x417.valid){
continue;
}
CheckValue<IkReal> x418=IKPowWithIntegerCheck(sj13,-1);
if(!x418.valid){
continue;
}
if( IKabs((x415*(x417.value)*(x418.value)*(((((-1.0)*cj13*new_r20))+(((-1.0)*new_r11*sj14)))))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((-1.0)*new_r20*x415)) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr((x415*(x417.value)*(x418.value)*(((((-1.0)*cj13*new_r20))+(((-1.0)*new_r11*sj14))))))+IKsqr(((-1.0)*new_r20*x415))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j15array[0]=IKatan2((x415*(x417.value)*(x418.value)*(((((-1.0)*cj13*new_r20))+(((-1.0)*new_r11*sj14))))), ((-1.0)*new_r20*x415));
sj15array[0]=IKsin(j15array[0]);
cj15array[0]=IKcos(j15array[0]);
if( j15array[0] > IKPI )
{
    j15array[0]-=IK2PI;
}
else if( j15array[0] < -IKPI )
{    j15array[0]+=IK2PI;
}
j15valid[0] = true;
for(int ij15 = 0; ij15 < 1; ++ij15)
{
if( !j15valid[ij15] )
{
    continue;
}
_ij15[0] = ij15; _ij15[1] = -1;
for(int iij15 = ij15+1; iij15 < 1; ++iij15)
{
if( j15valid[iij15] && IKabs(cj15array[ij15]-cj15array[iij15]) < IKFAST_SOLUTION_THRESH && IKabs(sj15array[ij15]-sj15array[iij15]) < IKFAST_SOLUTION_THRESH )
{
    j15valid[iij15]=false; _ij15[1] = iij15; break; 
}
}
j15 = j15array[ij15]; cj15 = cj15array[ij15]; sj15 = sj15array[ij15];
{
IkReal evalcond[12];
IkReal x419=IKsin(j15);
IkReal x420=IKcos(j15);
IkReal x421=(cj13*cj14);
IkReal x422=((1.0)*sj14);
IkReal x423=(cj14*sj13);
IkReal x424=((1.0)*sj13);
IkReal x425=((1.0)*x420);
IkReal x426=((1.0)*x419);
evalcond[0]=(((sj14*x420))+new_r20);
evalcond[1]=((((-1.0)*x419*x422))+new_r21);
evalcond[2]=(((cj13*new_r01))+((cj14*x419))+((new_r11*sj13)));
evalcond[3]=(((cj13*new_r10))+(((-1.0)*new_r00*x424))+(((-1.0)*x426)));
evalcond[4]=(((cj13*new_r11))+(((-1.0)*x425))+(((-1.0)*new_r01*x424)));
evalcond[5]=(((sj13*x420))+((x419*x421))+new_r01);
evalcond[6]=((((-1.0)*cj14*x425))+((cj13*new_r00))+((new_r10*sj13)));
evalcond[7]=((((-1.0)*x421*x425))+((sj13*x419))+new_r00);
evalcond[8]=(((x419*x423))+(((-1.0)*cj13*x425))+new_r11);
evalcond[9]=((((-1.0)*cj13*x426))+new_r10+(((-1.0)*x423*x425)));
evalcond[10]=(((new_r11*x423))+x419+(((-1.0)*new_r21*x422))+((new_r01*x421)));
evalcond[11]=((((-1.0)*x425))+((new_r10*x423))+(((-1.0)*new_r20*x422))+((new_r00*x421)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[8]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[9]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[10]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[11]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(8);
vinfos[0].jointtype = 17;
vinfos[0].foffset = j5;
vinfos[0].indices[0] = _ij5[0];
vinfos[0].indices[1] = _ij5[1];
vinfos[0].maxsolutions = _nj5;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j9;
vinfos[1].indices[0] = _ij9[0];
vinfos[1].indices[1] = _ij9[1];
vinfos[1].maxsolutions = _nj9;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j10;
vinfos[2].indices[0] = _ij10[0];
vinfos[2].indices[1] = _ij10[1];
vinfos[2].maxsolutions = _nj10;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j11;
vinfos[3].indices[0] = _ij11[0];
vinfos[3].indices[1] = _ij11[1];
vinfos[3].maxsolutions = _nj11;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j12;
vinfos[4].indices[0] = _ij12[0];
vinfos[4].indices[1] = _ij12[1];
vinfos[4].maxsolutions = _nj12;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j13;
vinfos[5].indices[0] = _ij13[0];
vinfos[5].indices[1] = _ij13[1];
vinfos[5].maxsolutions = _nj13;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j14;
vinfos[6].indices[0] = _ij14[0];
vinfos[6].indices[1] = _ij14[1];
vinfos[6].maxsolutions = _nj14;
vinfos[7].jointtype = 1;
vinfos[7].foffset = j15;
vinfos[7].indices[0] = _ij15[0];
vinfos[7].indices[1] = _ij15[1];
vinfos[7].maxsolutions = _nj15;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

} else
{
{
IkReal j15array[1], cj15array[1], sj15array[1];
bool j15valid[1]={false};
_nj15 = 1;
CheckValue<IkReal> x428=IKPowWithIntegerCheck(sj14,-1);
if(!x428.valid){
continue;
}
IkReal x427=x428.value;
CheckValue<IkReal> x429=IKPowWithIntegerCheck(sj13,-1);
if(!x429.valid){
continue;
}
if( IKabs((new_r21*x427)) < IKFAST_ATAN2_MAGTHRESH && IKabs((x427*(x429.value)*(((((-1.0)*cj13*cj14*new_r21))+(((-1.0)*new_r01*sj14)))))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr((new_r21*x427))+IKsqr((x427*(x429.value)*(((((-1.0)*cj13*cj14*new_r21))+(((-1.0)*new_r01*sj14))))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j15array[0]=IKatan2((new_r21*x427), (x427*(x429.value)*(((((-1.0)*cj13*cj14*new_r21))+(((-1.0)*new_r01*sj14))))));
sj15array[0]=IKsin(j15array[0]);
cj15array[0]=IKcos(j15array[0]);
if( j15array[0] > IKPI )
{
    j15array[0]-=IK2PI;
}
else if( j15array[0] < -IKPI )
{    j15array[0]+=IK2PI;
}
j15valid[0] = true;
for(int ij15 = 0; ij15 < 1; ++ij15)
{
if( !j15valid[ij15] )
{
    continue;
}
_ij15[0] = ij15; _ij15[1] = -1;
for(int iij15 = ij15+1; iij15 < 1; ++iij15)
{
if( j15valid[iij15] && IKabs(cj15array[ij15]-cj15array[iij15]) < IKFAST_SOLUTION_THRESH && IKabs(sj15array[ij15]-sj15array[iij15]) < IKFAST_SOLUTION_THRESH )
{
    j15valid[iij15]=false; _ij15[1] = iij15; break; 
}
}
j15 = j15array[ij15]; cj15 = cj15array[ij15]; sj15 = sj15array[ij15];
{
IkReal evalcond[12];
IkReal x430=IKsin(j15);
IkReal x431=IKcos(j15);
IkReal x432=(cj13*cj14);
IkReal x433=((1.0)*sj14);
IkReal x434=(cj14*sj13);
IkReal x435=((1.0)*sj13);
IkReal x436=((1.0)*x431);
IkReal x437=((1.0)*x430);
evalcond[0]=(((sj14*x431))+new_r20);
evalcond[1]=((((-1.0)*x430*x433))+new_r21);
evalcond[2]=(((cj13*new_r01))+((new_r11*sj13))+((cj14*x430)));
evalcond[3]=((((-1.0)*new_r00*x435))+(((-1.0)*x437))+((cj13*new_r10)));
evalcond[4]=((((-1.0)*x436))+((cj13*new_r11))+(((-1.0)*new_r01*x435)));
evalcond[5]=(((sj13*x431))+((x430*x432))+new_r01);
evalcond[6]=(((cj13*new_r00))+(((-1.0)*cj14*x436))+((new_r10*sj13)));
evalcond[7]=((((-1.0)*x432*x436))+((sj13*x430))+new_r00);
evalcond[8]=((((-1.0)*cj13*x436))+((x430*x434))+new_r11);
evalcond[9]=((((-1.0)*x434*x436))+(((-1.0)*cj13*x437))+new_r10);
evalcond[10]=(((new_r01*x432))+((new_r11*x434))+x430+(((-1.0)*new_r21*x433)));
evalcond[11]=((((-1.0)*x436))+((new_r00*x432))+((new_r10*x434))+(((-1.0)*new_r20*x433)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[8]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[9]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[10]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[11]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(8);
vinfos[0].jointtype = 17;
vinfos[0].foffset = j5;
vinfos[0].indices[0] = _ij5[0];
vinfos[0].indices[1] = _ij5[1];
vinfos[0].maxsolutions = _nj5;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j9;
vinfos[1].indices[0] = _ij9[0];
vinfos[1].indices[1] = _ij9[1];
vinfos[1].maxsolutions = _nj9;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j10;
vinfos[2].indices[0] = _ij10[0];
vinfos[2].indices[1] = _ij10[1];
vinfos[2].maxsolutions = _nj10;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j11;
vinfos[3].indices[0] = _ij11[0];
vinfos[3].indices[1] = _ij11[1];
vinfos[3].maxsolutions = _nj11;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j12;
vinfos[4].indices[0] = _ij12[0];
vinfos[4].indices[1] = _ij12[1];
vinfos[4].maxsolutions = _nj12;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j13;
vinfos[5].indices[0] = _ij13[0];
vinfos[5].indices[1] = _ij13[1];
vinfos[5].maxsolutions = _nj13;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j14;
vinfos[6].indices[0] = _ij14[0];
vinfos[6].indices[1] = _ij14[1];
vinfos[6].maxsolutions = _nj14;
vinfos[7].jointtype = 1;
vinfos[7].foffset = j15;
vinfos[7].indices[0] = _ij15[0];
vinfos[7].indices[1] = _ij15[1];
vinfos[7].maxsolutions = _nj15;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

} else
{
{
IkReal j15array[1], cj15array[1], sj15array[1];
bool j15valid[1]={false};
_nj15 = 1;
CheckValue<IkReal> x438=IKPowWithIntegerCheck(IKsign(sj14),-1);
if(!x438.valid){
continue;
}
CheckValue<IkReal> x439 = IKatan2WithCheck(IkReal(new_r21),IkReal(((-1.0)*new_r20)),IKFAST_ATAN2_MAGTHRESH);
if(!x439.valid){
continue;
}
j15array[0]=((-1.5707963267949)+(((1.5707963267949)*(x438.value)))+(x439.value));
sj15array[0]=IKsin(j15array[0]);
cj15array[0]=IKcos(j15array[0]);
if( j15array[0] > IKPI )
{
    j15array[0]-=IK2PI;
}
else if( j15array[0] < -IKPI )
{    j15array[0]+=IK2PI;
}
j15valid[0] = true;
for(int ij15 = 0; ij15 < 1; ++ij15)
{
if( !j15valid[ij15] )
{
    continue;
}
_ij15[0] = ij15; _ij15[1] = -1;
for(int iij15 = ij15+1; iij15 < 1; ++iij15)
{
if( j15valid[iij15] && IKabs(cj15array[ij15]-cj15array[iij15]) < IKFAST_SOLUTION_THRESH && IKabs(sj15array[ij15]-sj15array[iij15]) < IKFAST_SOLUTION_THRESH )
{
    j15valid[iij15]=false; _ij15[1] = iij15; break; 
}
}
j15 = j15array[ij15]; cj15 = cj15array[ij15]; sj15 = sj15array[ij15];
{
IkReal evalcond[12];
IkReal x440=IKsin(j15);
IkReal x441=IKcos(j15);
IkReal x442=(cj13*cj14);
IkReal x443=((1.0)*sj14);
IkReal x444=(cj14*sj13);
IkReal x445=((1.0)*sj13);
IkReal x446=((1.0)*x441);
IkReal x447=((1.0)*x440);
evalcond[0]=(((sj14*x441))+new_r20);
evalcond[1]=(new_r21+(((-1.0)*x440*x443)));
evalcond[2]=(((cj14*x440))+((cj13*new_r01))+((new_r11*sj13)));
evalcond[3]=((((-1.0)*x447))+(((-1.0)*new_r00*x445))+((cj13*new_r10)));
evalcond[4]=((((-1.0)*x446))+((cj13*new_r11))+(((-1.0)*new_r01*x445)));
evalcond[5]=(((sj13*x441))+((x440*x442))+new_r01);
evalcond[6]=(((cj13*new_r00))+(((-1.0)*cj14*x446))+((new_r10*sj13)));
evalcond[7]=(((sj13*x440))+new_r00+(((-1.0)*x442*x446)));
evalcond[8]=(((x440*x444))+(((-1.0)*cj13*x446))+new_r11);
evalcond[9]=((((-1.0)*x444*x446))+(((-1.0)*cj13*x447))+new_r10);
evalcond[10]=(((new_r01*x442))+((new_r11*x444))+x440+(((-1.0)*new_r21*x443)));
evalcond[11]=(((new_r00*x442))+(((-1.0)*x446))+((new_r10*x444))+(((-1.0)*new_r20*x443)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[8]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[9]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[10]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[11]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(8);
vinfos[0].jointtype = 17;
vinfos[0].foffset = j5;
vinfos[0].indices[0] = _ij5[0];
vinfos[0].indices[1] = _ij5[1];
vinfos[0].maxsolutions = _nj5;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j9;
vinfos[1].indices[0] = _ij9[0];
vinfos[1].indices[1] = _ij9[1];
vinfos[1].maxsolutions = _nj9;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j10;
vinfos[2].indices[0] = _ij10[0];
vinfos[2].indices[1] = _ij10[1];
vinfos[2].maxsolutions = _nj10;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j11;
vinfos[3].indices[0] = _ij11[0];
vinfos[3].indices[1] = _ij11[1];
vinfos[3].maxsolutions = _nj11;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j12;
vinfos[4].indices[0] = _ij12[0];
vinfos[4].indices[1] = _ij12[1];
vinfos[4].maxsolutions = _nj12;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j13;
vinfos[5].indices[0] = _ij13[0];
vinfos[5].indices[1] = _ij13[1];
vinfos[5].maxsolutions = _nj13;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j14;
vinfos[6].indices[0] = _ij14[0];
vinfos[6].indices[1] = _ij14[1];
vinfos[6].maxsolutions = _nj14;
vinfos[7].jointtype = 1;
vinfos[7].foffset = j15;
vinfos[7].indices[0] = _ij15[0];
vinfos[7].indices[1] = _ij15[1];
vinfos[7].maxsolutions = _nj15;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}
}
}

}

}

} else
{
{
IkReal j15array[1], cj15array[1], sj15array[1];
bool j15valid[1]={false};
_nj15 = 1;
CheckValue<IkReal> x448=IKPowWithIntegerCheck(IKsign(sj14),-1);
if(!x448.valid){
continue;
}
CheckValue<IkReal> x449 = IKatan2WithCheck(IkReal(new_r21),IkReal(((-1.0)*new_r20)),IKFAST_ATAN2_MAGTHRESH);
if(!x449.valid){
continue;
}
j15array[0]=((-1.5707963267949)+(((1.5707963267949)*(x448.value)))+(x449.value));
sj15array[0]=IKsin(j15array[0]);
cj15array[0]=IKcos(j15array[0]);
if( j15array[0] > IKPI )
{
    j15array[0]-=IK2PI;
}
else if( j15array[0] < -IKPI )
{    j15array[0]+=IK2PI;
}
j15valid[0] = true;
for(int ij15 = 0; ij15 < 1; ++ij15)
{
if( !j15valid[ij15] )
{
    continue;
}
_ij15[0] = ij15; _ij15[1] = -1;
for(int iij15 = ij15+1; iij15 < 1; ++iij15)
{
if( j15valid[iij15] && IKabs(cj15array[ij15]-cj15array[iij15]) < IKFAST_SOLUTION_THRESH && IKabs(sj15array[ij15]-sj15array[iij15]) < IKFAST_SOLUTION_THRESH )
{
    j15valid[iij15]=false; _ij15[1] = iij15; break; 
}
}
j15 = j15array[ij15]; cj15 = cj15array[ij15]; sj15 = sj15array[ij15];
{
IkReal evalcond[2];
evalcond[0]=(((sj14*(IKcos(j15))))+new_r20);
evalcond[1]=((((-1.0)*sj14*(IKsin(j15))))+new_r21);
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
IkReal j13eval[3];
j13eval[0]=sj14;
j13eval[1]=IKsign(sj14);
j13eval[2]=((IKabs(new_r12))+(IKabs(new_r02)));
if( IKabs(j13eval[0]) < 0.0000010000000000  || IKabs(j13eval[1]) < 0.0000010000000000  || IKabs(j13eval[2]) < 0.0000010000000000  )
{
{
IkReal j13eval[2];
j13eval[0]=cj15;
j13eval[1]=sj14;
if( IKabs(j13eval[0]) < 0.0000010000000000  || IKabs(j13eval[1]) < 0.0000010000000000  )
{
{
IkReal evalcond[5];
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((-1.5707963267949)+j15)))), 6.28318530717959)));
evalcond[1]=new_r20;
if( IKabs(evalcond[0]) < 0.0000050000000000  && IKabs(evalcond[1]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j13array[1], cj13array[1], sj13array[1];
bool j13valid[1]={false};
_nj13 = 1;
if( IKabs(((-1.0)*new_r00)) < IKFAST_ATAN2_MAGTHRESH && IKabs(new_r10) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((-1.0)*new_r00))+IKsqr(new_r10)-1) <= IKFAST_SINCOS_THRESH )
    continue;
j13array[0]=IKatan2(((-1.0)*new_r00), new_r10);
sj13array[0]=IKsin(j13array[0]);
cj13array[0]=IKcos(j13array[0]);
if( j13array[0] > IKPI )
{
    j13array[0]-=IK2PI;
}
else if( j13array[0] < -IKPI )
{    j13array[0]+=IK2PI;
}
j13valid[0] = true;
for(int ij13 = 0; ij13 < 1; ++ij13)
{
if( !j13valid[ij13] )
{
    continue;
}
_ij13[0] = ij13; _ij13[1] = -1;
for(int iij13 = ij13+1; iij13 < 1; ++iij13)
{
if( j13valid[iij13] && IKabs(cj13array[ij13]-cj13array[iij13]) < IKFAST_SOLUTION_THRESH && IKabs(sj13array[ij13]-sj13array[iij13]) < IKFAST_SOLUTION_THRESH )
{
    j13valid[iij13]=false; _ij13[1] = iij13; break; 
}
}
j13 = j13array[ij13]; cj13 = cj13array[ij13]; sj13 = sj13array[ij13];
{
IkReal evalcond[18];
IkReal x450=IKsin(j13);
IkReal x451=IKcos(j13);
IkReal x452=((1.0)*sj14);
IkReal x453=(new_r01*x451);
IkReal x454=(new_r00*x451);
IkReal x455=(new_r11*x450);
IkReal x456=(new_r22*x450);
IkReal x457=(sj14*x451);
IkReal x458=((1.0)*x450);
IkReal x459=(new_r22*x451);
IkReal x460=(new_r10*x450);
IkReal x461=(new_r12*x450);
evalcond[0]=(x450+new_r00);
evalcond[1]=(x459+new_r01);
evalcond[2]=(x456+new_r11);
evalcond[3]=((((-1.0)*x451))+new_r10);
evalcond[4]=((((-1.0)*x451*x452))+new_r02);
evalcond[5]=((((-1.0)*x450*x452))+new_r12);
evalcond[6]=(x454+x460);
evalcond[7]=(((new_r12*x451))+(((-1.0)*new_r02*x458)));
evalcond[8]=(((new_r11*x451))+(((-1.0)*new_r01*x458)));
evalcond[9]=(x455+x453+new_r22);
evalcond[10]=((-1.0)+((new_r10*x451))+(((-1.0)*new_r00*x458)));
evalcond[11]=(((sj14*x454))+((sj14*x460)));
evalcond[12]=(((new_r10*x456))+((new_r22*x454)));
evalcond[13]=((((-1.0)*x452))+x461+((new_r02*x451)));
evalcond[14]=(((sj14*x455))+((sj14*x453))+((cj14*new_r21)));
evalcond[15]=((-1.0)+(new_r22*new_r22)+((sj14*x461))+((new_r02*x457)));
evalcond[16]=(((new_r12*x456))+(((-1.0)*new_r22*x452))+((new_r02*x459)));
evalcond[17]=((1.0)+(((-1.0)*sj14*x452))+((new_r22*x453))+((new_r22*x455)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[8]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[9]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[10]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[11]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[12]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[13]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[14]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[15]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[16]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[17]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(8);
vinfos[0].jointtype = 17;
vinfos[0].foffset = j5;
vinfos[0].indices[0] = _ij5[0];
vinfos[0].indices[1] = _ij5[1];
vinfos[0].maxsolutions = _nj5;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j9;
vinfos[1].indices[0] = _ij9[0];
vinfos[1].indices[1] = _ij9[1];
vinfos[1].maxsolutions = _nj9;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j10;
vinfos[2].indices[0] = _ij10[0];
vinfos[2].indices[1] = _ij10[1];
vinfos[2].maxsolutions = _nj10;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j11;
vinfos[3].indices[0] = _ij11[0];
vinfos[3].indices[1] = _ij11[1];
vinfos[3].maxsolutions = _nj11;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j12;
vinfos[4].indices[0] = _ij12[0];
vinfos[4].indices[1] = _ij12[1];
vinfos[4].maxsolutions = _nj12;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j13;
vinfos[5].indices[0] = _ij13[0];
vinfos[5].indices[1] = _ij13[1];
vinfos[5].maxsolutions = _nj13;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j14;
vinfos[6].indices[0] = _ij14[0];
vinfos[6].indices[1] = _ij14[1];
vinfos[6].maxsolutions = _nj14;
vinfos[7].jointtype = 1;
vinfos[7].foffset = j15;
vinfos[7].indices[0] = _ij15[0];
vinfos[7].indices[1] = _ij15[1];
vinfos[7].maxsolutions = _nj15;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((1.5707963267949)+j15)))), 6.28318530717959)));
evalcond[1]=new_r20;
if( IKabs(evalcond[0]) < 0.0000050000000000  && IKabs(evalcond[1]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j13array[1], cj13array[1], sj13array[1];
bool j13valid[1]={false};
_nj13 = 1;
if( IKabs(new_r00) < IKFAST_ATAN2_MAGTHRESH && IKabs(((-1.0)*new_r10)) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(new_r00)+IKsqr(((-1.0)*new_r10))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j13array[0]=IKatan2(new_r00, ((-1.0)*new_r10));
sj13array[0]=IKsin(j13array[0]);
cj13array[0]=IKcos(j13array[0]);
if( j13array[0] > IKPI )
{
    j13array[0]-=IK2PI;
}
else if( j13array[0] < -IKPI )
{    j13array[0]+=IK2PI;
}
j13valid[0] = true;
for(int ij13 = 0; ij13 < 1; ++ij13)
{
if( !j13valid[ij13] )
{
    continue;
}
_ij13[0] = ij13; _ij13[1] = -1;
for(int iij13 = ij13+1; iij13 < 1; ++iij13)
{
if( j13valid[iij13] && IKabs(cj13array[ij13]-cj13array[iij13]) < IKFAST_SOLUTION_THRESH && IKabs(sj13array[ij13]-sj13array[iij13]) < IKFAST_SOLUTION_THRESH )
{
    j13valid[iij13]=false; _ij13[1] = iij13; break; 
}
}
j13 = j13array[ij13]; cj13 = cj13array[ij13]; sj13 = sj13array[ij13];
{
IkReal evalcond[18];
IkReal x462=IKcos(j13);
IkReal x463=IKsin(j13);
IkReal x464=((1.0)*sj14);
IkReal x465=((1.0)*new_r22);
IkReal x466=(new_r01*x462);
IkReal x467=(new_r00*x462);
IkReal x468=(new_r11*x463);
IkReal x469=(new_r22*x463);
IkReal x470=(sj14*x462);
IkReal x471=((1.0)*x463);
IkReal x472=(new_r10*x463);
IkReal x473=(new_r12*x463);
IkReal x474=(new_r02*x462);
evalcond[0]=(x462+new_r10);
evalcond[1]=((((-1.0)*x471))+new_r00);
evalcond[2]=((((-1.0)*x462*x464))+new_r02);
evalcond[3]=((((-1.0)*x463*x464))+new_r12);
evalcond[4]=((((-1.0)*x462*x465))+new_r01);
evalcond[5]=((((-1.0)*x463*x465))+new_r11);
evalcond[6]=(x467+x472);
evalcond[7]=(((new_r12*x462))+(((-1.0)*new_r02*x471)));
evalcond[8]=(((new_r11*x462))+(((-1.0)*new_r01*x471)));
evalcond[9]=((1.0)+((new_r10*x462))+(((-1.0)*new_r00*x471)));
evalcond[10]=(((sj14*x467))+((sj14*x472)));
evalcond[11]=(((new_r10*x469))+((new_r22*x467)));
evalcond[12]=((((-1.0)*x464))+x474+x473);
evalcond[13]=((((-1.0)*x465))+x468+x466);
evalcond[14]=(((sj14*x466))+((sj14*x468))+((cj14*new_r21)));
evalcond[15]=((-1.0)+(new_r22*new_r22)+((sj14*x473))+((new_r02*x470)));
evalcond[16]=(((new_r12*x469))+(((-1.0)*new_r22*x464))+((new_r22*x474)));
evalcond[17]=((-1.0)+(sj14*sj14)+((new_r22*x466))+((new_r22*x468)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[8]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[9]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[10]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[11]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[12]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[13]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[14]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[15]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[16]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[17]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(8);
vinfos[0].jointtype = 17;
vinfos[0].foffset = j5;
vinfos[0].indices[0] = _ij5[0];
vinfos[0].indices[1] = _ij5[1];
vinfos[0].maxsolutions = _nj5;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j9;
vinfos[1].indices[0] = _ij9[0];
vinfos[1].indices[1] = _ij9[1];
vinfos[1].maxsolutions = _nj9;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j10;
vinfos[2].indices[0] = _ij10[0];
vinfos[2].indices[1] = _ij10[1];
vinfos[2].maxsolutions = _nj10;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j11;
vinfos[3].indices[0] = _ij11[0];
vinfos[3].indices[1] = _ij11[1];
vinfos[3].maxsolutions = _nj11;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j12;
vinfos[4].indices[0] = _ij12[0];
vinfos[4].indices[1] = _ij12[1];
vinfos[4].maxsolutions = _nj12;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j13;
vinfos[5].indices[0] = _ij13[0];
vinfos[5].indices[1] = _ij13[1];
vinfos[5].maxsolutions = _nj13;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j14;
vinfos[6].indices[0] = _ij14[0];
vinfos[6].indices[1] = _ij14[1];
vinfos[6].maxsolutions = _nj14;
vinfos[7].jointtype = 1;
vinfos[7].foffset = j15;
vinfos[7].indices[0] = _ij15[0];
vinfos[7].indices[1] = _ij15[1];
vinfos[7].maxsolutions = _nj15;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(j14))), 6.28318530717959)));
evalcond[1]=new_r20;
evalcond[2]=new_r02;
evalcond[3]=new_r12;
evalcond[4]=new_r21;
if( IKabs(evalcond[0]) < 0.0000050000000000  && IKabs(evalcond[1]) < 0.0000050000000000  && IKabs(evalcond[2]) < 0.0000050000000000  && IKabs(evalcond[3]) < 0.0000050000000000  && IKabs(evalcond[4]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j13array[1], cj13array[1], sj13array[1];
bool j13valid[1]={false};
_nj13 = 1;
IkReal x475=((1.0)*new_r01);
if( IKabs(((((-1.0)*cj15*x475))+(((-1.0)*new_r00*sj15)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((((-1.0)*sj15*x475))+((cj15*new_r00)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((((-1.0)*cj15*x475))+(((-1.0)*new_r00*sj15))))+IKsqr(((((-1.0)*sj15*x475))+((cj15*new_r00))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j13array[0]=IKatan2(((((-1.0)*cj15*x475))+(((-1.0)*new_r00*sj15))), ((((-1.0)*sj15*x475))+((cj15*new_r00))));
sj13array[0]=IKsin(j13array[0]);
cj13array[0]=IKcos(j13array[0]);
if( j13array[0] > IKPI )
{
    j13array[0]-=IK2PI;
}
else if( j13array[0] < -IKPI )
{    j13array[0]+=IK2PI;
}
j13valid[0] = true;
for(int ij13 = 0; ij13 < 1; ++ij13)
{
if( !j13valid[ij13] )
{
    continue;
}
_ij13[0] = ij13; _ij13[1] = -1;
for(int iij13 = ij13+1; iij13 < 1; ++iij13)
{
if( j13valid[iij13] && IKabs(cj13array[ij13]-cj13array[iij13]) < IKFAST_SOLUTION_THRESH && IKabs(sj13array[ij13]-sj13array[iij13]) < IKFAST_SOLUTION_THRESH )
{
    j13valid[iij13]=false; _ij13[1] = iij13; break; 
}
}
j13 = j13array[ij13]; cj13 = cj13array[ij13]; sj13 = sj13array[ij13];
{
IkReal evalcond[8];
IkReal x476=IKcos(j13);
IkReal x477=IKsin(j13);
IkReal x478=((1.0)*cj15);
IkReal x479=((1.0)*sj15);
IkReal x480=(sj15*x477);
IkReal x481=((1.0)*x477);
IkReal x482=(x476*x478);
evalcond[0]=(((new_r01*x476))+((new_r11*x477))+sj15);
evalcond[1]=(((sj15*x476))+((cj15*x477))+new_r01);
evalcond[2]=((((-1.0)*x482))+x480+new_r00);
evalcond[3]=((((-1.0)*x482))+x480+new_r11);
evalcond[4]=(((new_r10*x477))+(((-1.0)*x478))+((new_r00*x476)));
evalcond[5]=((((-1.0)*x477*x478))+(((-1.0)*x476*x479))+new_r10);
evalcond[6]=((((-1.0)*new_r00*x481))+((new_r10*x476))+(((-1.0)*x479)));
evalcond[7]=((((-1.0)*new_r01*x481))+((new_r11*x476))+(((-1.0)*x478)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(8);
vinfos[0].jointtype = 17;
vinfos[0].foffset = j5;
vinfos[0].indices[0] = _ij5[0];
vinfos[0].indices[1] = _ij5[1];
vinfos[0].maxsolutions = _nj5;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j9;
vinfos[1].indices[0] = _ij9[0];
vinfos[1].indices[1] = _ij9[1];
vinfos[1].maxsolutions = _nj9;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j10;
vinfos[2].indices[0] = _ij10[0];
vinfos[2].indices[1] = _ij10[1];
vinfos[2].maxsolutions = _nj10;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j11;
vinfos[3].indices[0] = _ij11[0];
vinfos[3].indices[1] = _ij11[1];
vinfos[3].maxsolutions = _nj11;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j12;
vinfos[4].indices[0] = _ij12[0];
vinfos[4].indices[1] = _ij12[1];
vinfos[4].maxsolutions = _nj12;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j13;
vinfos[5].indices[0] = _ij13[0];
vinfos[5].indices[1] = _ij13[1];
vinfos[5].maxsolutions = _nj13;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j14;
vinfos[6].indices[0] = _ij14[0];
vinfos[6].indices[1] = _ij14[1];
vinfos[6].maxsolutions = _nj14;
vinfos[7].jointtype = 1;
vinfos[7].foffset = j15;
vinfos[7].indices[0] = _ij15[0];
vinfos[7].indices[1] = _ij15[1];
vinfos[7].maxsolutions = _nj15;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((-3.14159265358979)+j14)))), 6.28318530717959)));
evalcond[1]=new_r20;
evalcond[2]=new_r02;
evalcond[3]=new_r12;
evalcond[4]=new_r21;
if( IKabs(evalcond[0]) < 0.0000050000000000  && IKabs(evalcond[1]) < 0.0000050000000000  && IKabs(evalcond[2]) < 0.0000050000000000  && IKabs(evalcond[3]) < 0.0000050000000000  && IKabs(evalcond[4]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j13array[1], cj13array[1], sj13array[1];
bool j13valid[1]={false};
_nj13 = 1;
IkReal x483=((1.0)*cj15);
if( IKabs(((((-1.0)*new_r01*x483))+(((-1.0)*new_r00*sj15)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((((-1.0)*new_r00*x483))+((new_r01*sj15)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((((-1.0)*new_r01*x483))+(((-1.0)*new_r00*sj15))))+IKsqr(((((-1.0)*new_r00*x483))+((new_r01*sj15))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j13array[0]=IKatan2(((((-1.0)*new_r01*x483))+(((-1.0)*new_r00*sj15))), ((((-1.0)*new_r00*x483))+((new_r01*sj15))));
sj13array[0]=IKsin(j13array[0]);
cj13array[0]=IKcos(j13array[0]);
if( j13array[0] > IKPI )
{
    j13array[0]-=IK2PI;
}
else if( j13array[0] < -IKPI )
{    j13array[0]+=IK2PI;
}
j13valid[0] = true;
for(int ij13 = 0; ij13 < 1; ++ij13)
{
if( !j13valid[ij13] )
{
    continue;
}
_ij13[0] = ij13; _ij13[1] = -1;
for(int iij13 = ij13+1; iij13 < 1; ++iij13)
{
if( j13valid[iij13] && IKabs(cj13array[ij13]-cj13array[iij13]) < IKFAST_SOLUTION_THRESH && IKabs(sj13array[ij13]-sj13array[iij13]) < IKFAST_SOLUTION_THRESH )
{
    j13valid[iij13]=false; _ij13[1] = iij13; break; 
}
}
j13 = j13array[ij13]; cj13 = cj13array[ij13]; sj13 = sj13array[ij13];
{
IkReal evalcond[8];
IkReal x484=IKcos(j13);
IkReal x485=IKsin(j13);
IkReal x486=((1.0)*sj15);
IkReal x487=((1.0)*cj15);
IkReal x488=(cj15*x485);
IkReal x489=((1.0)*x485);
IkReal x490=(x484*x486);
evalcond[0]=(((new_r10*x485))+cj15+((new_r00*x484)));
evalcond[1]=(((cj15*x484))+((sj15*x485))+new_r00);
evalcond[2]=((((-1.0)*x490))+x488+new_r01);
evalcond[3]=((((-1.0)*x490))+x488+new_r10);
evalcond[4]=((((-1.0)*x486))+((new_r11*x485))+((new_r01*x484)));
evalcond[5]=((((-1.0)*x484*x487))+new_r11+(((-1.0)*x485*x486)));
evalcond[6]=((((-1.0)*x486))+(((-1.0)*new_r00*x489))+((new_r10*x484)));
evalcond[7]=((((-1.0)*new_r01*x489))+(((-1.0)*x487))+((new_r11*x484)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(8);
vinfos[0].jointtype = 17;
vinfos[0].foffset = j5;
vinfos[0].indices[0] = _ij5[0];
vinfos[0].indices[1] = _ij5[1];
vinfos[0].maxsolutions = _nj5;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j9;
vinfos[1].indices[0] = _ij9[0];
vinfos[1].indices[1] = _ij9[1];
vinfos[1].maxsolutions = _nj9;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j10;
vinfos[2].indices[0] = _ij10[0];
vinfos[2].indices[1] = _ij10[1];
vinfos[2].maxsolutions = _nj10;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j11;
vinfos[3].indices[0] = _ij11[0];
vinfos[3].indices[1] = _ij11[1];
vinfos[3].maxsolutions = _nj11;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j12;
vinfos[4].indices[0] = _ij12[0];
vinfos[4].indices[1] = _ij12[1];
vinfos[4].maxsolutions = _nj12;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j13;
vinfos[5].indices[0] = _ij13[0];
vinfos[5].indices[1] = _ij13[1];
vinfos[5].maxsolutions = _nj13;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j14;
vinfos[6].indices[0] = _ij14[0];
vinfos[6].indices[1] = _ij14[1];
vinfos[6].maxsolutions = _nj14;
vinfos[7].jointtype = 1;
vinfos[7].foffset = j15;
vinfos[7].indices[0] = _ij15[0];
vinfos[7].indices[1] = _ij15[1];
vinfos[7].maxsolutions = _nj15;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((IKabs(new_r12))+(IKabs(new_r02)));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j13eval[1];
new_r02=0;
new_r12=0;
new_r20=0;
new_r21=0;
j13eval[0]=((IKabs(new_r11))+(IKabs(new_r01)));
if( IKabs(j13eval[0]) < 0.0000010000000000  )
{
{
IkReal j13eval[1];
new_r02=0;
new_r12=0;
new_r20=0;
new_r21=0;
j13eval[0]=((IKabs(new_r10))+(IKabs(new_r00)));
if( IKabs(j13eval[0]) < 0.0000010000000000  )
{
{
IkReal j13eval[1];
new_r02=0;
new_r12=0;
new_r20=0;
new_r21=0;
j13eval[0]=((IKabs((new_r11*new_r22)))+(IKabs((new_r01*new_r22))));
if( IKabs(j13eval[0]) < 0.0000010000000000  )
{
continue; // no branches [j13]

} else
{
{
IkReal j13array[2], cj13array[2], sj13array[2];
bool j13valid[2]={false};
_nj13 = 2;
CheckValue<IkReal> x492 = IKatan2WithCheck(IkReal((new_r01*new_r22)),IkReal((new_r11*new_r22)),IKFAST_ATAN2_MAGTHRESH);
if(!x492.valid){
continue;
}
IkReal x491=x492.value;
j13array[0]=((-1.0)*x491);
sj13array[0]=IKsin(j13array[0]);
cj13array[0]=IKcos(j13array[0]);
j13array[1]=((3.14159265358979)+(((-1.0)*x491)));
sj13array[1]=IKsin(j13array[1]);
cj13array[1]=IKcos(j13array[1]);
if( j13array[0] > IKPI )
{
    j13array[0]-=IK2PI;
}
else if( j13array[0] < -IKPI )
{    j13array[0]+=IK2PI;
}
j13valid[0] = true;
if( j13array[1] > IKPI )
{
    j13array[1]-=IK2PI;
}
else if( j13array[1] < -IKPI )
{    j13array[1]+=IK2PI;
}
j13valid[1] = true;
for(int ij13 = 0; ij13 < 2; ++ij13)
{
if( !j13valid[ij13] )
{
    continue;
}
_ij13[0] = ij13; _ij13[1] = -1;
for(int iij13 = ij13+1; iij13 < 2; ++iij13)
{
if( j13valid[iij13] && IKabs(cj13array[ij13]-cj13array[iij13]) < IKFAST_SOLUTION_THRESH && IKabs(sj13array[ij13]-sj13array[iij13]) < IKFAST_SOLUTION_THRESH )
{
    j13valid[iij13]=false; _ij13[1] = iij13; break; 
}
}
j13 = j13array[ij13]; cj13 = cj13array[ij13]; sj13 = sj13array[ij13];
{
IkReal evalcond[5];
IkReal x493=IKcos(j13);
IkReal x494=IKsin(j13);
IkReal x495=((1.0)*x494);
IkReal x496=(new_r10*x494);
IkReal x497=(new_r00*x493);
evalcond[0]=(((new_r11*x494))+((new_r01*x493)));
evalcond[1]=(x496+x497);
evalcond[2]=((((-1.0)*new_r00*x495))+((new_r10*x493)));
evalcond[3]=((((-1.0)*new_r01*x495))+((new_r11*x493)));
evalcond[4]=(((new_r22*x497))+((new_r22*x496)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(8);
vinfos[0].jointtype = 17;
vinfos[0].foffset = j5;
vinfos[0].indices[0] = _ij5[0];
vinfos[0].indices[1] = _ij5[1];
vinfos[0].maxsolutions = _nj5;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j9;
vinfos[1].indices[0] = _ij9[0];
vinfos[1].indices[1] = _ij9[1];
vinfos[1].maxsolutions = _nj9;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j10;
vinfos[2].indices[0] = _ij10[0];
vinfos[2].indices[1] = _ij10[1];
vinfos[2].maxsolutions = _nj10;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j11;
vinfos[3].indices[0] = _ij11[0];
vinfos[3].indices[1] = _ij11[1];
vinfos[3].maxsolutions = _nj11;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j12;
vinfos[4].indices[0] = _ij12[0];
vinfos[4].indices[1] = _ij12[1];
vinfos[4].maxsolutions = _nj12;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j13;
vinfos[5].indices[0] = _ij13[0];
vinfos[5].indices[1] = _ij13[1];
vinfos[5].maxsolutions = _nj13;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j14;
vinfos[6].indices[0] = _ij14[0];
vinfos[6].indices[1] = _ij14[1];
vinfos[6].maxsolutions = _nj14;
vinfos[7].jointtype = 1;
vinfos[7].foffset = j15;
vinfos[7].indices[0] = _ij15[0];
vinfos[7].indices[1] = _ij15[1];
vinfos[7].maxsolutions = _nj15;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

} else
{
{
IkReal j13array[2], cj13array[2], sj13array[2];
bool j13valid[2]={false};
_nj13 = 2;
CheckValue<IkReal> x499 = IKatan2WithCheck(IkReal(new_r00),IkReal(new_r10),IKFAST_ATAN2_MAGTHRESH);
if(!x499.valid){
continue;
}
IkReal x498=x499.value;
j13array[0]=((-1.0)*x498);
sj13array[0]=IKsin(j13array[0]);
cj13array[0]=IKcos(j13array[0]);
j13array[1]=((3.14159265358979)+(((-1.0)*x498)));
sj13array[1]=IKsin(j13array[1]);
cj13array[1]=IKcos(j13array[1]);
if( j13array[0] > IKPI )
{
    j13array[0]-=IK2PI;
}
else if( j13array[0] < -IKPI )
{    j13array[0]+=IK2PI;
}
j13valid[0] = true;
if( j13array[1] > IKPI )
{
    j13array[1]-=IK2PI;
}
else if( j13array[1] < -IKPI )
{    j13array[1]+=IK2PI;
}
j13valid[1] = true;
for(int ij13 = 0; ij13 < 2; ++ij13)
{
if( !j13valid[ij13] )
{
    continue;
}
_ij13[0] = ij13; _ij13[1] = -1;
for(int iij13 = ij13+1; iij13 < 2; ++iij13)
{
if( j13valid[iij13] && IKabs(cj13array[ij13]-cj13array[iij13]) < IKFAST_SOLUTION_THRESH && IKabs(sj13array[ij13]-sj13array[iij13]) < IKFAST_SOLUTION_THRESH )
{
    j13valid[iij13]=false; _ij13[1] = iij13; break; 
}
}
j13 = j13array[ij13]; cj13 = cj13array[ij13]; sj13 = sj13array[ij13];
{
IkReal evalcond[5];
IkReal x500=IKcos(j13);
IkReal x501=IKsin(j13);
IkReal x502=((1.0)*x501);
IkReal x503=(new_r01*x500);
IkReal x504=(new_r22*x501);
evalcond[0]=(((new_r11*x501))+x503);
evalcond[1]=((((-1.0)*new_r00*x502))+((new_r10*x500)));
evalcond[2]=((((-1.0)*new_r01*x502))+((new_r11*x500)));
evalcond[3]=(((new_r22*x503))+((new_r11*x504)));
evalcond[4]=(((new_r00*new_r22*x500))+((new_r10*x504)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(8);
vinfos[0].jointtype = 17;
vinfos[0].foffset = j5;
vinfos[0].indices[0] = _ij5[0];
vinfos[0].indices[1] = _ij5[1];
vinfos[0].maxsolutions = _nj5;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j9;
vinfos[1].indices[0] = _ij9[0];
vinfos[1].indices[1] = _ij9[1];
vinfos[1].maxsolutions = _nj9;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j10;
vinfos[2].indices[0] = _ij10[0];
vinfos[2].indices[1] = _ij10[1];
vinfos[2].maxsolutions = _nj10;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j11;
vinfos[3].indices[0] = _ij11[0];
vinfos[3].indices[1] = _ij11[1];
vinfos[3].maxsolutions = _nj11;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j12;
vinfos[4].indices[0] = _ij12[0];
vinfos[4].indices[1] = _ij12[1];
vinfos[4].maxsolutions = _nj12;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j13;
vinfos[5].indices[0] = _ij13[0];
vinfos[5].indices[1] = _ij13[1];
vinfos[5].maxsolutions = _nj13;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j14;
vinfos[6].indices[0] = _ij14[0];
vinfos[6].indices[1] = _ij14[1];
vinfos[6].maxsolutions = _nj14;
vinfos[7].jointtype = 1;
vinfos[7].foffset = j15;
vinfos[7].indices[0] = _ij15[0];
vinfos[7].indices[1] = _ij15[1];
vinfos[7].maxsolutions = _nj15;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

} else
{
{
IkReal j13array[2], cj13array[2], sj13array[2];
bool j13valid[2]={false};
_nj13 = 2;
CheckValue<IkReal> x506 = IKatan2WithCheck(IkReal(new_r01),IkReal(new_r11),IKFAST_ATAN2_MAGTHRESH);
if(!x506.valid){
continue;
}
IkReal x505=x506.value;
j13array[0]=((-1.0)*x505);
sj13array[0]=IKsin(j13array[0]);
cj13array[0]=IKcos(j13array[0]);
j13array[1]=((3.14159265358979)+(((-1.0)*x505)));
sj13array[1]=IKsin(j13array[1]);
cj13array[1]=IKcos(j13array[1]);
if( j13array[0] > IKPI )
{
    j13array[0]-=IK2PI;
}
else if( j13array[0] < -IKPI )
{    j13array[0]+=IK2PI;
}
j13valid[0] = true;
if( j13array[1] > IKPI )
{
    j13array[1]-=IK2PI;
}
else if( j13array[1] < -IKPI )
{    j13array[1]+=IK2PI;
}
j13valid[1] = true;
for(int ij13 = 0; ij13 < 2; ++ij13)
{
if( !j13valid[ij13] )
{
    continue;
}
_ij13[0] = ij13; _ij13[1] = -1;
for(int iij13 = ij13+1; iij13 < 2; ++iij13)
{
if( j13valid[iij13] && IKabs(cj13array[ij13]-cj13array[iij13]) < IKFAST_SOLUTION_THRESH && IKabs(sj13array[ij13]-sj13array[iij13]) < IKFAST_SOLUTION_THRESH )
{
    j13valid[iij13]=false; _ij13[1] = iij13; break; 
}
}
j13 = j13array[ij13]; cj13 = cj13array[ij13]; sj13 = sj13array[ij13];
{
IkReal evalcond[5];
IkReal x507=IKcos(j13);
IkReal x508=IKsin(j13);
IkReal x509=((1.0)*x508);
IkReal x510=(new_r22*x507);
IkReal x511=(new_r22*x508);
evalcond[0]=(((new_r10*x508))+((new_r00*x507)));
evalcond[1]=((((-1.0)*new_r00*x509))+((new_r10*x507)));
evalcond[2]=((((-1.0)*new_r01*x509))+((new_r11*x507)));
evalcond[3]=(((new_r01*x510))+((new_r11*x511)));
evalcond[4]=(((new_r00*x510))+((new_r10*x511)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(8);
vinfos[0].jointtype = 17;
vinfos[0].foffset = j5;
vinfos[0].indices[0] = _ij5[0];
vinfos[0].indices[1] = _ij5[1];
vinfos[0].maxsolutions = _nj5;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j9;
vinfos[1].indices[0] = _ij9[0];
vinfos[1].indices[1] = _ij9[1];
vinfos[1].maxsolutions = _nj9;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j10;
vinfos[2].indices[0] = _ij10[0];
vinfos[2].indices[1] = _ij10[1];
vinfos[2].maxsolutions = _nj10;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j11;
vinfos[3].indices[0] = _ij11[0];
vinfos[3].indices[1] = _ij11[1];
vinfos[3].maxsolutions = _nj11;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j12;
vinfos[4].indices[0] = _ij12[0];
vinfos[4].indices[1] = _ij12[1];
vinfos[4].maxsolutions = _nj12;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j13;
vinfos[5].indices[0] = _ij13[0];
vinfos[5].indices[1] = _ij13[1];
vinfos[5].maxsolutions = _nj13;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j14;
vinfos[6].indices[0] = _ij14[0];
vinfos[6].indices[1] = _ij14[1];
vinfos[6].maxsolutions = _nj14;
vinfos[7].jointtype = 1;
vinfos[7].foffset = j15;
vinfos[7].indices[0] = _ij15[0];
vinfos[7].indices[1] = _ij15[1];
vinfos[7].maxsolutions = _nj15;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
if( 1 )
{
bgotonextstatement=false;
continue; // branch miss [j13]

}
} while(0);
if( bgotonextstatement )
{
}
}
}
}
}
}
}

} else
{
{
IkReal j13array[1], cj13array[1], sj13array[1];
bool j13valid[1]={false};
_nj13 = 1;
CheckValue<IkReal> x513=IKPowWithIntegerCheck(sj14,-1);
if(!x513.valid){
continue;
}
IkReal x512=x513.value;
CheckValue<IkReal> x514=IKPowWithIntegerCheck(cj15,-1);
if(!x514.valid){
continue;
}
if( IKabs((x512*(x514.value)*(((((-1.0)*new_r01*sj14))+(((-1.0)*cj14*new_r02*sj15)))))) < IKFAST_ATAN2_MAGTHRESH && IKabs((new_r02*x512)) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr((x512*(x514.value)*(((((-1.0)*new_r01*sj14))+(((-1.0)*cj14*new_r02*sj15))))))+IKsqr((new_r02*x512))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j13array[0]=IKatan2((x512*(x514.value)*(((((-1.0)*new_r01*sj14))+(((-1.0)*cj14*new_r02*sj15))))), (new_r02*x512));
sj13array[0]=IKsin(j13array[0]);
cj13array[0]=IKcos(j13array[0]);
if( j13array[0] > IKPI )
{
    j13array[0]-=IK2PI;
}
else if( j13array[0] < -IKPI )
{    j13array[0]+=IK2PI;
}
j13valid[0] = true;
for(int ij13 = 0; ij13 < 1; ++ij13)
{
if( !j13valid[ij13] )
{
    continue;
}
_ij13[0] = ij13; _ij13[1] = -1;
for(int iij13 = ij13+1; iij13 < 1; ++iij13)
{
if( j13valid[iij13] && IKabs(cj13array[ij13]-cj13array[iij13]) < IKFAST_SOLUTION_THRESH && IKabs(sj13array[ij13]-sj13array[iij13]) < IKFAST_SOLUTION_THRESH )
{
    j13valid[iij13]=false; _ij13[1] = iij13; break; 
}
}
j13 = j13array[ij13]; cj13 = cj13array[ij13]; sj13 = sj13array[ij13];
{
IkReal evalcond[18];
IkReal x515=IKcos(j13);
IkReal x516=IKsin(j13);
IkReal x517=((1.0)*cj15);
IkReal x518=((1.0)*sj15);
IkReal x519=((1.0)*sj14);
IkReal x520=(new_r01*x515);
IkReal x521=(new_r00*x515);
IkReal x522=(cj14*x516);
IkReal x523=(new_r11*x516);
IkReal x524=(sj14*x515);
IkReal x525=((1.0)*x516);
IkReal x526=(new_r10*x516);
IkReal x527=(new_r12*x516);
IkReal x528=(cj14*x515);
evalcond[0]=((((-1.0)*x515*x519))+new_r02);
evalcond[1]=((((-1.0)*x516*x519))+new_r12);
evalcond[2]=(((new_r12*x515))+(((-1.0)*new_r02*x525)));
evalcond[3]=(((sj15*x528))+new_r01+((cj15*x516)));
evalcond[4]=(((new_r02*x515))+x527+(((-1.0)*x519)));
evalcond[5]=(((cj14*sj15))+x523+x520);
evalcond[6]=((((-1.0)*x517*x528))+((sj15*x516))+new_r00);
evalcond[7]=(((sj15*x522))+(((-1.0)*x515*x517))+new_r11);
evalcond[8]=(((new_r10*x515))+(((-1.0)*new_r00*x525))+(((-1.0)*x518)));
evalcond[9]=(((new_r11*x515))+(((-1.0)*new_r01*x525))+(((-1.0)*x517)));
evalcond[10]=(x521+x526+(((-1.0)*cj14*x517)));
evalcond[11]=((((-1.0)*x517*x522))+(((-1.0)*x515*x518))+new_r10);
evalcond[12]=(((cj14*new_r20))+((sj14*x526))+((sj14*x521)));
evalcond[13]=(((cj14*new_r21))+((sj14*x520))+((sj14*x523)));
evalcond[14]=((-1.0)+((new_r02*x524))+((cj14*new_r22))+((sj14*x527)));
evalcond[15]=(((new_r02*x528))+((new_r12*x522))+(((-1.0)*new_r22*x519)));
evalcond[16]=(((new_r11*x522))+sj15+((cj14*x520))+(((-1.0)*new_r21*x519)));
evalcond[17]=(((new_r10*x522))+((cj14*x521))+(((-1.0)*new_r20*x519))+(((-1.0)*x517)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[8]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[9]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[10]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[11]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[12]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[13]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[14]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[15]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[16]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[17]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(8);
vinfos[0].jointtype = 17;
vinfos[0].foffset = j5;
vinfos[0].indices[0] = _ij5[0];
vinfos[0].indices[1] = _ij5[1];
vinfos[0].maxsolutions = _nj5;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j9;
vinfos[1].indices[0] = _ij9[0];
vinfos[1].indices[1] = _ij9[1];
vinfos[1].maxsolutions = _nj9;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j10;
vinfos[2].indices[0] = _ij10[0];
vinfos[2].indices[1] = _ij10[1];
vinfos[2].maxsolutions = _nj10;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j11;
vinfos[3].indices[0] = _ij11[0];
vinfos[3].indices[1] = _ij11[1];
vinfos[3].maxsolutions = _nj11;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j12;
vinfos[4].indices[0] = _ij12[0];
vinfos[4].indices[1] = _ij12[1];
vinfos[4].maxsolutions = _nj12;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j13;
vinfos[5].indices[0] = _ij13[0];
vinfos[5].indices[1] = _ij13[1];
vinfos[5].maxsolutions = _nj13;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j14;
vinfos[6].indices[0] = _ij14[0];
vinfos[6].indices[1] = _ij14[1];
vinfos[6].maxsolutions = _nj14;
vinfos[7].jointtype = 1;
vinfos[7].foffset = j15;
vinfos[7].indices[0] = _ij15[0];
vinfos[7].indices[1] = _ij15[1];
vinfos[7].maxsolutions = _nj15;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

} else
{
{
IkReal j13array[1], cj13array[1], sj13array[1];
bool j13valid[1]={false};
_nj13 = 1;
CheckValue<IkReal> x529=IKPowWithIntegerCheck(IKsign(sj14),-1);
if(!x529.valid){
continue;
}
CheckValue<IkReal> x530 = IKatan2WithCheck(IkReal(new_r12),IkReal(new_r02),IKFAST_ATAN2_MAGTHRESH);
if(!x530.valid){
continue;
}
j13array[0]=((-1.5707963267949)+(((1.5707963267949)*(x529.value)))+(x530.value));
sj13array[0]=IKsin(j13array[0]);
cj13array[0]=IKcos(j13array[0]);
if( j13array[0] > IKPI )
{
    j13array[0]-=IK2PI;
}
else if( j13array[0] < -IKPI )
{    j13array[0]+=IK2PI;
}
j13valid[0] = true;
for(int ij13 = 0; ij13 < 1; ++ij13)
{
if( !j13valid[ij13] )
{
    continue;
}
_ij13[0] = ij13; _ij13[1] = -1;
for(int iij13 = ij13+1; iij13 < 1; ++iij13)
{
if( j13valid[iij13] && IKabs(cj13array[ij13]-cj13array[iij13]) < IKFAST_SOLUTION_THRESH && IKabs(sj13array[ij13]-sj13array[iij13]) < IKFAST_SOLUTION_THRESH )
{
    j13valid[iij13]=false; _ij13[1] = iij13; break; 
}
}
j13 = j13array[ij13]; cj13 = cj13array[ij13]; sj13 = sj13array[ij13];
{
IkReal evalcond[18];
IkReal x531=IKcos(j13);
IkReal x532=IKsin(j13);
IkReal x533=((1.0)*cj15);
IkReal x534=((1.0)*sj15);
IkReal x535=((1.0)*sj14);
IkReal x536=(new_r01*x531);
IkReal x537=(new_r00*x531);
IkReal x538=(cj14*x532);
IkReal x539=(new_r11*x532);
IkReal x540=(sj14*x531);
IkReal x541=((1.0)*x532);
IkReal x542=(new_r10*x532);
IkReal x543=(new_r12*x532);
IkReal x544=(cj14*x531);
evalcond[0]=((((-1.0)*x531*x535))+new_r02);
evalcond[1]=((((-1.0)*x532*x535))+new_r12);
evalcond[2]=(((new_r12*x531))+(((-1.0)*new_r02*x541)));
evalcond[3]=(((sj15*x544))+((cj15*x532))+new_r01);
evalcond[4]=(((new_r02*x531))+(((-1.0)*x535))+x543);
evalcond[5]=(((cj14*sj15))+x536+x539);
evalcond[6]=((((-1.0)*x533*x544))+((sj15*x532))+new_r00);
evalcond[7]=(((sj15*x538))+(((-1.0)*x531*x533))+new_r11);
evalcond[8]=((((-1.0)*new_r00*x541))+(((-1.0)*x534))+((new_r10*x531)));
evalcond[9]=(((new_r11*x531))+(((-1.0)*x533))+(((-1.0)*new_r01*x541)));
evalcond[10]=(x542+x537+(((-1.0)*cj14*x533)));
evalcond[11]=((((-1.0)*x533*x538))+(((-1.0)*x531*x534))+new_r10);
evalcond[12]=(((cj14*new_r20))+((sj14*x542))+((sj14*x537)));
evalcond[13]=(((cj14*new_r21))+((sj14*x536))+((sj14*x539)));
evalcond[14]=((-1.0)+((new_r02*x540))+((cj14*new_r22))+((sj14*x543)));
evalcond[15]=((((-1.0)*new_r22*x535))+((new_r02*x544))+((new_r12*x538)));
evalcond[16]=(((new_r11*x538))+(((-1.0)*new_r21*x535))+((cj14*x536))+sj15);
evalcond[17]=((((-1.0)*x533))+((new_r10*x538))+(((-1.0)*new_r20*x535))+((cj14*x537)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[8]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[9]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[10]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[11]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[12]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[13]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[14]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[15]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[16]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[17]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(8);
vinfos[0].jointtype = 17;
vinfos[0].foffset = j5;
vinfos[0].indices[0] = _ij5[0];
vinfos[0].indices[1] = _ij5[1];
vinfos[0].maxsolutions = _nj5;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j9;
vinfos[1].indices[0] = _ij9[0];
vinfos[1].indices[1] = _ij9[1];
vinfos[1].maxsolutions = _nj9;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j10;
vinfos[2].indices[0] = _ij10[0];
vinfos[2].indices[1] = _ij10[1];
vinfos[2].maxsolutions = _nj10;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j11;
vinfos[3].indices[0] = _ij11[0];
vinfos[3].indices[1] = _ij11[1];
vinfos[3].maxsolutions = _nj11;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j12;
vinfos[4].indices[0] = _ij12[0];
vinfos[4].indices[1] = _ij12[1];
vinfos[4].maxsolutions = _nj12;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j13;
vinfos[5].indices[0] = _ij13[0];
vinfos[5].indices[1] = _ij13[1];
vinfos[5].maxsolutions = _nj13;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j14;
vinfos[6].indices[0] = _ij14[0];
vinfos[6].indices[1] = _ij14[1];
vinfos[6].maxsolutions = _nj14;
vinfos[7].jointtype = 1;
vinfos[7].foffset = j15;
vinfos[7].indices[0] = _ij15[0];
vinfos[7].indices[1] = _ij15[1];
vinfos[7].maxsolutions = _nj15;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}
}
}

}

}

} else
{
{
IkReal j13array[1], cj13array[1], sj13array[1];
bool j13valid[1]={false};
_nj13 = 1;
CheckValue<IkReal> x545=IKPowWithIntegerCheck(IKsign(sj14),-1);
if(!x545.valid){
continue;
}
CheckValue<IkReal> x546 = IKatan2WithCheck(IkReal(new_r12),IkReal(new_r02),IKFAST_ATAN2_MAGTHRESH);
if(!x546.valid){
continue;
}
j13array[0]=((-1.5707963267949)+(((1.5707963267949)*(x545.value)))+(x546.value));
sj13array[0]=IKsin(j13array[0]);
cj13array[0]=IKcos(j13array[0]);
if( j13array[0] > IKPI )
{
    j13array[0]-=IK2PI;
}
else if( j13array[0] < -IKPI )
{    j13array[0]+=IK2PI;
}
j13valid[0] = true;
for(int ij13 = 0; ij13 < 1; ++ij13)
{
if( !j13valid[ij13] )
{
    continue;
}
_ij13[0] = ij13; _ij13[1] = -1;
for(int iij13 = ij13+1; iij13 < 1; ++iij13)
{
if( j13valid[iij13] && IKabs(cj13array[ij13]-cj13array[iij13]) < IKFAST_SOLUTION_THRESH && IKabs(sj13array[ij13]-sj13array[iij13]) < IKFAST_SOLUTION_THRESH )
{
    j13valid[iij13]=false; _ij13[1] = iij13; break; 
}
}
j13 = j13array[ij13]; cj13 = cj13array[ij13]; sj13 = sj13array[ij13];
{
IkReal evalcond[8];
IkReal x547=IKcos(j13);
IkReal x548=IKsin(j13);
IkReal x549=((1.0)*sj14);
IkReal x550=(new_r12*x548);
IkReal x551=(new_r02*x547);
IkReal x552=(sj14*x547);
IkReal x553=(sj14*x548);
evalcond[0]=((((-1.0)*x547*x549))+new_r02);
evalcond[1]=((((-1.0)*x548*x549))+new_r12);
evalcond[2]=(((new_r12*x547))+(((-1.0)*new_r02*x548)));
evalcond[3]=((((-1.0)*x549))+x551+x550);
evalcond[4]=(((new_r10*x553))+((cj14*new_r20))+((new_r00*x552)));
evalcond[5]=(((new_r11*x553))+((cj14*new_r21))+((new_r01*x552)));
evalcond[6]=((-1.0)+((cj14*new_r22))+((sj14*x550))+((sj14*x551)));
evalcond[7]=((((-1.0)*new_r22*x549))+((cj14*x551))+((cj14*x550)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
IkReal j15eval[3];
j15eval[0]=sj14;
j15eval[1]=IKsign(sj14);
j15eval[2]=((IKabs(new_r20))+(IKabs(new_r21)));
if( IKabs(j15eval[0]) < 0.0000010000000000  || IKabs(j15eval[1]) < 0.0000010000000000  || IKabs(j15eval[2]) < 0.0000010000000000  )
{
{
IkReal j15eval[2];
j15eval[0]=sj14;
j15eval[1]=sj13;
if( IKabs(j15eval[0]) < 0.0000010000000000  || IKabs(j15eval[1]) < 0.0000010000000000  )
{
{
IkReal j15eval[3];
j15eval[0]=cj14;
j15eval[1]=sj13;
j15eval[2]=sj14;
if( IKabs(j15eval[0]) < 0.0000010000000000  || IKabs(j15eval[1]) < 0.0000010000000000  || IKabs(j15eval[2]) < 0.0000010000000000  )
{
{
IkReal evalcond[5];
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((-1.5707963267949)+j14)))), 6.28318530717959)));
evalcond[1]=new_r22;
if( IKabs(evalcond[0]) < 0.0000050000000000  && IKabs(evalcond[1]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j15array[1], cj15array[1], sj15array[1];
bool j15valid[1]={false};
_nj15 = 1;
if( IKabs(new_r21) < IKFAST_ATAN2_MAGTHRESH && IKabs(((-1.0)*new_r20)) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(new_r21)+IKsqr(((-1.0)*new_r20))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j15array[0]=IKatan2(new_r21, ((-1.0)*new_r20));
sj15array[0]=IKsin(j15array[0]);
cj15array[0]=IKcos(j15array[0]);
if( j15array[0] > IKPI )
{
    j15array[0]-=IK2PI;
}
else if( j15array[0] < -IKPI )
{    j15array[0]+=IK2PI;
}
j15valid[0] = true;
for(int ij15 = 0; ij15 < 1; ++ij15)
{
if( !j15valid[ij15] )
{
    continue;
}
_ij15[0] = ij15; _ij15[1] = -1;
for(int iij15 = ij15+1; iij15 < 1; ++iij15)
{
if( j15valid[iij15] && IKabs(cj15array[ij15]-cj15array[iij15]) < IKFAST_SOLUTION_THRESH && IKabs(sj15array[ij15]-sj15array[iij15]) < IKFAST_SOLUTION_THRESH )
{
    j15valid[iij15]=false; _ij15[1] = iij15; break; 
}
}
j15 = j15array[ij15]; cj15 = cj15array[ij15]; sj15 = sj15array[ij15];
{
IkReal evalcond[8];
IkReal x554=IKcos(j15);
IkReal x555=IKsin(j15);
IkReal x556=((1.0)*cj13);
IkReal x557=((1.0)*sj13);
IkReal x558=((1.0)*x555);
evalcond[0]=(x554+new_r20);
evalcond[1]=((((-1.0)*x558))+new_r21);
evalcond[2]=(((sj13*x554))+new_r01);
evalcond[3]=(((sj13*x555))+new_r00);
evalcond[4]=((((-1.0)*x554*x556))+new_r11);
evalcond[5]=((((-1.0)*x555*x556))+new_r10);
evalcond[6]=(((cj13*new_r10))+(((-1.0)*new_r00*x557))+(((-1.0)*x558)));
evalcond[7]=((((-1.0)*x554))+((cj13*new_r11))+(((-1.0)*new_r01*x557)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(8);
vinfos[0].jointtype = 17;
vinfos[0].foffset = j5;
vinfos[0].indices[0] = _ij5[0];
vinfos[0].indices[1] = _ij5[1];
vinfos[0].maxsolutions = _nj5;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j9;
vinfos[1].indices[0] = _ij9[0];
vinfos[1].indices[1] = _ij9[1];
vinfos[1].maxsolutions = _nj9;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j10;
vinfos[2].indices[0] = _ij10[0];
vinfos[2].indices[1] = _ij10[1];
vinfos[2].maxsolutions = _nj10;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j11;
vinfos[3].indices[0] = _ij11[0];
vinfos[3].indices[1] = _ij11[1];
vinfos[3].maxsolutions = _nj11;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j12;
vinfos[4].indices[0] = _ij12[0];
vinfos[4].indices[1] = _ij12[1];
vinfos[4].maxsolutions = _nj12;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j13;
vinfos[5].indices[0] = _ij13[0];
vinfos[5].indices[1] = _ij13[1];
vinfos[5].maxsolutions = _nj13;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j14;
vinfos[6].indices[0] = _ij14[0];
vinfos[6].indices[1] = _ij14[1];
vinfos[6].maxsolutions = _nj14;
vinfos[7].jointtype = 1;
vinfos[7].foffset = j15;
vinfos[7].indices[0] = _ij15[0];
vinfos[7].indices[1] = _ij15[1];
vinfos[7].maxsolutions = _nj15;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((1.5707963267949)+j14)))), 6.28318530717959)));
evalcond[1]=new_r22;
if( IKabs(evalcond[0]) < 0.0000050000000000  && IKabs(evalcond[1]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j15array[1], cj15array[1], sj15array[1];
bool j15valid[1]={false};
_nj15 = 1;
if( IKabs(((-1.0)*new_r21)) < IKFAST_ATAN2_MAGTHRESH && IKabs(new_r20) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((-1.0)*new_r21))+IKsqr(new_r20)-1) <= IKFAST_SINCOS_THRESH )
    continue;
j15array[0]=IKatan2(((-1.0)*new_r21), new_r20);
sj15array[0]=IKsin(j15array[0]);
cj15array[0]=IKcos(j15array[0]);
if( j15array[0] > IKPI )
{
    j15array[0]-=IK2PI;
}
else if( j15array[0] < -IKPI )
{    j15array[0]+=IK2PI;
}
j15valid[0] = true;
for(int ij15 = 0; ij15 < 1; ++ij15)
{
if( !j15valid[ij15] )
{
    continue;
}
_ij15[0] = ij15; _ij15[1] = -1;
for(int iij15 = ij15+1; iij15 < 1; ++iij15)
{
if( j15valid[iij15] && IKabs(cj15array[ij15]-cj15array[iij15]) < IKFAST_SOLUTION_THRESH && IKabs(sj15array[ij15]-sj15array[iij15]) < IKFAST_SOLUTION_THRESH )
{
    j15valid[iij15]=false; _ij15[1] = iij15; break; 
}
}
j15 = j15array[ij15]; cj15 = cj15array[ij15]; sj15 = sj15array[ij15];
{
IkReal evalcond[8];
IkReal x559=IKcos(j15);
IkReal x560=IKsin(j15);
IkReal x561=((1.0)*cj13);
IkReal x562=((1.0)*sj13);
IkReal x563=((1.0)*x559);
evalcond[0]=(x560+new_r21);
evalcond[1]=(new_r20+(((-1.0)*x563)));
evalcond[2]=(((sj13*x559))+new_r01);
evalcond[3]=(((sj13*x560))+new_r00);
evalcond[4]=((((-1.0)*x559*x561))+new_r11);
evalcond[5]=((((-1.0)*x560*x561))+new_r10);
evalcond[6]=((((-1.0)*new_r00*x562))+((cj13*new_r10))+(((-1.0)*x560)));
evalcond[7]=(((cj13*new_r11))+(((-1.0)*x563))+(((-1.0)*new_r01*x562)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(8);
vinfos[0].jointtype = 17;
vinfos[0].foffset = j5;
vinfos[0].indices[0] = _ij5[0];
vinfos[0].indices[1] = _ij5[1];
vinfos[0].maxsolutions = _nj5;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j9;
vinfos[1].indices[0] = _ij9[0];
vinfos[1].indices[1] = _ij9[1];
vinfos[1].maxsolutions = _nj9;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j10;
vinfos[2].indices[0] = _ij10[0];
vinfos[2].indices[1] = _ij10[1];
vinfos[2].maxsolutions = _nj10;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j11;
vinfos[3].indices[0] = _ij11[0];
vinfos[3].indices[1] = _ij11[1];
vinfos[3].maxsolutions = _nj11;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j12;
vinfos[4].indices[0] = _ij12[0];
vinfos[4].indices[1] = _ij12[1];
vinfos[4].maxsolutions = _nj12;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j13;
vinfos[5].indices[0] = _ij13[0];
vinfos[5].indices[1] = _ij13[1];
vinfos[5].maxsolutions = _nj13;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j14;
vinfos[6].indices[0] = _ij14[0];
vinfos[6].indices[1] = _ij14[1];
vinfos[6].maxsolutions = _nj14;
vinfos[7].jointtype = 1;
vinfos[7].foffset = j15;
vinfos[7].indices[0] = _ij15[0];
vinfos[7].indices[1] = _ij15[1];
vinfos[7].maxsolutions = _nj15;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(j13))), 6.28318530717959)));
evalcond[1]=new_r12;
if( IKabs(evalcond[0]) < 0.0000050000000000  && IKabs(evalcond[1]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j15array[1], cj15array[1], sj15array[1];
bool j15valid[1]={false};
_nj15 = 1;
if( IKabs(new_r10) < IKFAST_ATAN2_MAGTHRESH && IKabs(new_r11) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(new_r10)+IKsqr(new_r11)-1) <= IKFAST_SINCOS_THRESH )
    continue;
j15array[0]=IKatan2(new_r10, new_r11);
sj15array[0]=IKsin(j15array[0]);
cj15array[0]=IKcos(j15array[0]);
if( j15array[0] > IKPI )
{
    j15array[0]-=IK2PI;
}
else if( j15array[0] < -IKPI )
{    j15array[0]+=IK2PI;
}
j15valid[0] = true;
for(int ij15 = 0; ij15 < 1; ++ij15)
{
if( !j15valid[ij15] )
{
    continue;
}
_ij15[0] = ij15; _ij15[1] = -1;
for(int iij15 = ij15+1; iij15 < 1; ++iij15)
{
if( j15valid[iij15] && IKabs(cj15array[ij15]-cj15array[iij15]) < IKFAST_SOLUTION_THRESH && IKabs(sj15array[ij15]-sj15array[iij15]) < IKFAST_SOLUTION_THRESH )
{
    j15valid[iij15]=false; _ij15[1] = iij15; break; 
}
}
j15 = j15array[ij15]; cj15 = cj15array[ij15]; sj15 = sj15array[ij15];
{
IkReal evalcond[8];
IkReal x564=IKcos(j15);
IkReal x565=IKsin(j15);
IkReal x566=((1.0)*sj14);
IkReal x567=((1.0)*x564);
evalcond[0]=(((sj14*x564))+new_r20);
evalcond[1]=((((-1.0)*x565))+new_r10);
evalcond[2]=(new_r11+(((-1.0)*x567)));
evalcond[3]=(((cj14*x565))+new_r01);
evalcond[4]=(new_r21+(((-1.0)*x565*x566)));
evalcond[5]=((((-1.0)*cj14*x567))+new_r00);
evalcond[6]=(((cj14*new_r01))+x565+(((-1.0)*new_r21*x566)));
evalcond[7]=(((cj14*new_r00))+(((-1.0)*new_r20*x566))+(((-1.0)*x567)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(8);
vinfos[0].jointtype = 17;
vinfos[0].foffset = j5;
vinfos[0].indices[0] = _ij5[0];
vinfos[0].indices[1] = _ij5[1];
vinfos[0].maxsolutions = _nj5;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j9;
vinfos[1].indices[0] = _ij9[0];
vinfos[1].indices[1] = _ij9[1];
vinfos[1].maxsolutions = _nj9;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j10;
vinfos[2].indices[0] = _ij10[0];
vinfos[2].indices[1] = _ij10[1];
vinfos[2].maxsolutions = _nj10;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j11;
vinfos[3].indices[0] = _ij11[0];
vinfos[3].indices[1] = _ij11[1];
vinfos[3].maxsolutions = _nj11;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j12;
vinfos[4].indices[0] = _ij12[0];
vinfos[4].indices[1] = _ij12[1];
vinfos[4].maxsolutions = _nj12;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j13;
vinfos[5].indices[0] = _ij13[0];
vinfos[5].indices[1] = _ij13[1];
vinfos[5].maxsolutions = _nj13;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j14;
vinfos[6].indices[0] = _ij14[0];
vinfos[6].indices[1] = _ij14[1];
vinfos[6].maxsolutions = _nj14;
vinfos[7].jointtype = 1;
vinfos[7].foffset = j15;
vinfos[7].indices[0] = _ij15[0];
vinfos[7].indices[1] = _ij15[1];
vinfos[7].maxsolutions = _nj15;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((-3.14159265358979)+j13)))), 6.28318530717959)));
evalcond[1]=new_r12;
if( IKabs(evalcond[0]) < 0.0000050000000000  && IKabs(evalcond[1]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j15eval[3];
sj13=0;
cj13=-1.0;
j13=3.14159265358979;
j15eval[0]=sj14;
j15eval[1]=IKsign(sj14);
j15eval[2]=((IKabs(new_r20))+(IKabs(new_r21)));
if( IKabs(j15eval[0]) < 0.0000010000000000  || IKabs(j15eval[1]) < 0.0000010000000000  || IKabs(j15eval[2]) < 0.0000010000000000  )
{
{
IkReal j15eval[1];
sj13=0;
cj13=-1.0;
j13=3.14159265358979;
j15eval[0]=sj14;
if( IKabs(j15eval[0]) < 0.0000010000000000  )
{
{
IkReal j15eval[2];
sj13=0;
cj13=-1.0;
j13=3.14159265358979;
j15eval[0]=cj14;
j15eval[1]=sj14;
if( IKabs(j15eval[0]) < 0.0000010000000000  || IKabs(j15eval[1]) < 0.0000010000000000  )
{
{
IkReal evalcond[4];
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((-1.5707963267949)+j14)))), 6.28318530717959)));
evalcond[1]=new_r22;
evalcond[2]=new_r01;
evalcond[3]=new_r00;
if( IKabs(evalcond[0]) < 0.0000050000000000  && IKabs(evalcond[1]) < 0.0000050000000000  && IKabs(evalcond[2]) < 0.0000050000000000  && IKabs(evalcond[3]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j15array[1], cj15array[1], sj15array[1];
bool j15valid[1]={false};
_nj15 = 1;
if( IKabs(new_r21) < IKFAST_ATAN2_MAGTHRESH && IKabs(((-1.0)*new_r20)) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(new_r21)+IKsqr(((-1.0)*new_r20))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j15array[0]=IKatan2(new_r21, ((-1.0)*new_r20));
sj15array[0]=IKsin(j15array[0]);
cj15array[0]=IKcos(j15array[0]);
if( j15array[0] > IKPI )
{
    j15array[0]-=IK2PI;
}
else if( j15array[0] < -IKPI )
{    j15array[0]+=IK2PI;
}
j15valid[0] = true;
for(int ij15 = 0; ij15 < 1; ++ij15)
{
if( !j15valid[ij15] )
{
    continue;
}
_ij15[0] = ij15; _ij15[1] = -1;
for(int iij15 = ij15+1; iij15 < 1; ++iij15)
{
if( j15valid[iij15] && IKabs(cj15array[ij15]-cj15array[iij15]) < IKFAST_SOLUTION_THRESH && IKabs(sj15array[ij15]-sj15array[iij15]) < IKFAST_SOLUTION_THRESH )
{
    j15valid[iij15]=false; _ij15[1] = iij15; break; 
}
}
j15 = j15array[ij15]; cj15 = cj15array[ij15]; sj15 = sj15array[ij15];
{
IkReal evalcond[4];
IkReal x568=IKcos(j15);
IkReal x569=((1.0)*(IKsin(j15)));
evalcond[0]=(x568+new_r20);
evalcond[1]=(new_r21+(((-1.0)*x569)));
evalcond[2]=((((-1.0)*new_r10))+(((-1.0)*x569)));
evalcond[3]=((((-1.0)*x568))+(((-1.0)*new_r11)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(8);
vinfos[0].jointtype = 17;
vinfos[0].foffset = j5;
vinfos[0].indices[0] = _ij5[0];
vinfos[0].indices[1] = _ij5[1];
vinfos[0].maxsolutions = _nj5;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j9;
vinfos[1].indices[0] = _ij9[0];
vinfos[1].indices[1] = _ij9[1];
vinfos[1].maxsolutions = _nj9;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j10;
vinfos[2].indices[0] = _ij10[0];
vinfos[2].indices[1] = _ij10[1];
vinfos[2].maxsolutions = _nj10;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j11;
vinfos[3].indices[0] = _ij11[0];
vinfos[3].indices[1] = _ij11[1];
vinfos[3].maxsolutions = _nj11;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j12;
vinfos[4].indices[0] = _ij12[0];
vinfos[4].indices[1] = _ij12[1];
vinfos[4].maxsolutions = _nj12;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j13;
vinfos[5].indices[0] = _ij13[0];
vinfos[5].indices[1] = _ij13[1];
vinfos[5].maxsolutions = _nj13;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j14;
vinfos[6].indices[0] = _ij14[0];
vinfos[6].indices[1] = _ij14[1];
vinfos[6].maxsolutions = _nj14;
vinfos[7].jointtype = 1;
vinfos[7].foffset = j15;
vinfos[7].indices[0] = _ij15[0];
vinfos[7].indices[1] = _ij15[1];
vinfos[7].maxsolutions = _nj15;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((1.5707963267949)+j14)))), 6.28318530717959)));
evalcond[1]=new_r22;
evalcond[2]=new_r01;
evalcond[3]=new_r00;
if( IKabs(evalcond[0]) < 0.0000050000000000  && IKabs(evalcond[1]) < 0.0000050000000000  && IKabs(evalcond[2]) < 0.0000050000000000  && IKabs(evalcond[3]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j15array[1], cj15array[1], sj15array[1];
bool j15valid[1]={false};
_nj15 = 1;
if( IKabs(((-1.0)*new_r21)) < IKFAST_ATAN2_MAGTHRESH && IKabs(new_r20) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((-1.0)*new_r21))+IKsqr(new_r20)-1) <= IKFAST_SINCOS_THRESH )
    continue;
j15array[0]=IKatan2(((-1.0)*new_r21), new_r20);
sj15array[0]=IKsin(j15array[0]);
cj15array[0]=IKcos(j15array[0]);
if( j15array[0] > IKPI )
{
    j15array[0]-=IK2PI;
}
else if( j15array[0] < -IKPI )
{    j15array[0]+=IK2PI;
}
j15valid[0] = true;
for(int ij15 = 0; ij15 < 1; ++ij15)
{
if( !j15valid[ij15] )
{
    continue;
}
_ij15[0] = ij15; _ij15[1] = -1;
for(int iij15 = ij15+1; iij15 < 1; ++iij15)
{
if( j15valid[iij15] && IKabs(cj15array[ij15]-cj15array[iij15]) < IKFAST_SOLUTION_THRESH && IKabs(sj15array[ij15]-sj15array[iij15]) < IKFAST_SOLUTION_THRESH )
{
    j15valid[iij15]=false; _ij15[1] = iij15; break; 
}
}
j15 = j15array[ij15]; cj15 = cj15array[ij15]; sj15 = sj15array[ij15];
{
IkReal evalcond[4];
IkReal x570=IKsin(j15);
IkReal x571=((1.0)*(IKcos(j15)));
evalcond[0]=(x570+new_r21);
evalcond[1]=((((-1.0)*x571))+new_r20);
evalcond[2]=((((-1.0)*x570))+(((-1.0)*new_r10)));
evalcond[3]=((((-1.0)*x571))+(((-1.0)*new_r11)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(8);
vinfos[0].jointtype = 17;
vinfos[0].foffset = j5;
vinfos[0].indices[0] = _ij5[0];
vinfos[0].indices[1] = _ij5[1];
vinfos[0].maxsolutions = _nj5;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j9;
vinfos[1].indices[0] = _ij9[0];
vinfos[1].indices[1] = _ij9[1];
vinfos[1].maxsolutions = _nj9;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j10;
vinfos[2].indices[0] = _ij10[0];
vinfos[2].indices[1] = _ij10[1];
vinfos[2].maxsolutions = _nj10;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j11;
vinfos[3].indices[0] = _ij11[0];
vinfos[3].indices[1] = _ij11[1];
vinfos[3].maxsolutions = _nj11;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j12;
vinfos[4].indices[0] = _ij12[0];
vinfos[4].indices[1] = _ij12[1];
vinfos[4].maxsolutions = _nj12;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j13;
vinfos[5].indices[0] = _ij13[0];
vinfos[5].indices[1] = _ij13[1];
vinfos[5].maxsolutions = _nj13;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j14;
vinfos[6].indices[0] = _ij14[0];
vinfos[6].indices[1] = _ij14[1];
vinfos[6].maxsolutions = _nj14;
vinfos[7].jointtype = 1;
vinfos[7].foffset = j15;
vinfos[7].indices[0] = _ij15[0];
vinfos[7].indices[1] = _ij15[1];
vinfos[7].maxsolutions = _nj15;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(j14))), 6.28318530717959)));
evalcond[1]=new_r20;
evalcond[2]=new_r02;
evalcond[3]=new_r21;
if( IKabs(evalcond[0]) < 0.0000050000000000  && IKabs(evalcond[1]) < 0.0000050000000000  && IKabs(evalcond[2]) < 0.0000050000000000  && IKabs(evalcond[3]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j15array[1], cj15array[1], sj15array[1];
bool j15valid[1]={false};
_nj15 = 1;
if( IKabs(new_r01) < IKFAST_ATAN2_MAGTHRESH && IKabs(((-1.0)*new_r11)) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(new_r01)+IKsqr(((-1.0)*new_r11))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j15array[0]=IKatan2(new_r01, ((-1.0)*new_r11));
sj15array[0]=IKsin(j15array[0]);
cj15array[0]=IKcos(j15array[0]);
if( j15array[0] > IKPI )
{
    j15array[0]-=IK2PI;
}
else if( j15array[0] < -IKPI )
{    j15array[0]+=IK2PI;
}
j15valid[0] = true;
for(int ij15 = 0; ij15 < 1; ++ij15)
{
if( !j15valid[ij15] )
{
    continue;
}
_ij15[0] = ij15; _ij15[1] = -1;
for(int iij15 = ij15+1; iij15 < 1; ++iij15)
{
if( j15valid[iij15] && IKabs(cj15array[ij15]-cj15array[iij15]) < IKFAST_SOLUTION_THRESH && IKabs(sj15array[ij15]-sj15array[iij15]) < IKFAST_SOLUTION_THRESH )
{
    j15valid[iij15]=false; _ij15[1] = iij15; break; 
}
}
j15 = j15array[ij15]; cj15 = cj15array[ij15]; sj15 = sj15array[ij15];
{
IkReal evalcond[4];
IkReal x572=IKsin(j15);
IkReal x573=((1.0)*(IKcos(j15)));
evalcond[0]=(x572+(((-1.0)*new_r01)));
evalcond[1]=((((-1.0)*x572))+(((-1.0)*new_r10)));
evalcond[2]=((((-1.0)*x573))+(((-1.0)*new_r11)));
evalcond[3]=((((-1.0)*x573))+(((-1.0)*new_r00)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(8);
vinfos[0].jointtype = 17;
vinfos[0].foffset = j5;
vinfos[0].indices[0] = _ij5[0];
vinfos[0].indices[1] = _ij5[1];
vinfos[0].maxsolutions = _nj5;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j9;
vinfos[1].indices[0] = _ij9[0];
vinfos[1].indices[1] = _ij9[1];
vinfos[1].maxsolutions = _nj9;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j10;
vinfos[2].indices[0] = _ij10[0];
vinfos[2].indices[1] = _ij10[1];
vinfos[2].maxsolutions = _nj10;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j11;
vinfos[3].indices[0] = _ij11[0];
vinfos[3].indices[1] = _ij11[1];
vinfos[3].maxsolutions = _nj11;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j12;
vinfos[4].indices[0] = _ij12[0];
vinfos[4].indices[1] = _ij12[1];
vinfos[4].maxsolutions = _nj12;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j13;
vinfos[5].indices[0] = _ij13[0];
vinfos[5].indices[1] = _ij13[1];
vinfos[5].maxsolutions = _nj13;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j14;
vinfos[6].indices[0] = _ij14[0];
vinfos[6].indices[1] = _ij14[1];
vinfos[6].maxsolutions = _nj14;
vinfos[7].jointtype = 1;
vinfos[7].foffset = j15;
vinfos[7].indices[0] = _ij15[0];
vinfos[7].indices[1] = _ij15[1];
vinfos[7].maxsolutions = _nj15;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((-3.14159265358979)+j14)))), 6.28318530717959)));
evalcond[1]=new_r20;
evalcond[2]=new_r02;
evalcond[3]=new_r21;
if( IKabs(evalcond[0]) < 0.0000050000000000  && IKabs(evalcond[1]) < 0.0000050000000000  && IKabs(evalcond[2]) < 0.0000050000000000  && IKabs(evalcond[3]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j15array[1], cj15array[1], sj15array[1];
bool j15valid[1]={false};
_nj15 = 1;
if( IKabs(((-1.0)*new_r10)) < IKFAST_ATAN2_MAGTHRESH && IKabs(new_r00) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((-1.0)*new_r10))+IKsqr(new_r00)-1) <= IKFAST_SINCOS_THRESH )
    continue;
j15array[0]=IKatan2(((-1.0)*new_r10), new_r00);
sj15array[0]=IKsin(j15array[0]);
cj15array[0]=IKcos(j15array[0]);
if( j15array[0] > IKPI )
{
    j15array[0]-=IK2PI;
}
else if( j15array[0] < -IKPI )
{    j15array[0]+=IK2PI;
}
j15valid[0] = true;
for(int ij15 = 0; ij15 < 1; ++ij15)
{
if( !j15valid[ij15] )
{
    continue;
}
_ij15[0] = ij15; _ij15[1] = -1;
for(int iij15 = ij15+1; iij15 < 1; ++iij15)
{
if( j15valid[iij15] && IKabs(cj15array[ij15]-cj15array[iij15]) < IKFAST_SOLUTION_THRESH && IKabs(sj15array[ij15]-sj15array[iij15]) < IKFAST_SOLUTION_THRESH )
{
    j15valid[iij15]=false; _ij15[1] = iij15; break; 
}
}
j15 = j15array[ij15]; cj15 = cj15array[ij15]; sj15 = sj15array[ij15];
{
IkReal evalcond[4];
IkReal x574=IKcos(j15);
IkReal x575=((1.0)*(IKsin(j15)));
evalcond[0]=(x574+(((-1.0)*new_r00)));
evalcond[1]=((((-1.0)*x575))+(((-1.0)*new_r10)));
evalcond[2]=((((-1.0)*x574))+(((-1.0)*new_r11)));
evalcond[3]=((((-1.0)*x575))+(((-1.0)*new_r01)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(8);
vinfos[0].jointtype = 17;
vinfos[0].foffset = j5;
vinfos[0].indices[0] = _ij5[0];
vinfos[0].indices[1] = _ij5[1];
vinfos[0].maxsolutions = _nj5;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j9;
vinfos[1].indices[0] = _ij9[0];
vinfos[1].indices[1] = _ij9[1];
vinfos[1].maxsolutions = _nj9;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j10;
vinfos[2].indices[0] = _ij10[0];
vinfos[2].indices[1] = _ij10[1];
vinfos[2].maxsolutions = _nj10;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j11;
vinfos[3].indices[0] = _ij11[0];
vinfos[3].indices[1] = _ij11[1];
vinfos[3].maxsolutions = _nj11;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j12;
vinfos[4].indices[0] = _ij12[0];
vinfos[4].indices[1] = _ij12[1];
vinfos[4].maxsolutions = _nj12;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j13;
vinfos[5].indices[0] = _ij13[0];
vinfos[5].indices[1] = _ij13[1];
vinfos[5].maxsolutions = _nj13;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j14;
vinfos[6].indices[0] = _ij14[0];
vinfos[6].indices[1] = _ij14[1];
vinfos[6].maxsolutions = _nj14;
vinfos[7].jointtype = 1;
vinfos[7].foffset = j15;
vinfos[7].indices[0] = _ij15[0];
vinfos[7].indices[1] = _ij15[1];
vinfos[7].maxsolutions = _nj15;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((IKabs(new_r20))+(IKabs(new_r21)));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j15array[1], cj15array[1], sj15array[1];
bool j15valid[1]={false};
_nj15 = 1;
if( IKabs(((-1.0)*new_r10)) < IKFAST_ATAN2_MAGTHRESH && IKabs(((-1.0)*new_r11)) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((-1.0)*new_r10))+IKsqr(((-1.0)*new_r11))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j15array[0]=IKatan2(((-1.0)*new_r10), ((-1.0)*new_r11));
sj15array[0]=IKsin(j15array[0]);
cj15array[0]=IKcos(j15array[0]);
if( j15array[0] > IKPI )
{
    j15array[0]-=IK2PI;
}
else if( j15array[0] < -IKPI )
{    j15array[0]+=IK2PI;
}
j15valid[0] = true;
for(int ij15 = 0; ij15 < 1; ++ij15)
{
if( !j15valid[ij15] )
{
    continue;
}
_ij15[0] = ij15; _ij15[1] = -1;
for(int iij15 = ij15+1; iij15 < 1; ++iij15)
{
if( j15valid[iij15] && IKabs(cj15array[ij15]-cj15array[iij15]) < IKFAST_SOLUTION_THRESH && IKabs(sj15array[ij15]-sj15array[iij15]) < IKFAST_SOLUTION_THRESH )
{
    j15valid[iij15]=false; _ij15[1] = iij15; break; 
}
}
j15 = j15array[ij15]; cj15 = cj15array[ij15]; sj15 = sj15array[ij15];
{
IkReal evalcond[6];
IkReal x576=IKsin(j15);
IkReal x577=IKcos(j15);
IkReal x578=((-1.0)*x577);
evalcond[0]=x576;
evalcond[1]=(new_r22*x576);
evalcond[2]=x578;
evalcond[3]=(new_r22*x578);
evalcond[4]=((((-1.0)*x576))+(((-1.0)*new_r10)));
evalcond[5]=((((-1.0)*x577))+(((-1.0)*new_r11)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(8);
vinfos[0].jointtype = 17;
vinfos[0].foffset = j5;
vinfos[0].indices[0] = _ij5[0];
vinfos[0].indices[1] = _ij5[1];
vinfos[0].maxsolutions = _nj5;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j9;
vinfos[1].indices[0] = _ij9[0];
vinfos[1].indices[1] = _ij9[1];
vinfos[1].maxsolutions = _nj9;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j10;
vinfos[2].indices[0] = _ij10[0];
vinfos[2].indices[1] = _ij10[1];
vinfos[2].maxsolutions = _nj10;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j11;
vinfos[3].indices[0] = _ij11[0];
vinfos[3].indices[1] = _ij11[1];
vinfos[3].maxsolutions = _nj11;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j12;
vinfos[4].indices[0] = _ij12[0];
vinfos[4].indices[1] = _ij12[1];
vinfos[4].maxsolutions = _nj12;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j13;
vinfos[5].indices[0] = _ij13[0];
vinfos[5].indices[1] = _ij13[1];
vinfos[5].maxsolutions = _nj13;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j14;
vinfos[6].indices[0] = _ij14[0];
vinfos[6].indices[1] = _ij14[1];
vinfos[6].maxsolutions = _nj14;
vinfos[7].jointtype = 1;
vinfos[7].foffset = j15;
vinfos[7].indices[0] = _ij15[0];
vinfos[7].indices[1] = _ij15[1];
vinfos[7].maxsolutions = _nj15;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
if( 1 )
{
bgotonextstatement=false;
continue; // branch miss [j15]

}
} while(0);
if( bgotonextstatement )
{
}
}
}
}
}
}
}

} else
{
{
IkReal j15array[1], cj15array[1], sj15array[1];
bool j15valid[1]={false};
_nj15 = 1;
CheckValue<IkReal> x579=IKPowWithIntegerCheck(cj14,-1);
if(!x579.valid){
continue;
}
CheckValue<IkReal> x580=IKPowWithIntegerCheck(sj14,-1);
if(!x580.valid){
continue;
}
if( IKabs((new_r01*(x579.value))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((-1.0)*new_r20*(x580.value))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr((new_r01*(x579.value)))+IKsqr(((-1.0)*new_r20*(x580.value)))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j15array[0]=IKatan2((new_r01*(x579.value)), ((-1.0)*new_r20*(x580.value)));
sj15array[0]=IKsin(j15array[0]);
cj15array[0]=IKcos(j15array[0]);
if( j15array[0] > IKPI )
{
    j15array[0]-=IK2PI;
}
else if( j15array[0] < -IKPI )
{    j15array[0]+=IK2PI;
}
j15valid[0] = true;
for(int ij15 = 0; ij15 < 1; ++ij15)
{
if( !j15valid[ij15] )
{
    continue;
}
_ij15[0] = ij15; _ij15[1] = -1;
for(int iij15 = ij15+1; iij15 < 1; ++iij15)
{
if( j15valid[iij15] && IKabs(cj15array[ij15]-cj15array[iij15]) < IKFAST_SOLUTION_THRESH && IKabs(sj15array[ij15]-sj15array[iij15]) < IKFAST_SOLUTION_THRESH )
{
    j15valid[iij15]=false; _ij15[1] = iij15; break; 
}
}
j15 = j15array[ij15]; cj15 = cj15array[ij15]; sj15 = sj15array[ij15];
{
IkReal evalcond[8];
IkReal x581=IKsin(j15);
IkReal x582=IKcos(j15);
IkReal x583=((1.0)*new_r00);
IkReal x584=((1.0)*sj14);
IkReal x585=((1.0)*new_r01);
IkReal x586=((1.0)*x582);
evalcond[0]=(((sj14*x582))+new_r20);
evalcond[1]=(new_r21+(((-1.0)*x581*x584)));
evalcond[2]=((((-1.0)*x581))+(((-1.0)*new_r10)));
evalcond[3]=((((-1.0)*new_r11))+(((-1.0)*x586)));
evalcond[4]=((((-1.0)*x585))+((cj14*x581)));
evalcond[5]=((((-1.0)*cj14*x586))+(((-1.0)*x583)));
evalcond[6]=((((-1.0)*cj14*x585))+(((-1.0)*new_r21*x584))+x581);
evalcond[7]=((((-1.0)*cj14*x583))+(((-1.0)*new_r20*x584))+(((-1.0)*x586)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(8);
vinfos[0].jointtype = 17;
vinfos[0].foffset = j5;
vinfos[0].indices[0] = _ij5[0];
vinfos[0].indices[1] = _ij5[1];
vinfos[0].maxsolutions = _nj5;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j9;
vinfos[1].indices[0] = _ij9[0];
vinfos[1].indices[1] = _ij9[1];
vinfos[1].maxsolutions = _nj9;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j10;
vinfos[2].indices[0] = _ij10[0];
vinfos[2].indices[1] = _ij10[1];
vinfos[2].maxsolutions = _nj10;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j11;
vinfos[3].indices[0] = _ij11[0];
vinfos[3].indices[1] = _ij11[1];
vinfos[3].maxsolutions = _nj11;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j12;
vinfos[4].indices[0] = _ij12[0];
vinfos[4].indices[1] = _ij12[1];
vinfos[4].maxsolutions = _nj12;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j13;
vinfos[5].indices[0] = _ij13[0];
vinfos[5].indices[1] = _ij13[1];
vinfos[5].maxsolutions = _nj13;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j14;
vinfos[6].indices[0] = _ij14[0];
vinfos[6].indices[1] = _ij14[1];
vinfos[6].maxsolutions = _nj14;
vinfos[7].jointtype = 1;
vinfos[7].foffset = j15;
vinfos[7].indices[0] = _ij15[0];
vinfos[7].indices[1] = _ij15[1];
vinfos[7].maxsolutions = _nj15;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

} else
{
{
IkReal j15array[1], cj15array[1], sj15array[1];
bool j15valid[1]={false};
_nj15 = 1;
CheckValue<IkReal> x587=IKPowWithIntegerCheck(sj14,-1);
if(!x587.valid){
continue;
}
if( IKabs((new_r21*(x587.value))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((-1.0)*new_r11)) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr((new_r21*(x587.value)))+IKsqr(((-1.0)*new_r11))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j15array[0]=IKatan2((new_r21*(x587.value)), ((-1.0)*new_r11));
sj15array[0]=IKsin(j15array[0]);
cj15array[0]=IKcos(j15array[0]);
if( j15array[0] > IKPI )
{
    j15array[0]-=IK2PI;
}
else if( j15array[0] < -IKPI )
{    j15array[0]+=IK2PI;
}
j15valid[0] = true;
for(int ij15 = 0; ij15 < 1; ++ij15)
{
if( !j15valid[ij15] )
{
    continue;
}
_ij15[0] = ij15; _ij15[1] = -1;
for(int iij15 = ij15+1; iij15 < 1; ++iij15)
{
if( j15valid[iij15] && IKabs(cj15array[ij15]-cj15array[iij15]) < IKFAST_SOLUTION_THRESH && IKabs(sj15array[ij15]-sj15array[iij15]) < IKFAST_SOLUTION_THRESH )
{
    j15valid[iij15]=false; _ij15[1] = iij15; break; 
}
}
j15 = j15array[ij15]; cj15 = cj15array[ij15]; sj15 = sj15array[ij15];
{
IkReal evalcond[8];
IkReal x588=IKsin(j15);
IkReal x589=IKcos(j15);
IkReal x590=((1.0)*new_r00);
IkReal x591=((1.0)*sj14);
IkReal x592=((1.0)*new_r01);
IkReal x593=((1.0)*x589);
evalcond[0]=(((sj14*x589))+new_r20);
evalcond[1]=((((-1.0)*x588*x591))+new_r21);
evalcond[2]=((((-1.0)*x588))+(((-1.0)*new_r10)));
evalcond[3]=((((-1.0)*x593))+(((-1.0)*new_r11)));
evalcond[4]=((((-1.0)*x592))+((cj14*x588)));
evalcond[5]=((((-1.0)*x590))+(((-1.0)*cj14*x593)));
evalcond[6]=((((-1.0)*new_r21*x591))+(((-1.0)*cj14*x592))+x588);
evalcond[7]=((((-1.0)*new_r20*x591))+(((-1.0)*x593))+(((-1.0)*cj14*x590)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(8);
vinfos[0].jointtype = 17;
vinfos[0].foffset = j5;
vinfos[0].indices[0] = _ij5[0];
vinfos[0].indices[1] = _ij5[1];
vinfos[0].maxsolutions = _nj5;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j9;
vinfos[1].indices[0] = _ij9[0];
vinfos[1].indices[1] = _ij9[1];
vinfos[1].maxsolutions = _nj9;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j10;
vinfos[2].indices[0] = _ij10[0];
vinfos[2].indices[1] = _ij10[1];
vinfos[2].maxsolutions = _nj10;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j11;
vinfos[3].indices[0] = _ij11[0];
vinfos[3].indices[1] = _ij11[1];
vinfos[3].maxsolutions = _nj11;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j12;
vinfos[4].indices[0] = _ij12[0];
vinfos[4].indices[1] = _ij12[1];
vinfos[4].maxsolutions = _nj12;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j13;
vinfos[5].indices[0] = _ij13[0];
vinfos[5].indices[1] = _ij13[1];
vinfos[5].maxsolutions = _nj13;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j14;
vinfos[6].indices[0] = _ij14[0];
vinfos[6].indices[1] = _ij14[1];
vinfos[6].maxsolutions = _nj14;
vinfos[7].jointtype = 1;
vinfos[7].foffset = j15;
vinfos[7].indices[0] = _ij15[0];
vinfos[7].indices[1] = _ij15[1];
vinfos[7].maxsolutions = _nj15;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

} else
{
{
IkReal j15array[1], cj15array[1], sj15array[1];
bool j15valid[1]={false};
_nj15 = 1;
CheckValue<IkReal> x594=IKPowWithIntegerCheck(IKsign(sj14),-1);
if(!x594.valid){
continue;
}
CheckValue<IkReal> x595 = IKatan2WithCheck(IkReal(new_r21),IkReal(((-1.0)*new_r20)),IKFAST_ATAN2_MAGTHRESH);
if(!x595.valid){
continue;
}
j15array[0]=((-1.5707963267949)+(((1.5707963267949)*(x594.value)))+(x595.value));
sj15array[0]=IKsin(j15array[0]);
cj15array[0]=IKcos(j15array[0]);
if( j15array[0] > IKPI )
{
    j15array[0]-=IK2PI;
}
else if( j15array[0] < -IKPI )
{    j15array[0]+=IK2PI;
}
j15valid[0] = true;
for(int ij15 = 0; ij15 < 1; ++ij15)
{
if( !j15valid[ij15] )
{
    continue;
}
_ij15[0] = ij15; _ij15[1] = -1;
for(int iij15 = ij15+1; iij15 < 1; ++iij15)
{
if( j15valid[iij15] && IKabs(cj15array[ij15]-cj15array[iij15]) < IKFAST_SOLUTION_THRESH && IKabs(sj15array[ij15]-sj15array[iij15]) < IKFAST_SOLUTION_THRESH )
{
    j15valid[iij15]=false; _ij15[1] = iij15; break; 
}
}
j15 = j15array[ij15]; cj15 = cj15array[ij15]; sj15 = sj15array[ij15];
{
IkReal evalcond[8];
IkReal x596=IKsin(j15);
IkReal x597=IKcos(j15);
IkReal x598=((1.0)*new_r00);
IkReal x599=((1.0)*sj14);
IkReal x600=((1.0)*new_r01);
IkReal x601=((1.0)*x597);
evalcond[0]=(new_r20+((sj14*x597)));
evalcond[1]=((((-1.0)*x596*x599))+new_r21);
evalcond[2]=((((-1.0)*x596))+(((-1.0)*new_r10)));
evalcond[3]=((((-1.0)*new_r11))+(((-1.0)*x601)));
evalcond[4]=(((cj14*x596))+(((-1.0)*x600)));
evalcond[5]=((((-1.0)*x598))+(((-1.0)*cj14*x601)));
evalcond[6]=((((-1.0)*new_r21*x599))+x596+(((-1.0)*cj14*x600)));
evalcond[7]=((((-1.0)*new_r20*x599))+(((-1.0)*cj14*x598))+(((-1.0)*x601)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(8);
vinfos[0].jointtype = 17;
vinfos[0].foffset = j5;
vinfos[0].indices[0] = _ij5[0];
vinfos[0].indices[1] = _ij5[1];
vinfos[0].maxsolutions = _nj5;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j9;
vinfos[1].indices[0] = _ij9[0];
vinfos[1].indices[1] = _ij9[1];
vinfos[1].maxsolutions = _nj9;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j10;
vinfos[2].indices[0] = _ij10[0];
vinfos[2].indices[1] = _ij10[1];
vinfos[2].maxsolutions = _nj10;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j11;
vinfos[3].indices[0] = _ij11[0];
vinfos[3].indices[1] = _ij11[1];
vinfos[3].maxsolutions = _nj11;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j12;
vinfos[4].indices[0] = _ij12[0];
vinfos[4].indices[1] = _ij12[1];
vinfos[4].maxsolutions = _nj12;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j13;
vinfos[5].indices[0] = _ij13[0];
vinfos[5].indices[1] = _ij13[1];
vinfos[5].maxsolutions = _nj13;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j14;
vinfos[6].indices[0] = _ij14[0];
vinfos[6].indices[1] = _ij14[1];
vinfos[6].maxsolutions = _nj14;
vinfos[7].jointtype = 1;
vinfos[7].foffset = j15;
vinfos[7].indices[0] = _ij15[0];
vinfos[7].indices[1] = _ij15[1];
vinfos[7].maxsolutions = _nj15;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(j14))), 6.28318530717959)));
evalcond[1]=new_r20;
evalcond[2]=new_r02;
evalcond[3]=new_r12;
evalcond[4]=new_r21;
if( IKabs(evalcond[0]) < 0.0000050000000000  && IKabs(evalcond[1]) < 0.0000050000000000  && IKabs(evalcond[2]) < 0.0000050000000000  && IKabs(evalcond[3]) < 0.0000050000000000  && IKabs(evalcond[4]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j15array[1], cj15array[1], sj15array[1];
bool j15valid[1]={false};
_nj15 = 1;
IkReal x602=((1.0)*new_r01);
if( IKabs(((((-1.0)*cj13*x602))+(((-1.0)*new_r00*sj13)))) < IKFAST_ATAN2_MAGTHRESH && IKabs((((cj13*new_r00))+(((-1.0)*sj13*x602)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((((-1.0)*cj13*x602))+(((-1.0)*new_r00*sj13))))+IKsqr((((cj13*new_r00))+(((-1.0)*sj13*x602))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j15array[0]=IKatan2(((((-1.0)*cj13*x602))+(((-1.0)*new_r00*sj13))), (((cj13*new_r00))+(((-1.0)*sj13*x602))));
sj15array[0]=IKsin(j15array[0]);
cj15array[0]=IKcos(j15array[0]);
if( j15array[0] > IKPI )
{
    j15array[0]-=IK2PI;
}
else if( j15array[0] < -IKPI )
{    j15array[0]+=IK2PI;
}
j15valid[0] = true;
for(int ij15 = 0; ij15 < 1; ++ij15)
{
if( !j15valid[ij15] )
{
    continue;
}
_ij15[0] = ij15; _ij15[1] = -1;
for(int iij15 = ij15+1; iij15 < 1; ++iij15)
{
if( j15valid[iij15] && IKabs(cj15array[ij15]-cj15array[iij15]) < IKFAST_SOLUTION_THRESH && IKabs(sj15array[ij15]-sj15array[iij15]) < IKFAST_SOLUTION_THRESH )
{
    j15valid[iij15]=false; _ij15[1] = iij15; break; 
}
}
j15 = j15array[ij15]; cj15 = cj15array[ij15]; sj15 = sj15array[ij15];
{
IkReal evalcond[8];
IkReal x603=IKsin(j15);
IkReal x604=IKcos(j15);
IkReal x605=((1.0)*cj13);
IkReal x606=((1.0)*sj13);
IkReal x607=((1.0)*x604);
IkReal x608=(sj13*x603);
IkReal x609=(x604*x605);
evalcond[0]=(((cj13*new_r01))+x603+((new_r11*sj13)));
evalcond[1]=(((sj13*x604))+((cj13*x603))+new_r01);
evalcond[2]=(((cj13*new_r00))+(((-1.0)*x607))+((new_r10*sj13)));
evalcond[3]=(((cj13*new_r10))+(((-1.0)*x603))+(((-1.0)*new_r00*x606)));
evalcond[4]=(((cj13*new_r11))+(((-1.0)*x607))+(((-1.0)*new_r01*x606)));
evalcond[5]=(x608+(((-1.0)*x609))+new_r00);
evalcond[6]=(x608+(((-1.0)*x609))+new_r11);
evalcond[7]=((((-1.0)*x603*x605))+(((-1.0)*x604*x606))+new_r10);
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(8);
vinfos[0].jointtype = 17;
vinfos[0].foffset = j5;
vinfos[0].indices[0] = _ij5[0];
vinfos[0].indices[1] = _ij5[1];
vinfos[0].maxsolutions = _nj5;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j9;
vinfos[1].indices[0] = _ij9[0];
vinfos[1].indices[1] = _ij9[1];
vinfos[1].maxsolutions = _nj9;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j10;
vinfos[2].indices[0] = _ij10[0];
vinfos[2].indices[1] = _ij10[1];
vinfos[2].maxsolutions = _nj10;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j11;
vinfos[3].indices[0] = _ij11[0];
vinfos[3].indices[1] = _ij11[1];
vinfos[3].maxsolutions = _nj11;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j12;
vinfos[4].indices[0] = _ij12[0];
vinfos[4].indices[1] = _ij12[1];
vinfos[4].maxsolutions = _nj12;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j13;
vinfos[5].indices[0] = _ij13[0];
vinfos[5].indices[1] = _ij13[1];
vinfos[5].maxsolutions = _nj13;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j14;
vinfos[6].indices[0] = _ij14[0];
vinfos[6].indices[1] = _ij14[1];
vinfos[6].maxsolutions = _nj14;
vinfos[7].jointtype = 1;
vinfos[7].foffset = j15;
vinfos[7].indices[0] = _ij15[0];
vinfos[7].indices[1] = _ij15[1];
vinfos[7].maxsolutions = _nj15;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((-3.14159265358979)+j14)))), 6.28318530717959)));
evalcond[1]=new_r20;
evalcond[2]=new_r02;
evalcond[3]=new_r12;
evalcond[4]=new_r21;
if( IKabs(evalcond[0]) < 0.0000050000000000  && IKabs(evalcond[1]) < 0.0000050000000000  && IKabs(evalcond[2]) < 0.0000050000000000  && IKabs(evalcond[3]) < 0.0000050000000000  && IKabs(evalcond[4]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j15array[1], cj15array[1], sj15array[1];
bool j15valid[1]={false};
_nj15 = 1;
IkReal x610=((1.0)*new_r00);
if( IKabs((((cj13*new_r01))+(((-1.0)*sj13*x610)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((((-1.0)*cj13*x610))+(((-1.0)*new_r01*sj13)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr((((cj13*new_r01))+(((-1.0)*sj13*x610))))+IKsqr(((((-1.0)*cj13*x610))+(((-1.0)*new_r01*sj13))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j15array[0]=IKatan2((((cj13*new_r01))+(((-1.0)*sj13*x610))), ((((-1.0)*cj13*x610))+(((-1.0)*new_r01*sj13))));
sj15array[0]=IKsin(j15array[0]);
cj15array[0]=IKcos(j15array[0]);
if( j15array[0] > IKPI )
{
    j15array[0]-=IK2PI;
}
else if( j15array[0] < -IKPI )
{    j15array[0]+=IK2PI;
}
j15valid[0] = true;
for(int ij15 = 0; ij15 < 1; ++ij15)
{
if( !j15valid[ij15] )
{
    continue;
}
_ij15[0] = ij15; _ij15[1] = -1;
for(int iij15 = ij15+1; iij15 < 1; ++iij15)
{
if( j15valid[iij15] && IKabs(cj15array[ij15]-cj15array[iij15]) < IKFAST_SOLUTION_THRESH && IKabs(sj15array[ij15]-sj15array[iij15]) < IKFAST_SOLUTION_THRESH )
{
    j15valid[iij15]=false; _ij15[1] = iij15; break; 
}
}
j15 = j15array[ij15]; cj15 = cj15array[ij15]; sj15 = sj15array[ij15];
{
IkReal evalcond[8];
IkReal x611=IKsin(j15);
IkReal x612=IKcos(j15);
IkReal x613=((1.0)*cj13);
IkReal x614=((1.0)*sj13);
IkReal x615=((1.0)*x611);
IkReal x616=(sj13*x612);
IkReal x617=(x611*x613);
evalcond[0]=(((cj13*new_r00))+x612+((new_r10*sj13)));
evalcond[1]=(((cj13*new_r01))+(((-1.0)*x615))+((new_r11*sj13)));
evalcond[2]=(((sj13*x611))+new_r00+((cj13*x612)));
evalcond[3]=(((cj13*new_r10))+(((-1.0)*x615))+(((-1.0)*new_r00*x614)));
evalcond[4]=(((cj13*new_r11))+(((-1.0)*x612))+(((-1.0)*new_r01*x614)));
evalcond[5]=((((-1.0)*x617))+x616+new_r01);
evalcond[6]=((((-1.0)*x617))+x616+new_r10);
evalcond[7]=((((-1.0)*x612*x613))+(((-1.0)*x611*x614))+new_r11);
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(8);
vinfos[0].jointtype = 17;
vinfos[0].foffset = j5;
vinfos[0].indices[0] = _ij5[0];
vinfos[0].indices[1] = _ij5[1];
vinfos[0].maxsolutions = _nj5;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j9;
vinfos[1].indices[0] = _ij9[0];
vinfos[1].indices[1] = _ij9[1];
vinfos[1].maxsolutions = _nj9;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j10;
vinfos[2].indices[0] = _ij10[0];
vinfos[2].indices[1] = _ij10[1];
vinfos[2].maxsolutions = _nj10;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j11;
vinfos[3].indices[0] = _ij11[0];
vinfos[3].indices[1] = _ij11[1];
vinfos[3].maxsolutions = _nj11;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j12;
vinfos[4].indices[0] = _ij12[0];
vinfos[4].indices[1] = _ij12[1];
vinfos[4].maxsolutions = _nj12;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j13;
vinfos[5].indices[0] = _ij13[0];
vinfos[5].indices[1] = _ij13[1];
vinfos[5].maxsolutions = _nj13;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j14;
vinfos[6].indices[0] = _ij14[0];
vinfos[6].indices[1] = _ij14[1];
vinfos[6].maxsolutions = _nj14;
vinfos[7].jointtype = 1;
vinfos[7].foffset = j15;
vinfos[7].indices[0] = _ij15[0];
vinfos[7].indices[1] = _ij15[1];
vinfos[7].maxsolutions = _nj15;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((IKabs(new_r20))+(IKabs(new_r21)));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j15eval[1];
new_r21=0;
new_r20=0;
new_r02=0;
new_r12=0;
j15eval[0]=1.0;
if( IKabs(j15eval[0]) < 0.0000000100000000  )
{
continue; // no branches [j15]

} else
{
IkReal op[2+1], zeror[2];
int numroots;
op[0]=1.0;
op[1]=0;
op[2]=-1.0;
polyroots2(op,zeror,numroots);
IkReal j15array[2], cj15array[2], sj15array[2], tempj15array[1];
int numsolutions = 0;
for(int ij15 = 0; ij15 < numroots; ++ij15)
{
IkReal htj15 = zeror[ij15];
tempj15array[0]=((2.0)*(atan(htj15)));
for(int kj15 = 0; kj15 < 1; ++kj15)
{
j15array[numsolutions] = tempj15array[kj15];
if( j15array[numsolutions] > IKPI )
{
    j15array[numsolutions]-=IK2PI;
}
else if( j15array[numsolutions] < -IKPI )
{
    j15array[numsolutions]+=IK2PI;
}
sj15array[numsolutions] = IKsin(j15array[numsolutions]);
cj15array[numsolutions] = IKcos(j15array[numsolutions]);
numsolutions++;
}
}
bool j15valid[2]={true,true};
_nj15 = 2;
for(int ij15 = 0; ij15 < numsolutions; ++ij15)
    {
if( !j15valid[ij15] )
{
    continue;
}
    j15 = j15array[ij15]; cj15 = cj15array[ij15]; sj15 = sj15array[ij15];
htj15 = IKtan(j15/2);

_ij15[0] = ij15; _ij15[1] = -1;
for(int iij15 = ij15+1; iij15 < numsolutions; ++iij15)
{
if( j15valid[iij15] && IKabs(cj15array[ij15]-cj15array[iij15]) < IKFAST_SOLUTION_THRESH && IKabs(sj15array[ij15]-sj15array[iij15]) < IKFAST_SOLUTION_THRESH )
{
    j15valid[iij15]=false; _ij15[1] = iij15; break; 
}
}
{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(8);
vinfos[0].jointtype = 17;
vinfos[0].foffset = j5;
vinfos[0].indices[0] = _ij5[0];
vinfos[0].indices[1] = _ij5[1];
vinfos[0].maxsolutions = _nj5;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j9;
vinfos[1].indices[0] = _ij9[0];
vinfos[1].indices[1] = _ij9[1];
vinfos[1].maxsolutions = _nj9;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j10;
vinfos[2].indices[0] = _ij10[0];
vinfos[2].indices[1] = _ij10[1];
vinfos[2].maxsolutions = _nj10;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j11;
vinfos[3].indices[0] = _ij11[0];
vinfos[3].indices[1] = _ij11[1];
vinfos[3].maxsolutions = _nj11;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j12;
vinfos[4].indices[0] = _ij12[0];
vinfos[4].indices[1] = _ij12[1];
vinfos[4].maxsolutions = _nj12;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j13;
vinfos[5].indices[0] = _ij13[0];
vinfos[5].indices[1] = _ij13[1];
vinfos[5].maxsolutions = _nj13;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j14;
vinfos[6].indices[0] = _ij14[0];
vinfos[6].indices[1] = _ij14[1];
vinfos[6].maxsolutions = _nj14;
vinfos[7].jointtype = 1;
vinfos[7].foffset = j15;
vinfos[7].indices[0] = _ij15[0];
vinfos[7].indices[1] = _ij15[1];
vinfos[7].maxsolutions = _nj15;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
    }

}

}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
if( 1 )
{
bgotonextstatement=false;
continue; // branch miss [j15]

}
} while(0);
if( bgotonextstatement )
{
}
}
}
}
}
}
}
}
}

} else
{
{
IkReal j15array[1], cj15array[1], sj15array[1];
bool j15valid[1]={false};
_nj15 = 1;
CheckValue<IkReal> x619=IKPowWithIntegerCheck(sj14,-1);
if(!x619.valid){
continue;
}
IkReal x618=x619.value;
CheckValue<IkReal> x620=IKPowWithIntegerCheck(cj14,-1);
if(!x620.valid){
continue;
}
CheckValue<IkReal> x621=IKPowWithIntegerCheck(sj13,-1);
if(!x621.valid){
continue;
}
if( IKabs((x618*(x620.value)*(x621.value)*(((((-1.0)*cj13*new_r20))+(((-1.0)*new_r11*sj14)))))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((-1.0)*new_r20*x618)) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr((x618*(x620.value)*(x621.value)*(((((-1.0)*cj13*new_r20))+(((-1.0)*new_r11*sj14))))))+IKsqr(((-1.0)*new_r20*x618))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j15array[0]=IKatan2((x618*(x620.value)*(x621.value)*(((((-1.0)*cj13*new_r20))+(((-1.0)*new_r11*sj14))))), ((-1.0)*new_r20*x618));
sj15array[0]=IKsin(j15array[0]);
cj15array[0]=IKcos(j15array[0]);
if( j15array[0] > IKPI )
{
    j15array[0]-=IK2PI;
}
else if( j15array[0] < -IKPI )
{    j15array[0]+=IK2PI;
}
j15valid[0] = true;
for(int ij15 = 0; ij15 < 1; ++ij15)
{
if( !j15valid[ij15] )
{
    continue;
}
_ij15[0] = ij15; _ij15[1] = -1;
for(int iij15 = ij15+1; iij15 < 1; ++iij15)
{
if( j15valid[iij15] && IKabs(cj15array[ij15]-cj15array[iij15]) < IKFAST_SOLUTION_THRESH && IKabs(sj15array[ij15]-sj15array[iij15]) < IKFAST_SOLUTION_THRESH )
{
    j15valid[iij15]=false; _ij15[1] = iij15; break; 
}
}
j15 = j15array[ij15]; cj15 = cj15array[ij15]; sj15 = sj15array[ij15];
{
IkReal evalcond[12];
IkReal x622=IKsin(j15);
IkReal x623=IKcos(j15);
IkReal x624=(cj13*cj14);
IkReal x625=((1.0)*sj14);
IkReal x626=(cj14*sj13);
IkReal x627=((1.0)*sj13);
IkReal x628=((1.0)*x623);
IkReal x629=((1.0)*x622);
evalcond[0]=(new_r20+((sj14*x623)));
evalcond[1]=((((-1.0)*x622*x625))+new_r21);
evalcond[2]=(((cj13*new_r01))+((new_r11*sj13))+((cj14*x622)));
evalcond[3]=((((-1.0)*new_r00*x627))+((cj13*new_r10))+(((-1.0)*x629)));
evalcond[4]=((((-1.0)*new_r01*x627))+((cj13*new_r11))+(((-1.0)*x628)));
evalcond[5]=(new_r01+((sj13*x623))+((x622*x624)));
evalcond[6]=(((cj13*new_r00))+(((-1.0)*cj14*x628))+((new_r10*sj13)));
evalcond[7]=((((-1.0)*x624*x628))+new_r00+((sj13*x622)));
evalcond[8]=(new_r11+(((-1.0)*cj13*x628))+((x622*x626)));
evalcond[9]=((((-1.0)*x626*x628))+new_r10+(((-1.0)*cj13*x629)));
evalcond[10]=(((new_r01*x624))+(((-1.0)*new_r21*x625))+((new_r11*x626))+x622);
evalcond[11]=((((-1.0)*x628))+((new_r00*x624))+((new_r10*x626))+(((-1.0)*new_r20*x625)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[8]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[9]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[10]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[11]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(8);
vinfos[0].jointtype = 17;
vinfos[0].foffset = j5;
vinfos[0].indices[0] = _ij5[0];
vinfos[0].indices[1] = _ij5[1];
vinfos[0].maxsolutions = _nj5;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j9;
vinfos[1].indices[0] = _ij9[0];
vinfos[1].indices[1] = _ij9[1];
vinfos[1].maxsolutions = _nj9;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j10;
vinfos[2].indices[0] = _ij10[0];
vinfos[2].indices[1] = _ij10[1];
vinfos[2].maxsolutions = _nj10;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j11;
vinfos[3].indices[0] = _ij11[0];
vinfos[3].indices[1] = _ij11[1];
vinfos[3].maxsolutions = _nj11;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j12;
vinfos[4].indices[0] = _ij12[0];
vinfos[4].indices[1] = _ij12[1];
vinfos[4].maxsolutions = _nj12;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j13;
vinfos[5].indices[0] = _ij13[0];
vinfos[5].indices[1] = _ij13[1];
vinfos[5].maxsolutions = _nj13;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j14;
vinfos[6].indices[0] = _ij14[0];
vinfos[6].indices[1] = _ij14[1];
vinfos[6].maxsolutions = _nj14;
vinfos[7].jointtype = 1;
vinfos[7].foffset = j15;
vinfos[7].indices[0] = _ij15[0];
vinfos[7].indices[1] = _ij15[1];
vinfos[7].maxsolutions = _nj15;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

} else
{
{
IkReal j15array[1], cj15array[1], sj15array[1];
bool j15valid[1]={false};
_nj15 = 1;
CheckValue<IkReal> x631=IKPowWithIntegerCheck(sj14,-1);
if(!x631.valid){
continue;
}
IkReal x630=x631.value;
CheckValue<IkReal> x632=IKPowWithIntegerCheck(sj13,-1);
if(!x632.valid){
continue;
}
if( IKabs((new_r21*x630)) < IKFAST_ATAN2_MAGTHRESH && IKabs((x630*(x632.value)*(((((-1.0)*cj13*cj14*new_r21))+(((-1.0)*new_r01*sj14)))))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr((new_r21*x630))+IKsqr((x630*(x632.value)*(((((-1.0)*cj13*cj14*new_r21))+(((-1.0)*new_r01*sj14))))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j15array[0]=IKatan2((new_r21*x630), (x630*(x632.value)*(((((-1.0)*cj13*cj14*new_r21))+(((-1.0)*new_r01*sj14))))));
sj15array[0]=IKsin(j15array[0]);
cj15array[0]=IKcos(j15array[0]);
if( j15array[0] > IKPI )
{
    j15array[0]-=IK2PI;
}
else if( j15array[0] < -IKPI )
{    j15array[0]+=IK2PI;
}
j15valid[0] = true;
for(int ij15 = 0; ij15 < 1; ++ij15)
{
if( !j15valid[ij15] )
{
    continue;
}
_ij15[0] = ij15; _ij15[1] = -1;
for(int iij15 = ij15+1; iij15 < 1; ++iij15)
{
if( j15valid[iij15] && IKabs(cj15array[ij15]-cj15array[iij15]) < IKFAST_SOLUTION_THRESH && IKabs(sj15array[ij15]-sj15array[iij15]) < IKFAST_SOLUTION_THRESH )
{
    j15valid[iij15]=false; _ij15[1] = iij15; break; 
}
}
j15 = j15array[ij15]; cj15 = cj15array[ij15]; sj15 = sj15array[ij15];
{
IkReal evalcond[12];
IkReal x633=IKsin(j15);
IkReal x634=IKcos(j15);
IkReal x635=(cj13*cj14);
IkReal x636=((1.0)*sj14);
IkReal x637=(cj14*sj13);
IkReal x638=((1.0)*sj13);
IkReal x639=((1.0)*x634);
IkReal x640=((1.0)*x633);
evalcond[0]=(((sj14*x634))+new_r20);
evalcond[1]=((((-1.0)*x633*x636))+new_r21);
evalcond[2]=(((cj13*new_r01))+((new_r11*sj13))+((cj14*x633)));
evalcond[3]=(((cj13*new_r10))+(((-1.0)*new_r00*x638))+(((-1.0)*x640)));
evalcond[4]=((((-1.0)*new_r01*x638))+((cj13*new_r11))+(((-1.0)*x639)));
evalcond[5]=(new_r01+((sj13*x634))+((x633*x635)));
evalcond[6]=(((cj13*new_r00))+(((-1.0)*cj14*x639))+((new_r10*sj13)));
evalcond[7]=((((-1.0)*x635*x639))+new_r00+((sj13*x633)));
evalcond[8]=(new_r11+(((-1.0)*cj13*x639))+((x633*x637)));
evalcond[9]=((((-1.0)*cj13*x640))+(((-1.0)*x637*x639))+new_r10);
evalcond[10]=(((new_r01*x635))+(((-1.0)*new_r21*x636))+((new_r11*x637))+x633);
evalcond[11]=((((-1.0)*x639))+((new_r00*x635))+(((-1.0)*new_r20*x636))+((new_r10*x637)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[8]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[9]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[10]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[11]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(8);
vinfos[0].jointtype = 17;
vinfos[0].foffset = j5;
vinfos[0].indices[0] = _ij5[0];
vinfos[0].indices[1] = _ij5[1];
vinfos[0].maxsolutions = _nj5;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j9;
vinfos[1].indices[0] = _ij9[0];
vinfos[1].indices[1] = _ij9[1];
vinfos[1].maxsolutions = _nj9;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j10;
vinfos[2].indices[0] = _ij10[0];
vinfos[2].indices[1] = _ij10[1];
vinfos[2].maxsolutions = _nj10;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j11;
vinfos[3].indices[0] = _ij11[0];
vinfos[3].indices[1] = _ij11[1];
vinfos[3].maxsolutions = _nj11;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j12;
vinfos[4].indices[0] = _ij12[0];
vinfos[4].indices[1] = _ij12[1];
vinfos[4].maxsolutions = _nj12;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j13;
vinfos[5].indices[0] = _ij13[0];
vinfos[5].indices[1] = _ij13[1];
vinfos[5].maxsolutions = _nj13;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j14;
vinfos[6].indices[0] = _ij14[0];
vinfos[6].indices[1] = _ij14[1];
vinfos[6].maxsolutions = _nj14;
vinfos[7].jointtype = 1;
vinfos[7].foffset = j15;
vinfos[7].indices[0] = _ij15[0];
vinfos[7].indices[1] = _ij15[1];
vinfos[7].maxsolutions = _nj15;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

} else
{
{
IkReal j15array[1], cj15array[1], sj15array[1];
bool j15valid[1]={false};
_nj15 = 1;
CheckValue<IkReal> x641=IKPowWithIntegerCheck(IKsign(sj14),-1);
if(!x641.valid){
continue;
}
CheckValue<IkReal> x642 = IKatan2WithCheck(IkReal(new_r21),IkReal(((-1.0)*new_r20)),IKFAST_ATAN2_MAGTHRESH);
if(!x642.valid){
continue;
}
j15array[0]=((-1.5707963267949)+(((1.5707963267949)*(x641.value)))+(x642.value));
sj15array[0]=IKsin(j15array[0]);
cj15array[0]=IKcos(j15array[0]);
if( j15array[0] > IKPI )
{
    j15array[0]-=IK2PI;
}
else if( j15array[0] < -IKPI )
{    j15array[0]+=IK2PI;
}
j15valid[0] = true;
for(int ij15 = 0; ij15 < 1; ++ij15)
{
if( !j15valid[ij15] )
{
    continue;
}
_ij15[0] = ij15; _ij15[1] = -1;
for(int iij15 = ij15+1; iij15 < 1; ++iij15)
{
if( j15valid[iij15] && IKabs(cj15array[ij15]-cj15array[iij15]) < IKFAST_SOLUTION_THRESH && IKabs(sj15array[ij15]-sj15array[iij15]) < IKFAST_SOLUTION_THRESH )
{
    j15valid[iij15]=false; _ij15[1] = iij15; break; 
}
}
j15 = j15array[ij15]; cj15 = cj15array[ij15]; sj15 = sj15array[ij15];
{
IkReal evalcond[12];
IkReal x643=IKsin(j15);
IkReal x644=IKcos(j15);
IkReal x645=(cj13*cj14);
IkReal x646=((1.0)*sj14);
IkReal x647=(cj14*sj13);
IkReal x648=((1.0)*sj13);
IkReal x649=((1.0)*x644);
IkReal x650=((1.0)*x643);
evalcond[0]=(new_r20+((sj14*x644)));
evalcond[1]=((((-1.0)*x643*x646))+new_r21);
evalcond[2]=(((cj13*new_r01))+((cj14*x643))+((new_r11*sj13)));
evalcond[3]=(((cj13*new_r10))+(((-1.0)*x650))+(((-1.0)*new_r00*x648)));
evalcond[4]=(((cj13*new_r11))+(((-1.0)*x649))+(((-1.0)*new_r01*x648)));
evalcond[5]=(((x643*x645))+((sj13*x644))+new_r01);
evalcond[6]=(((cj13*new_r00))+(((-1.0)*cj14*x649))+((new_r10*sj13)));
evalcond[7]=(((sj13*x643))+(((-1.0)*x645*x649))+new_r00);
evalcond[8]=(((x643*x647))+(((-1.0)*cj13*x649))+new_r11);
evalcond[9]=((((-1.0)*x647*x649))+(((-1.0)*cj13*x650))+new_r10);
evalcond[10]=(((new_r11*x647))+(((-1.0)*new_r21*x646))+((new_r01*x645))+x643);
evalcond[11]=((((-1.0)*x649))+((new_r10*x647))+((new_r00*x645))+(((-1.0)*new_r20*x646)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[8]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[9]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[10]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[11]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(8);
vinfos[0].jointtype = 17;
vinfos[0].foffset = j5;
vinfos[0].indices[0] = _ij5[0];
vinfos[0].indices[1] = _ij5[1];
vinfos[0].maxsolutions = _nj5;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j9;
vinfos[1].indices[0] = _ij9[0];
vinfos[1].indices[1] = _ij9[1];
vinfos[1].maxsolutions = _nj9;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j10;
vinfos[2].indices[0] = _ij10[0];
vinfos[2].indices[1] = _ij10[1];
vinfos[2].maxsolutions = _nj10;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j11;
vinfos[3].indices[0] = _ij11[0];
vinfos[3].indices[1] = _ij11[1];
vinfos[3].maxsolutions = _nj11;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j12;
vinfos[4].indices[0] = _ij12[0];
vinfos[4].indices[1] = _ij12[1];
vinfos[4].maxsolutions = _nj12;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j13;
vinfos[5].indices[0] = _ij13[0];
vinfos[5].indices[1] = _ij13[1];
vinfos[5].maxsolutions = _nj13;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j14;
vinfos[6].indices[0] = _ij14[0];
vinfos[6].indices[1] = _ij14[1];
vinfos[6].maxsolutions = _nj14;
vinfos[7].jointtype = 1;
vinfos[7].foffset = j15;
vinfos[7].indices[0] = _ij15[0];
vinfos[7].indices[1] = _ij15[1];
vinfos[7].maxsolutions = _nj15;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}
}
}

}

}
}
}
}
}static inline void polyroots3(IkReal rawcoeffs[3+1], IkReal rawroots[3], int& numroots)
{
    using std::complex;
    if( rawcoeffs[0] == 0 ) {
        // solve with one reduced degree
        polyroots2(&rawcoeffs[1], &rawroots[0], numroots);
        return;
    }
    IKFAST_ASSERT(rawcoeffs[0] != 0);
    const IkReal tol = 128.0*std::numeric_limits<IkReal>::epsilon();
    const IkReal tolsqrt = sqrt(std::numeric_limits<IkReal>::epsilon());
    complex<IkReal> coeffs[3];
    const int maxsteps = 110;
    for(int i = 0; i < 3; ++i) {
        coeffs[i] = complex<IkReal>(rawcoeffs[i+1]/rawcoeffs[0]);
    }
    complex<IkReal> roots[3];
    IkReal err[3];
    roots[0] = complex<IkReal>(1,0);
    roots[1] = complex<IkReal>(0.4,0.9); // any complex number not a root of unity works
    err[0] = 1.0;
    err[1] = 1.0;
    for(int i = 2; i < 3; ++i) {
        roots[i] = roots[i-1]*roots[1];
        err[i] = 1.0;
    }
    for(int step = 0; step < maxsteps; ++step) {
        bool changed = false;
        for(int i = 0; i < 3; ++i) {
            if ( err[i] >= tol ) {
                changed = true;
                // evaluate
                complex<IkReal> x = roots[i] + coeffs[0];
                for(int j = 1; j < 3; ++j) {
                    x = roots[i] * x + coeffs[j];
                }
                for(int j = 0; j < 3; ++j) {
                    if( i != j ) {
                        if( roots[i] != roots[j] ) {
                            x /= (roots[i] - roots[j]);
                        }
                    }
                }
                roots[i] -= x;
                err[i] = abs(x);
            }
        }
        if( !changed ) {
            break;
        }
    }

    numroots = 0;
    bool visited[3] = {false};
    for(int i = 0; i < 3; ++i) {
        if( !visited[i] ) {
            // might be a multiple root, in which case it will have more error than the other roots
            // find any neighboring roots, and take the average
            complex<IkReal> newroot=roots[i];
            int n = 1;
            for(int j = i+1; j < 3; ++j) {
                // care about error in real much more than imaginary
                if( abs(real(roots[i])-real(roots[j])) < tolsqrt && abs(imag(roots[i])-imag(roots[j])) < 0.002 ) {
                    newroot += roots[j];
                    n += 1;
                    visited[j] = true;
                }
            }
            if( n > 1 ) {
                newroot /= n;
            }
            // there are still cases where even the mean is not accurate enough, until a better multi-root algorithm is used, need to use the sqrt
            if( IKabs(imag(newroot)) < tolsqrt ) {
                rawroots[numroots++] = real(newroot);
            }
        }
    }
}
static inline void polyroots2(IkReal rawcoeffs[2+1], IkReal rawroots[2], int& numroots) {
    IkReal det = rawcoeffs[1]*rawcoeffs[1]-4*rawcoeffs[0]*rawcoeffs[2];
    if( det < 0 ) {
        numroots=0;
    }
    else if( det == 0 ) {
        rawroots[0] = -0.5*rawcoeffs[1]/rawcoeffs[0];
        numroots = 1;
    }
    else {
        det = IKsqrt(det);
        rawroots[0] = (-rawcoeffs[1]+det)/(2*rawcoeffs[0]);
        rawroots[1] = (-rawcoeffs[1]-det)/(2*rawcoeffs[0]);//rawcoeffs[2]/(rawcoeffs[0]*rawroots[0]);
        numroots = 2;
    }
}
static inline void polyroots5(IkReal rawcoeffs[5+1], IkReal rawroots[5], int& numroots)
{
    using std::complex;
    if( rawcoeffs[0] == 0 ) {
        // solve with one reduced degree
        polyroots4(&rawcoeffs[1], &rawroots[0], numroots);
        return;
    }
    IKFAST_ASSERT(rawcoeffs[0] != 0);
    const IkReal tol = 128.0*std::numeric_limits<IkReal>::epsilon();
    const IkReal tolsqrt = sqrt(std::numeric_limits<IkReal>::epsilon());
    complex<IkReal> coeffs[5];
    const int maxsteps = 110;
    for(int i = 0; i < 5; ++i) {
        coeffs[i] = complex<IkReal>(rawcoeffs[i+1]/rawcoeffs[0]);
    }
    complex<IkReal> roots[5];
    IkReal err[5];
    roots[0] = complex<IkReal>(1,0);
    roots[1] = complex<IkReal>(0.4,0.9); // any complex number not a root of unity works
    err[0] = 1.0;
    err[1] = 1.0;
    for(int i = 2; i < 5; ++i) {
        roots[i] = roots[i-1]*roots[1];
        err[i] = 1.0;
    }
    for(int step = 0; step < maxsteps; ++step) {
        bool changed = false;
        for(int i = 0; i < 5; ++i) {
            if ( err[i] >= tol ) {
                changed = true;
                // evaluate
                complex<IkReal> x = roots[i] + coeffs[0];
                for(int j = 1; j < 5; ++j) {
                    x = roots[i] * x + coeffs[j];
                }
                for(int j = 0; j < 5; ++j) {
                    if( i != j ) {
                        if( roots[i] != roots[j] ) {
                            x /= (roots[i] - roots[j]);
                        }
                    }
                }
                roots[i] -= x;
                err[i] = abs(x);
            }
        }
        if( !changed ) {
            break;
        }
    }

    numroots = 0;
    bool visited[5] = {false};
    for(int i = 0; i < 5; ++i) {
        if( !visited[i] ) {
            // might be a multiple root, in which case it will have more error than the other roots
            // find any neighboring roots, and take the average
            complex<IkReal> newroot=roots[i];
            int n = 1;
            for(int j = i+1; j < 5; ++j) {
                // care about error in real much more than imaginary
                if( abs(real(roots[i])-real(roots[j])) < tolsqrt && abs(imag(roots[i])-imag(roots[j])) < 0.002 ) {
                    newroot += roots[j];
                    n += 1;
                    visited[j] = true;
                }
            }
            if( n > 1 ) {
                newroot /= n;
            }
            // there are still cases where even the mean is not accurate enough, until a better multi-root algorithm is used, need to use the sqrt
            if( IKabs(imag(newroot)) < tolsqrt ) {
                rawroots[numroots++] = real(newroot);
            }
        }
    }
}
static inline void polyroots4(IkReal rawcoeffs[4+1], IkReal rawroots[4], int& numroots)
{
    using std::complex;
    if( rawcoeffs[0] == 0 ) {
        // solve with one reduced degree
        polyroots3(&rawcoeffs[1], &rawroots[0], numroots);
        return;
    }
    IKFAST_ASSERT(rawcoeffs[0] != 0);
    const IkReal tol = 128.0*std::numeric_limits<IkReal>::epsilon();
    const IkReal tolsqrt = sqrt(std::numeric_limits<IkReal>::epsilon());
    complex<IkReal> coeffs[4];
    const int maxsteps = 110;
    for(int i = 0; i < 4; ++i) {
        coeffs[i] = complex<IkReal>(rawcoeffs[i+1]/rawcoeffs[0]);
    }
    complex<IkReal> roots[4];
    IkReal err[4];
    roots[0] = complex<IkReal>(1,0);
    roots[1] = complex<IkReal>(0.4,0.9); // any complex number not a root of unity works
    err[0] = 1.0;
    err[1] = 1.0;
    for(int i = 2; i < 4; ++i) {
        roots[i] = roots[i-1]*roots[1];
        err[i] = 1.0;
    }
    for(int step = 0; step < maxsteps; ++step) {
        bool changed = false;
        for(int i = 0; i < 4; ++i) {
            if ( err[i] >= tol ) {
                changed = true;
                // evaluate
                complex<IkReal> x = roots[i] + coeffs[0];
                for(int j = 1; j < 4; ++j) {
                    x = roots[i] * x + coeffs[j];
                }
                for(int j = 0; j < 4; ++j) {
                    if( i != j ) {
                        if( roots[i] != roots[j] ) {
                            x /= (roots[i] - roots[j]);
                        }
                    }
                }
                roots[i] -= x;
                err[i] = abs(x);
            }
        }
        if( !changed ) {
            break;
        }
    }

    numroots = 0;
    bool visited[4] = {false};
    for(int i = 0; i < 4; ++i) {
        if( !visited[i] ) {
            // might be a multiple root, in which case it will have more error than the other roots
            // find any neighboring roots, and take the average
            complex<IkReal> newroot=roots[i];
            int n = 1;
            for(int j = i+1; j < 4; ++j) {
                // care about error in real much more than imaginary
                if( abs(real(roots[i])-real(roots[j])) < tolsqrt && abs(imag(roots[i])-imag(roots[j])) < 0.002 ) {
                    newroot += roots[j];
                    n += 1;
                    visited[j] = true;
                }
            }
            if( n > 1 ) {
                newroot /= n;
            }
            // there are still cases where even the mean is not accurate enough, until a better multi-root algorithm is used, need to use the sqrt
            if( IKabs(imag(newroot)) < tolsqrt ) {
                rawroots[numroots++] = real(newroot);
            }
        }
    }
}
static inline void polyroots7(IkReal rawcoeffs[7+1], IkReal rawroots[7], int& numroots)
{
    using std::complex;
    if( rawcoeffs[0] == 0 ) {
        // solve with one reduced degree
        polyroots6(&rawcoeffs[1], &rawroots[0], numroots);
        return;
    }
    IKFAST_ASSERT(rawcoeffs[0] != 0);
    const IkReal tol = 128.0*std::numeric_limits<IkReal>::epsilon();
    const IkReal tolsqrt = sqrt(std::numeric_limits<IkReal>::epsilon());
    complex<IkReal> coeffs[7];
    const int maxsteps = 110;
    for(int i = 0; i < 7; ++i) {
        coeffs[i] = complex<IkReal>(rawcoeffs[i+1]/rawcoeffs[0]);
    }
    complex<IkReal> roots[7];
    IkReal err[7];
    roots[0] = complex<IkReal>(1,0);
    roots[1] = complex<IkReal>(0.4,0.9); // any complex number not a root of unity works
    err[0] = 1.0;
    err[1] = 1.0;
    for(int i = 2; i < 7; ++i) {
        roots[i] = roots[i-1]*roots[1];
        err[i] = 1.0;
    }
    for(int step = 0; step < maxsteps; ++step) {
        bool changed = false;
        for(int i = 0; i < 7; ++i) {
            if ( err[i] >= tol ) {
                changed = true;
                // evaluate
                complex<IkReal> x = roots[i] + coeffs[0];
                for(int j = 1; j < 7; ++j) {
                    x = roots[i] * x + coeffs[j];
                }
                for(int j = 0; j < 7; ++j) {
                    if( i != j ) {
                        if( roots[i] != roots[j] ) {
                            x /= (roots[i] - roots[j]);
                        }
                    }
                }
                roots[i] -= x;
                err[i] = abs(x);
            }
        }
        if( !changed ) {
            break;
        }
    }

    numroots = 0;
    bool visited[7] = {false};
    for(int i = 0; i < 7; ++i) {
        if( !visited[i] ) {
            // might be a multiple root, in which case it will have more error than the other roots
            // find any neighboring roots, and take the average
            complex<IkReal> newroot=roots[i];
            int n = 1;
            for(int j = i+1; j < 7; ++j) {
                // care about error in real much more than imaginary
                if( abs(real(roots[i])-real(roots[j])) < tolsqrt && abs(imag(roots[i])-imag(roots[j])) < 0.002 ) {
                    newroot += roots[j];
                    n += 1;
                    visited[j] = true;
                }
            }
            if( n > 1 ) {
                newroot /= n;
            }
            // there are still cases where even the mean is not accurate enough, until a better multi-root algorithm is used, need to use the sqrt
            if( IKabs(imag(newroot)) < tolsqrt ) {
                rawroots[numroots++] = real(newroot);
            }
        }
    }
}
static inline void polyroots6(IkReal rawcoeffs[6+1], IkReal rawroots[6], int& numroots)
{
    using std::complex;
    if( rawcoeffs[0] == 0 ) {
        // solve with one reduced degree
        polyroots5(&rawcoeffs[1], &rawroots[0], numroots);
        return;
    }
    IKFAST_ASSERT(rawcoeffs[0] != 0);
    const IkReal tol = 128.0*std::numeric_limits<IkReal>::epsilon();
    const IkReal tolsqrt = sqrt(std::numeric_limits<IkReal>::epsilon());
    complex<IkReal> coeffs[6];
    const int maxsteps = 110;
    for(int i = 0; i < 6; ++i) {
        coeffs[i] = complex<IkReal>(rawcoeffs[i+1]/rawcoeffs[0]);
    }
    complex<IkReal> roots[6];
    IkReal err[6];
    roots[0] = complex<IkReal>(1,0);
    roots[1] = complex<IkReal>(0.4,0.9); // any complex number not a root of unity works
    err[0] = 1.0;
    err[1] = 1.0;
    for(int i = 2; i < 6; ++i) {
        roots[i] = roots[i-1]*roots[1];
        err[i] = 1.0;
    }
    for(int step = 0; step < maxsteps; ++step) {
        bool changed = false;
        for(int i = 0; i < 6; ++i) {
            if ( err[i] >= tol ) {
                changed = true;
                // evaluate
                complex<IkReal> x = roots[i] + coeffs[0];
                for(int j = 1; j < 6; ++j) {
                    x = roots[i] * x + coeffs[j];
                }
                for(int j = 0; j < 6; ++j) {
                    if( i != j ) {
                        if( roots[i] != roots[j] ) {
                            x /= (roots[i] - roots[j]);
                        }
                    }
                }
                roots[i] -= x;
                err[i] = abs(x);
            }
        }
        if( !changed ) {
            break;
        }
    }

    numroots = 0;
    bool visited[6] = {false};
    for(int i = 0; i < 6; ++i) {
        if( !visited[i] ) {
            // might be a multiple root, in which case it will have more error than the other roots
            // find any neighboring roots, and take the average
            complex<IkReal> newroot=roots[i];
            int n = 1;
            for(int j = i+1; j < 6; ++j) {
                // care about error in real much more than imaginary
                if( abs(real(roots[i])-real(roots[j])) < tolsqrt && abs(imag(roots[i])-imag(roots[j])) < 0.002 ) {
                    newroot += roots[j];
                    n += 1;
                    visited[j] = true;
                }
            }
            if( n > 1 ) {
                newroot /= n;
            }
            // there are still cases where even the mean is not accurate enough, until a better multi-root algorithm is used, need to use the sqrt
            if( IKabs(imag(newroot)) < tolsqrt ) {
                rawroots[numroots++] = real(newroot);
            }
        }
    }
}
static inline void polyroots8(IkReal rawcoeffs[8+1], IkReal rawroots[8], int& numroots)
{
    using std::complex;
    if( rawcoeffs[0] == 0 ) {
        // solve with one reduced degree
        polyroots7(&rawcoeffs[1], &rawroots[0], numroots);
        return;
    }
    IKFAST_ASSERT(rawcoeffs[0] != 0);
    const IkReal tol = 128.0*std::numeric_limits<IkReal>::epsilon();
    const IkReal tolsqrt = sqrt(std::numeric_limits<IkReal>::epsilon());
    complex<IkReal> coeffs[8];
    const int maxsteps = 110;
    for(int i = 0; i < 8; ++i) {
        coeffs[i] = complex<IkReal>(rawcoeffs[i+1]/rawcoeffs[0]);
    }
    complex<IkReal> roots[8];
    IkReal err[8];
    roots[0] = complex<IkReal>(1,0);
    roots[1] = complex<IkReal>(0.4,0.9); // any complex number not a root of unity works
    err[0] = 1.0;
    err[1] = 1.0;
    for(int i = 2; i < 8; ++i) {
        roots[i] = roots[i-1]*roots[1];
        err[i] = 1.0;
    }
    for(int step = 0; step < maxsteps; ++step) {
        bool changed = false;
        for(int i = 0; i < 8; ++i) {
            if ( err[i] >= tol ) {
                changed = true;
                // evaluate
                complex<IkReal> x = roots[i] + coeffs[0];
                for(int j = 1; j < 8; ++j) {
                    x = roots[i] * x + coeffs[j];
                }
                for(int j = 0; j < 8; ++j) {
                    if( i != j ) {
                        if( roots[i] != roots[j] ) {
                            x /= (roots[i] - roots[j]);
                        }
                    }
                }
                roots[i] -= x;
                err[i] = abs(x);
            }
        }
        if( !changed ) {
            break;
        }
    }

    numroots = 0;
    bool visited[8] = {false};
    for(int i = 0; i < 8; ++i) {
        if( !visited[i] ) {
            // might be a multiple root, in which case it will have more error than the other roots
            // find any neighboring roots, and take the average
            complex<IkReal> newroot=roots[i];
            int n = 1;
            for(int j = i+1; j < 8; ++j) {
                // care about error in real much more than imaginary
                if( abs(real(roots[i])-real(roots[j])) < tolsqrt && abs(imag(roots[i])-imag(roots[j])) < 0.002 ) {
                    newroot += roots[j];
                    n += 1;
                    visited[j] = true;
                }
            }
            if( n > 1 ) {
                newroot /= n;
            }
            // there are still cases where even the mean is not accurate enough, until a better multi-root algorithm is used, need to use the sqrt
            if( IKabs(imag(newroot)) < tolsqrt ) {
                rawroots[numroots++] = real(newroot);
            }
        }
    }
}
};


/// solves the inverse kinematics equations.
/// \param pfree is an array specifying the free joints of the chain.
IKFAST_API bool ComputeIk(const IkReal* eetrans, const IkReal* eerot, const IkReal* pfree, IkSolutionListBase<IkReal>& solutions) {
IKSolver solver;
return solver.ComputeIk(eetrans,eerot,pfree,solutions);
}

IKFAST_API bool ComputeIk2(const IkReal* eetrans, const IkReal* eerot, const IkReal* pfree, IkSolutionListBase<IkReal>& solutions, void* pOpenRAVEManip) {
IKSolver solver;
return solver.ComputeIk(eetrans,eerot,pfree,solutions);
}

IKFAST_API const char* GetKinematicsHash() { return "<robot:GenericRobot - fetch (e550ddaa93397f5c841bf0ca317262da)>"; }

IKFAST_API const char* GetIkFastVersion() { return "0x1000004a"; }

#ifdef IKFAST_NAMESPACE
} // end namespace
#endif

#ifndef IKFAST_NO_MAIN
#include <stdio.h>
#include <stdlib.h>
#ifdef IKFAST_NAMESPACE
using namespace IKFAST_NAMESPACE;
#endif
int main(int argc, char** argv)
{
    if( argc != 12+GetNumFreeParameters()+1 ) {
        printf("\nUsage: ./ik r00 r01 r02 t0 r10 r11 r12 t1 r20 r21 r22 t2 free0 ...\n\n"
               "Returns the ik solutions given the transformation of the end effector specified by\n"
               "a 3x3 rotation R (rXX), and a 3x1 translation (tX).\n"
               "There are %d free parameters that have to be specified.\n\n",GetNumFreeParameters());
        return 1;
    }

    IkSolutionList<IkReal> solutions;
    std::vector<IkReal> vfree(GetNumFreeParameters());
    IkReal eerot[9],eetrans[3];
    eerot[0] = atof(argv[1]); eerot[1] = atof(argv[2]); eerot[2] = atof(argv[3]); eetrans[0] = atof(argv[4]);
    eerot[3] = atof(argv[5]); eerot[4] = atof(argv[6]); eerot[5] = atof(argv[7]); eetrans[1] = atof(argv[8]);
    eerot[6] = atof(argv[9]); eerot[7] = atof(argv[10]); eerot[8] = atof(argv[11]); eetrans[2] = atof(argv[12]);
    for(std::size_t i = 0; i < vfree.size(); ++i)
        vfree[i] = atof(argv[13+i]);
    bool bSuccess = ComputeIk(eetrans, eerot, vfree.size() > 0 ? &vfree[0] : NULL, solutions);

    if( !bSuccess ) {
        fprintf(stderr,"Failed to get ik solution\n");
        return -1;
    }

    printf("Found %d ik solutions:\n", (int)solutions.GetNumSolutions());
    std::vector<IkReal> solvalues(GetNumJoints());
    for(std::size_t i = 0; i < solutions.GetNumSolutions(); ++i) {
        const IkSolutionBase<IkReal>& sol = solutions.GetSolution(i);
        printf("sol%d (free=%d): ", (int)i, (int)sol.GetFree().size());
        std::vector<IkReal> vsolfree(sol.GetFree().size());
        sol.GetSolution(&solvalues[0],vsolfree.size()>0?&vsolfree[0]:NULL);
        for( std::size_t j = 0; j < solvalues.size(); ++j)
            printf("%.15f, ", solvalues[j]);
        printf("\n");
    }
    return 0;
}

#endif

//// START
static PyObject *arm_ik(PyObject *self, PyObject *args) {
    IkSolutionList<IkReal> solutions;

    // Should only have two free parameters (torso and upper arm)
    std::vector<IkReal> vfree(GetNumFreeParameters());
    IkReal eerot[9], eetrans[3];

    // First list if 3x3 rotation matrix, easier to compute in Python.
    // Next list is [x, y, z] translation matrix.
    // Last list is free joints (torso and upper arm roll (in that order)).
    PyObject *rotList; // 3x3 rotation matrix
    PyObject *transList; // [x,y,z]
    PyObject *freeList; // [torso, upper arm]

    if(!PyArg_ParseTuple(args, "O!O!O!", &PyList_Type, &rotList, &PyList_Type, &transList, &PyList_Type, &freeList)) {
        return NULL;
    }

    for(std::size_t i = 0; i < 3; ++i) {
        eetrans[i] = PyFloat_AsDouble(PyList_GetItem(transList, i));

        PyObject* rowList = PyList_GetItem(rotList, i);
        for( std::size_t j = 0; j < 3; ++j) {
            eerot[3*i + j] = PyFloat_AsDouble(PyList_GetItem(rowList, j));
        }
    }

    for(int i = 0; i < GetNumFreeParameters(); ++i) {
        vfree[i] = PyFloat_AsDouble(PyList_GetItem(freeList, i));
    }

    // I don't understand why we pass &vfree[0] instead of just vfree.
    // Clearly ComputeIk takes an IkReal* parameter there, but it treats that parameter like an array.
    // It probably does work because the computeIk call in main specifically makes this change.
    // So it's hopefully right, and I don't understand because I don't know C++.
    bool bSuccess = ComputeIk(eetrans, eerot, &vfree[0], solutions);

    if (!bSuccess) {
        return Py_BuildValue(""); // Equivalent to returning None
    }

    // There are 8 joints in each solution (torso + 7 arm joints).
    std::vector<IkReal> solvalues(GetNumJoints());
    PyObject *solutionList = PyList_New(solutions.GetNumSolutions());

    for(std::size_t i = 0; i < solutions.GetNumSolutions(); ++i) {
        const IkSolutionBase<IkReal>& sol = solutions.GetSolution(i);
        std::vector<IkReal> vsolfree(sol.GetFree().size());
        sol.GetSolution(&solvalues[0],vsolfree.size()>0?&vsolfree[0]:NULL);

        PyObject *individualSolution = PyList_New(GetNumJoints());
        for( std::size_t j = 0; j < solvalues.size(); ++j) {
            // I think IkReal is just a wrapper for double. So this should work.
            PyList_SetItem(individualSolution, j, PyFloat_FromDouble(solvalues[j]));
        }
        PyList_SetItem(solutionList, i, individualSolution);
    }
    return solutionList;
}

static PyObject *arm_fk(PyObject *self, PyObject *args) {
    std::vector<IkReal> joints(8);
    IkReal eerot[9], eetrans[3];

    // First double is torso height. Next 7 doubles are arm joints
    PyObject *jointList;
    if(!PyArg_ParseTuple(args, "O!", &PyList_Type, &jointList)) {
        return NULL;
    }

    for(std::size_t i = 0; i < 8; ++i){
        joints[i] = PyFloat_AsDouble(PyList_GetItem(jointList, i));
    }

    ComputeFk(&joints[0], eetrans, eerot);

    PyObject *pose = PyList_New(2);
    PyObject *pos = PyList_New(3);
    PyObject *rot = PyList_New(3);

    for(std::size_t i = 0; i < 3; ++i) {
        PyList_SetItem(pos, i, PyFloat_FromDouble(eetrans[i]));

        PyObject *row = PyList_New(3);
        for( std::size_t j = 0; j < 3; ++j) {
            PyList_SetItem(row, j, PyFloat_FromDouble(eerot[3*i + j]));
        }
        PyList_SetItem(rot, i, row);
    }

    PyList_SetItem(pose, 0, pos);
    PyList_SetItem(pose, 1, rot);

    return pose;
}

static PyMethodDef ikfast_fetchMethods[] = {
    {"get_ik", arm_ik, METH_VARARGS, "Compute ik solutions using ikfast."},
    {"get_fk", arm_fk, METH_VARARGS, "Compute fk solutions using ikfast."},
    // TODO: deprecate
    {"armIK", arm_ik, METH_VARARGS, "Compute IK for the PR2's arm."},
    {"armFK", arm_fk, METH_VARARGS, "Compute FK for the PR2's arm."},
    {NULL, NULL, 0, NULL} // Not sure why/if this is needed. It shows up in the examples though(something about Sentinel).
};

// OLD WAY
/*#if PY_MAJOR_VERSION >= 3

//// This is the python3.4 version.
static struct PyModuleDef ikArmModule = {
    PyModuleDef_HEAD_INIT,
    "ikArm",
    NULL,
    -1,
    ikArmMethods
};

PyMODINIT_FUNC PyInit_ikArm(void) {
    return PyModule_Create(&ikArmModule);
}

#else

//// This is the python2.7 version.
PyMODINIT_FUNC initikArm(void) {
    (void) Py_InitModule("ikArm", ikArmMethods);
}

#endif*/

// NEW WAY
#if PY_MAJOR_VERSION >= 3

static struct PyModuleDef ikfast_fetchModule = {
    PyModuleDef_HEAD_INIT,
    "ikfast_fetch",   /* name of module */
    NULL, /* module documentation, may be NULL */
    -1,       /* size of per-interpreter state of the module,
                 or -1 if the module keeps state in global variables. */
    ikfast_fetchMethods
};

#define INITERROR return NULL

PyMODINIT_FUNC
PyInit_ikfast_fetch(void)

#else // PY_MAJOR_VERSION < 3
#define INITERROR return

PyMODINIT_FUNC
initikfast_fetch(void)
#endif
{
#if PY_MAJOR_VERSION >= 3
    PyObject *module = PyModule_Create(&ikfast_fetchModule);
#else
    PyObject *module = Py_InitModule("ikfast_fetch", ikfast_fetchMethods);
#endif

if (module == NULL)
    INITERROR;

#if PY_MAJOR_VERSION >= 3
    return module;
#endif
}

//// END