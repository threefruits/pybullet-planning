/// autogenerated analytical inverse kinematics code from ikfast program part of OpenRAVE
/// \author Rosen Diankov
///
/// Licensed under the Apache License, Version 2.0 (the "License");
/// you may not use this file except in compliance with the License.
/// You may obtain a copy of the License at
///     http://www.apache.org/licenses/LICENSE-2.0
/// 
/// Unless required by applicable law or agreed to in writing, software
/// distributed under the License is distributed on an "AS IS" BASIS,
/// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
/// See the License for the specific language governing permissions and
/// limitations under the License.
///
/// ikfast version 0x1000004a generated on 2024-06-21 06:07:25.043562
/// Generated using solver transform6d
/// To compile with gcc:
///     gcc -lstdc++ ik.cpp
/// To compile without any main function as a shared object (might need -llapack):
///     gcc -fPIC -lstdc++ -DIKFAST_NO_MAIN -DIKFAST_CLIBRARY -shared -Wl,-soname,libik.so -o libik.so ik.cpp


//// START
//// Make sure the version number matches.
//// You might need to install the dev version to get the header files.
//// sudo apt-get install python3.4-dev
#include "Python.h"
//// END

#define IKFAST_HAS_LIBRARY
#include "ikfast.h" // found inside share/openrave-X.Y/python/ikfast.h
using namespace ikfast;

// check if the included ikfast version matches what this file was compiled with
// #define IKFAST_COMPILE_ASSERT(x) extern int __dummy[(int)x]
// IKFAST_COMPILE_ASSERT(IKFAST_VERSION==0x1000004a);

#include <cmath>
#include <vector>
#include <limits>
#include <algorithm>
#include <complex>

#ifndef IKFAST_ASSERT
#include <stdexcept>
#include <sstream>
#include <iostream>

#ifdef _MSC_VER
#ifndef __PRETTY_FUNCTION__
#define __PRETTY_FUNCTION__ __FUNCDNAME__
#endif
#endif

#ifndef __PRETTY_FUNCTION__
#define __PRETTY_FUNCTION__ __func__
#endif

#define IKFAST_ASSERT(b) { if( !(b) ) { std::stringstream ss; ss << "ikfast exception: " << __FILE__ << ":" << __LINE__ << ": " <<__PRETTY_FUNCTION__ << ": Assertion '" << #b << "' failed"; throw std::runtime_error(ss.str()); } }

#endif

#if defined(_MSC_VER)
#define IKFAST_ALIGNED16(x) __declspec(align(16)) x
#else
#define IKFAST_ALIGNED16(x) x __attribute((aligned(16)))
#endif

#define IK2PI  ((IkReal)6.28318530717959)
#define IKPI  ((IkReal)3.14159265358979)
#define IKPI_2  ((IkReal)1.57079632679490)

#ifdef _MSC_VER
#ifndef isnan
#define isnan std::isnan
#endif
#ifndef isinf
#define isinf std::isinf
#endif
//#ifndef isfinite
//#define isfinite _isfinite
//#endif
#endif // _MSC_VER

// lapack routines
extern "C" {
  void dgetrf_ (const int* m, const int* n, double* a, const int* lda, int* ipiv, int* info);
  void zgetrf_ (const int* m, const int* n, std::complex<double>* a, const int* lda, int* ipiv, int* info);
  void dgetri_(const int* n, const double* a, const int* lda, int* ipiv, double* work, const int* lwork, int* info);
  void dgesv_ (const int* n, const int* nrhs, double* a, const int* lda, int* ipiv, double* b, const int* ldb, int* info);
  void dgetrs_(const char *trans, const int *n, const int *nrhs, double *a, const int *lda, int *ipiv, double *b, const int *ldb, int *info);
  void dgeev_(const char *jobvl, const char *jobvr, const int *n, double *a, const int *lda, double *wr, double *wi,double *vl, const int *ldvl, double *vr, const int *ldvr, double *work, const int *lwork, int *info);
}

using namespace std; // necessary to get std math routines

#ifdef IKFAST_NAMESPACE
namespace IKFAST_NAMESPACE {
#endif

inline float IKabs(float f) { return fabsf(f); }
inline double IKabs(double f) { return fabs(f); }

inline float IKsqr(float f) { return f*f; }
inline double IKsqr(double f) { return f*f; }

inline float IKlog(float f) { return logf(f); }
inline double IKlog(double f) { return log(f); }

// allows asin and acos to exceed 1. has to be smaller than thresholds used for branch conds and evaluation
#ifndef IKFAST_SINCOS_THRESH
#define IKFAST_SINCOS_THRESH ((IkReal)1e-7)
#endif

// used to check input to atan2 for degenerate cases. has to be smaller than thresholds used for branch conds and evaluation
#ifndef IKFAST_ATAN2_MAGTHRESH
#define IKFAST_ATAN2_MAGTHRESH ((IkReal)1e-7)
#endif

// minimum distance of separate solutions
#ifndef IKFAST_SOLUTION_THRESH
#define IKFAST_SOLUTION_THRESH ((IkReal)1e-6)
#endif

// there are checkpoints in ikfast that are evaluated to make sure they are 0. This threshold speicfies by how much they can deviate
#ifndef IKFAST_EVALCOND_THRESH
#define IKFAST_EVALCOND_THRESH ((IkReal)0.00001)
#endif


inline float IKasin(float f)
{
IKFAST_ASSERT( f > -1-IKFAST_SINCOS_THRESH && f < 1+IKFAST_SINCOS_THRESH ); // any more error implies something is wrong with the solver
if( f <= -1 ) return float(-IKPI_2);
else if( f >= 1 ) return float(IKPI_2);
return asinf(f);
}
inline double IKasin(double f)
{
IKFAST_ASSERT( f > -1-IKFAST_SINCOS_THRESH && f < 1+IKFAST_SINCOS_THRESH ); // any more error implies something is wrong with the solver
if( f <= -1 ) return -IKPI_2;
else if( f >= 1 ) return IKPI_2;
return asin(f);
}

// return positive value in [0,y)
inline float IKfmod(float x, float y)
{
    while(x < 0) {
        x += y;
    }
    return fmodf(x,y);
}

// return positive value in [0,y)
inline double IKfmod(double x, double y)
{
    while(x < 0) {
        x += y;
    }
    return fmod(x,y);
}

inline float IKacos(float f)
{
IKFAST_ASSERT( f > -1-IKFAST_SINCOS_THRESH && f < 1+IKFAST_SINCOS_THRESH ); // any more error implies something is wrong with the solver
if( f <= -1 ) return float(IKPI);
else if( f >= 1 ) return float(0);
return acosf(f);
}
inline double IKacos(double f)
{
IKFAST_ASSERT( f > -1-IKFAST_SINCOS_THRESH && f < 1+IKFAST_SINCOS_THRESH ); // any more error implies something is wrong with the solver
if( f <= -1 ) return IKPI;
else if( f >= 1 ) return 0;
return acos(f);
}
inline float IKsin(float f) { return sinf(f); }
inline double IKsin(double f) { return sin(f); }
inline float IKcos(float f) { return cosf(f); }
inline double IKcos(double f) { return cos(f); }
inline float IKtan(float f) { return tanf(f); }
inline double IKtan(double f) { return tan(f); }
inline float IKsqrt(float f) { if( f <= 0.0f ) return 0.0f; return sqrtf(f); }
inline double IKsqrt(double f) { if( f <= 0.0 ) return 0.0; return sqrt(f); }
inline float IKatan2Simple(float fy, float fx) {
    return atan2f(fy,fx);
}
inline float IKatan2(float fy, float fx) {
    if( isnan(fy) ) {
        IKFAST_ASSERT(!isnan(fx)); // if both are nan, probably wrong value will be returned
        return float(IKPI_2);
    }
    else if( isnan(fx) ) {
        return 0;
    }
    return atan2f(fy,fx);
}
inline double IKatan2Simple(double fy, double fx) {
    return atan2(fy,fx);
}
inline double IKatan2(double fy, double fx) {
    if( isnan(fy) ) {
        IKFAST_ASSERT(!isnan(fx)); // if both are nan, probably wrong value will be returned
        return IKPI_2;
    }
    else if( isnan(fx) ) {
        return 0;
    }
    return atan2(fy,fx);
}

template <typename T>
struct CheckValue
{
    T value;
    bool valid;
};

template <typename T>
inline CheckValue<T> IKatan2WithCheck(T fy, T fx, T epsilon)
{
    CheckValue<T> ret;
    ret.valid = false;
    ret.value = 0;
    if( !isnan(fy) && !isnan(fx) ) {
        if( IKabs(fy) >= IKFAST_ATAN2_MAGTHRESH || IKabs(fx) > IKFAST_ATAN2_MAGTHRESH ) {
            ret.value = IKatan2Simple(fy,fx);
            ret.valid = true;
        }
    }
    return ret;
}

inline float IKsign(float f) {
    if( f > 0 ) {
        return float(1);
    }
    else if( f < 0 ) {
        return float(-1);
    }
    return 0;
}

inline double IKsign(double f) {
    if( f > 0 ) {
        return 1.0;
    }
    else if( f < 0 ) {
        return -1.0;
    }
    return 0;
}

template <typename T>
inline CheckValue<T> IKPowWithIntegerCheck(T f, int n)
{
    CheckValue<T> ret;
    ret.valid = true;
    if( n == 0 ) {
        ret.value = 1.0;
        return ret;
    }
    else if( n == 1 )
    {
        ret.value = f;
        return ret;
    }
    else if( n < 0 )
    {
        if( f == 0 )
        {
            ret.valid = false;
            ret.value = (T)1.0e30;
            return ret;
        }
        if( n == -1 ) {
            ret.value = T(1.0)/f;
            return ret;
        }
    }

    int num = n > 0 ? n : -n;
    if( num == 2 ) {
        ret.value = f*f;
    }
    else if( num == 3 ) {
        ret.value = f*f*f;
    }
    else {
        ret.value = 1.0;
        while(num>0) {
            if( num & 1 ) {
                ret.value *= f;
            }
            num >>= 1;
            f *= f;
        }
    }
    
    if( n < 0 ) {
        ret.value = T(1.0)/ret.value;
    }
    return ret;
}

/// solves the forward kinematics equations.
/// \param pfree is an array specifying the free joints of the chain.
IKFAST_API void ComputeFk(const IkReal* j, IkReal* eetrans, IkReal* eerot) {
IkReal x0,x1,x2,x3,x4,x5,x6,x7,x8,x9,x10,x11,x12,x13,x14,x15,x16,x17,x18,x19,x20,x21,x22,x23,x24,x25,x26,x27,x28,x29,x30,x31,x32,x33,x34,x35,x36,x37,x38,x39,x40,x41,x42,x43,x44,x45,x46,x47,x48,x49,x50,x51,x52,x53,x54,x55,x56,x57,x58,x59,x60,x61,x62,x63,x64;
x0=IKcos(j[1]);
x1=IKcos(j[4]);
x2=IKcos(j[2]);
x3=IKsin(j[4]);
x4=IKsin(j[2]);
x5=IKsin(j[3]);
x6=IKcos(j[3]);
x7=IKsin(j[1]);
x8=IKcos(j[5]);
x9=IKsin(j[5]);
x10=IKsin(j[6]);
x11=IKcos(j[6]);
x12=IKsin(j[7]);
x13=IKcos(j[7]);
x14=((1.0)*x1);
x15=((1.0)*x3);
x16=((1.0)*x8);
x17=((0.30495)*x8);
x18=((0.30495)*x3);
x19=((0.30495)*x9);
x20=((1.0)*x9);
x21=((1.0)*x10);
x22=((0.30495)*x1);
x23=((1.0)*x11);
x24=((0.3215)*x1);
x25=(x2*x7);
x26=((-1.0)*x3);
x27=(x0*x2);
x28=(x2*x5);
x29=((-1.0)*x10);
x30=((-1.0)*x1);
x31=(x0*x5);
x32=((-1.0)*x11);
x33=(x5*x7);
x34=(x2*x6);
x35=(x0*x4*x6);
x36=(x4*x6*x7);
x37=(x15*x27);
x38=(x14*x34);
x39=(((x31*x4))+(((-1.0)*x6*x7)));
x40=((((-1.0)*x36))+x31);
x41=(((x0*x6))+((x33*x4)));
x42=((((-1.0)*x38))+((x3*x4)));
x43=(x38+(((-1.0)*x15*x4)));
x44=((((-1.0)*x35))+(((-1.0)*x33)));
x45=(x39*x9);
x46=(((x14*x4))+((x15*x34)));
x47=(x41*x9);
x48=(x41*x8);
x49=(x42*x8);
x50=(x39*x8);
x51=((1.0)*x44);
x52=(x43*x9);
x53=(x1*x44);
x54=(x49+((x28*x9)));
x55=((((-1.0)*x14*x40))+((x15*x25)));
x56=(((x25*x26))+((x1*x40)));
x57=(x53+((x26*x27)));
x58=(x56*x8);
x59=(x55*x9);
x60=(x57*x8);
x61=(x47+x58);
x62=(x45+x60);
x63=((((-1.0)*x23*x54))+(((-1.0)*x21*x46)));
x64=(((x32*x61))+((x29*((((x26*x40))+((x25*x30)))))));
eerot[0]=(((x11*((((x1*x27))+((x3*x44))))))+((x10*((x45+((x8*(((((-1.0)*x37))+x53)))))))));
eerot[1]=((((-1.0)*x12*((((x23*x62))+((x21*(((((-1.0)*x15*x44))+(((-1.0)*x14*x27))))))))))+((x13*((((x9*((x37+((x30*x44))))))+x50)))));
eerot[2]=(((x13*((((x32*x62))+((x29*((((x27*x30))+((x26*x44))))))))))+(((-1.0)*x12*((((x16*x39))+((x20*(((((-1.0)*x14*x44))+x37)))))))));
eetrans[0]=((0.03265)+((x10*((((x19*x39))+((x17*x57))))))+((x11*((((x22*x27))+((x18*x44))))))+(((0.117)*x0))+(((0.352)*x27))+((x3*(((((-0.3215)*x35))+(((-0.3215)*x33))))))+((x24*x27)));
eerot[3]=(((x11*((((x1*x25))+((x3*x40))))))+((x10*x61)));
eerot[4]=(((x12*x64))+((x13*((x48+x59)))));
eerot[5]=(((x13*x64))+((x12*(((((-1.0)*x20*x55))+(((-1.0)*x16*x41)))))));
eetrans[1]=(((x10*((((x19*x41))+((x17*x56))))))+((x3*(((((-0.3215)*x36))+(((0.3215)*x31))))))+(((0.117)*x7))+(((0.352)*x25))+((x11*((((x22*x25))+((x18*x40))))))+((x24*x25)));
eerot[6]=(((x10*x54))+(((-1.0)*x11*x46)));
eerot[7]=(((x12*x63))+((x13*((x52+((x28*x8)))))));
eerot[8]=(((x13*x63))+((x12*(((((-1.0)*x20*x43))+(((-1.0)*x16*x28)))))));
IkReal x65=((1.0)*x4);
eetrans[2]=((0.78601)+((x10*((((x19*x28))+((x17*x42))))))+(((-1.0)*x24*x65))+((x11*(((((-1.0)*x18*x34))+(((-1.0)*x22*x65))))))+(((-0.3215)*x3*x34))+(((-0.352)*x4))+j[0]);
}

IKFAST_API int GetNumFreeParameters() { return 2; }
IKFAST_API int* GetFreeParameters() { static int freeparams[] = {2, 3}; return freeparams; }
IKFAST_API int GetNumJoints() { return 8; }

IKFAST_API int GetIkRealSize() { return sizeof(IkReal); }

IKFAST_API int GetIkType() { return 0x67000001; }

class IKSolver {
public:
IkReal j5,cj5,sj5,htj5,j5mul,j9,cj9,sj9,htj9,j9mul,j12,cj12,sj12,htj12,j12mul,j13,cj13,sj13,htj13,j13mul,j14,cj14,sj14,htj14,j14mul,j15,cj15,sj15,htj15,j15mul,j10,cj10,sj10,htj10,j11,cj11,sj11,htj11,new_r00,r00,rxp0_0,new_r01,r01,rxp0_1,new_r02,r02,rxp0_2,new_r10,r10,rxp1_0,new_r11,r11,rxp1_1,new_r12,r12,rxp1_2,new_r20,r20,rxp2_0,new_r21,r21,rxp2_1,new_r22,r22,rxp2_2,new_px,px,npx,new_py,py,npy,new_pz,pz,npz,pp;
unsigned char _ij5[2], _nj5,_ij9[2], _nj9,_ij12[2], _nj12,_ij13[2], _nj13,_ij14[2], _nj14,_ij15[2], _nj15,_ij10[2], _nj10,_ij11[2], _nj11;

IkReal j100, cj100, sj100;
unsigned char _ij100[2], _nj100;
bool ComputeIk(const IkReal* eetrans, const IkReal* eerot, const IkReal* pfree, IkSolutionListBase<IkReal>& solutions) {
j5=numeric_limits<IkReal>::quiet_NaN(); _ij5[0] = -1; _ij5[1] = -1; _nj5 = -1; j9=numeric_limits<IkReal>::quiet_NaN(); _ij9[0] = -1; _ij9[1] = -1; _nj9 = -1; j12=numeric_limits<IkReal>::quiet_NaN(); _ij12[0] = -1; _ij12[1] = -1; _nj12 = -1; j13=numeric_limits<IkReal>::quiet_NaN(); _ij13[0] = -1; _ij13[1] = -1; _nj13 = -1; j14=numeric_limits<IkReal>::quiet_NaN(); _ij14[0] = -1; _ij14[1] = -1; _nj14 = -1; j15=numeric_limits<IkReal>::quiet_NaN(); _ij15[0] = -1; _ij15[1] = -1; _nj15 = -1;  _ij10[0] = -1; _ij10[1] = -1; _nj10 = 0;  _ij11[0] = -1; _ij11[1] = -1; _nj11 = 0; 
for(int dummyiter = 0; dummyiter < 1; ++dummyiter) {
    solutions.Clear();
j10=pfree[0]; cj10=cos(pfree[0]); sj10=sin(pfree[0]), htj10=tan(pfree[0]*0.5);
j11=pfree[1]; cj11=cos(pfree[1]); sj11=sin(pfree[1]), htj11=tan(pfree[1]*0.5);
r00 = eerot[0*3+0];
r01 = eerot[0*3+1];
r02 = eerot[0*3+2];
r10 = eerot[1*3+0];
r11 = eerot[1*3+1];
r12 = eerot[1*3+2];
r20 = eerot[2*3+0];
r21 = eerot[2*3+1];
r22 = eerot[2*3+2];
px = eetrans[0]; py = eetrans[1]; pz = eetrans[2];

new_r00=((-1.0)*r02);
new_r01=r01;
new_r02=r00;
new_px=((-0.03265)+px+(((-0.30495)*r00)));
new_r10=((-1.0)*r12);
new_r11=r11;
new_r12=r10;
new_py=((((-0.30495)*r10))+py);
new_r20=((-1.0)*r22);
new_r21=r21;
new_r22=r20;
new_pz=((-0.72601)+(((-0.30495)*r20))+pz);
r00 = new_r00; r01 = new_r01; r02 = new_r02; r10 = new_r10; r11 = new_r11; r12 = new_r12; r20 = new_r20; r21 = new_r21; r22 = new_r22; px = new_px; py = new_py; pz = new_pz;
IkReal x66=((1.0)*px);
IkReal x67=((1.0)*pz);
IkReal x68=((1.0)*py);
pp=((px*px)+(py*py)+(pz*pz));
npx=(((px*r00))+((py*r10))+((pz*r20)));
npy=(((px*r01))+((py*r11))+((pz*r21)));
npz=(((px*r02))+((py*r12))+((pz*r22)));
rxp0_0=((((-1.0)*r20*x68))+((pz*r10)));
rxp0_1=(((px*r20))+(((-1.0)*r00*x67)));
rxp0_2=((((-1.0)*r10*x66))+((py*r00)));
rxp1_0=((((-1.0)*r21*x68))+((pz*r11)));
rxp1_1=(((px*r21))+(((-1.0)*r01*x67)));
rxp1_2=((((-1.0)*r11*x66))+((py*r01)));
rxp2_0=(((pz*r12))+(((-1.0)*r22*x68)));
rxp2_1=(((px*r22))+(((-1.0)*r02*x67)));
rxp2_2=((((-1.0)*r12*x66))+((py*r02)));
{
IkReal j12eval[1];
IkReal x69=pz*pz;
IkReal x70=sj10*sj10;
IkReal x71=(cj11*sj10);
IkReal x72=((0.363919129082426)*x71);
j12eval[0]=((IKabs(((((-0.0948678071539658)*cj10*x71))+(((-1.0)*x72)))))+(IKabs(((((-2.09486780715397)*cj10*x71))+(((-1.0)*x72)))))+(IKabs(((1.16558632382712)+(((4.83735599795864)*x69))+(((-1.0)*(cj10*cj10)*(cj11*cj11)))+(((0.398443338839857)*cj10))+(((-0.0993677575710668)*x70))+(((-4.83735599795864)*pp)))))+(IKabs(((0.0353592583365784)+(((2.41867799897932)*x69))+(((-0.00224997520855051)*x70))+(((0.0172621048787154)*cj10))+(((-2.41867799897932)*pp))))));
if( IKabs(j12eval[0]) < 0.0000000100000000  )
{
IkReal op[8+1], zeror[8];
int numroots;
IkReal x73=((1.0)*px);
IkReal x74=((0.6735)*cj10);
IkReal x75=((0.0305)*cj10);
IkReal x76=((0.117)+(((-1.0)*x73))+x74);
IkReal x77=((0.117)+(((-1.0)*x73))+x75);
IkReal x78=((-0.117)+(((-1.0)*x73))+(((-1.0)*x74)));
IkReal x79=((-0.117)+(((-1.0)*x73))+(((-1.0)*x75)));
IkReal gconst0=x76;
IkReal gconst1=x77;
IkReal gconst2=x76;
IkReal gconst3=x77;
IkReal gconst4=x78;
IkReal gconst5=x79;
IkReal gconst6=x78;
IkReal gconst7=x79;
IkReal x80=py*py;
IkReal x81=cj11*cj11;
IkReal x82=sj10*sj10;
IkReal x83=sj11*sj11;
IkReal x84=cj10*cj10;
IkReal x85=((0.193494132)*gconst1);
IkReal x86=(gconst1*gconst2);
IkReal x87=((1.0)*gconst4);
IkReal x88=(cj10*gconst6);
IkReal x89=(gconst5*gconst7);
IkReal x90=((0.630396)*cj10);
IkReal x91=((0.468)*py);
IkReal x92=(gconst2*gconst4);
IkReal x93=((1.408)*py);
IkReal x94=(cj10*gconst2);
IkReal x95=(cj10*gconst5);
IkReal x96=(gconst1*gconst3);
IkReal x97=(gconst5*gconst6);
IkReal x98=(gconst3*gconst4);
IkReal x99=(gconst0*gconst3);
IkReal x100=(gconst4*gconst7);
IkReal x101=((0.122)*py);
IkReal x102=(gconst1*gconst6);
IkReal x103=(gconst1*gconst7);
IkReal x104=(gconst2*py);
IkReal x105=((2.067245)*py);
IkReal x106=((0.329472)*cj10);
IkReal x107=((0.193494132)*gconst6);
IkReal x108=((2.694)*py);
IkReal x109=(gconst0*gconst2);
IkReal x110=((0.193494132)*gconst5);
IkReal x111=(cj10*gconst1);
IkReal x112=(gconst3*gconst5);
IkReal x113=(gconst4*gconst6);
IkReal x114=((0.193494132)*gconst2);
IkReal x115=(gconst2*gconst5);
IkReal x116=((0.826898)*py);
IkReal x117=(gconst0*gconst7);
IkReal x118=((0.413449)*py);
IkReal x119=((0.773976528)*py);
IkReal x120=(cj11*sj10*sj11);
IkReal x121=((0.826898)*x83);
IkReal x122=(gconst6*x80);
IkReal x123=((1.814409)*x84);
IkReal x124=((2.0)*x80);
IkReal x125=((1.653796)*x80);
IkReal x126=((0.082167)*x84);
IkReal x127=((2.328544768)*cj10*py);
IkReal x128=((0.413449)*x83);
IkReal x129=((1.0)*x80);
IkReal x130=((0.050440778)*x83);
IkReal x131=((1.113831606)*x83);
IkReal x132=((0.003721)*x84);
IkReal x133=(x89*x91);
IkReal x134=(x113*x91);
IkReal x135=(x100*x91);
IkReal x136=(x91*x97);
IkReal x137=(x103*x91);
IkReal x138=(gconst0*gconst6*x91);
IkReal x139=(x91*x92);
IkReal x140=(x112*x91);
IkReal x141=(x119*x83);
IkReal x142=(x117*x91);
IkReal x143=(x102*x91);
IkReal x144=((0.090555253776)*x120);
IkReal x145=(x115*x91);
IkReal x146=(x91*x98);
IkReal x147=(x115*x80);
IkReal x148=(x80*x98);
IkReal x149=(x117*x80);
IkReal x150=(x102*x80);
IkReal x151=(x109*x91);
IkReal x152=(x91*x96);
IkReal x153=(x91*x99);
IkReal x154=(x86*x91);
IkReal x155=(x81*x82);
IkReal x156=(x108*x111);
IkReal x157=(x109*x80);
IkReal x158=(gconst4*x101*x88);
IkReal x159=(cj10*x108*x89);
IkReal x160=(gconst5*x88*x93);
IkReal x161=(cj10*x100*x93);
IkReal x162=(gconst6*x116*x83);
IkReal x163=(gconst3*x108*x95);
IkReal x164=(gconst5*x116*x83);
IkReal x165=(x127*x83);
IkReal x166=(cj10*x101*x92);
IkReal x167=(gconst0*x101*x88);
IkReal x168=(cj10*x103*x108);
IkReal x169=(cj10*x117*x93);
IkReal x170=(gconst5*x93*x94);
IkReal x171=((0.096747066)*gconst6*x120);
IkReal x172=(cj10*x93*x98);
IkReal x173=((0.096747066)*gconst5*x120);
IkReal x174=(gconst1*x88*x93);
IkReal x175=((0.544879475712)*cj10*x120);
IkReal x176=(x119*x120);
IkReal x177=(x102*x128);
IkReal x178=(x103*x129);
IkReal x179=(gconst2*x80*x87);
IkReal x180=(x115*x128);
IkReal x181=((1.0)*gconst0*x122);
IkReal x182=(x125*x83);
IkReal x183=(x112*x129);
IkReal x184=((0.022638813444)*x155);
IkReal x185=(cj10*x108*x96);
IkReal x186=(x104*x121);
IkReal x187=(gconst1*x116*x83);
IkReal x188=(gconst0*x101*x94);
IkReal x189=((0.096747066)*gconst1*x120);
IkReal x190=((0.096747066)*gconst2*x120);
IkReal x191=(cj10*x93*x99);
IkReal x192=(cj10*x86*x93);
IkReal x193=((1.653796)*x120*x97);
IkReal x194=(x120*x125);
IkReal x195=((0.193494132)*py*x155);
IkReal x196=((1.653796)*x115*x120);
IkReal x197=((1.653796)*x102*x120);
IkReal x198=((0.025220389)*x120*x88);
IkReal x199=((0.556915803)*x120*x95);
IkReal x200=((0.135887455932)*x120*x84);
IkReal x201=(gconst6*x118*x120);
IkReal x202=(gconst5*x118*x120);
IkReal x203=(x120*x127);
IkReal x204=((0.136219868928)*cj10*x155);
IkReal x205=((1.653796)*x120*x86);
IkReal x206=((0.025220389)*x120*x94);
IkReal x207=((0.556915803)*x111*x120);
IkReal x208=((0.413449)*x104*x120);
IkReal x209=(gconst1*x118*x120);
IkReal x210=((0.582136192)*cj10*py*x155);
IkReal x211=(gconst5*x116*x155);
IkReal x212=(gconst6*x116*x155);
IkReal x213=((0.033971863983)*x155*x84);
IkReal x214=((0.826898)*x104*x155);
IkReal x215=(gconst1*x116*x155);
IkReal x216=((0.413449)*x155*x80);
IkReal x217=(x162+x164);
IkReal x218=(x176+x203);
IkReal x219=(x197+x196);
IkReal x220=(x209+x208);
IkReal x221=(x202+x201);
IkReal x222=(x214+x215);
IkReal x223=(x175+x144+x200);
IkReal x224=(x150+x147+x148+x149);
IkReal x225=(x152+x151+x185+x188);
IkReal x226=(x160+x161+x135+x136);
IkReal x227=(x190+x189+x207+x206);
IkReal x228=(x171+x173+x199+x198);
IkReal x229=(x195+x186+x187+x210);
IkReal x230=(x159+x158+x134+x133+x194);
IkReal x231=(x154+x153+x192+x191+x194);
IkReal x232=(x195+x210+x211+x212);
IkReal x233=(x170+x172+x174+x169+x142+x143+x145+x146);
IkReal x234=(x168+x163+x166+x167+x165+x140+x141+x137+x139+x138);
IkReal x235=(x179+x178+x177+x184+x180+x181+x182+x183+x213+x204);
op[0]=(((x100*x80))+x221+((x80*x97))+(((-1.0)*x216))+(((-1.0)*x129*x89))+(((-1.0)*x122*x87))+(((-1.0)*x128*x97)));
op[1]=((((-1.0)*x193))+x232+x230+(((-1.0)*x217))+(((-1.0)*x228))+(((-1.0)*x226)));
op[2]=((((-1.653796)*x155*x97))+((x126*x97))+(((-1.0)*x113*x124))+((x110*x83))+((x107*x83))+(((-1.0)*gconst5*x105*x120))+(((-1.0)*x113*x132))+(((-0.054756)*x89))+(((0.054756)*x97))+((x124*x97))+(((0.329472)*gconst5*x88))+(((-0.054756)*x113))+(((-0.050440778)*x155*x88))+(((-1.0)*x235))+x220+x224+(((0.054756)*x100))+(((-0.028548)*gconst4*x88))+((x121*x97))+(((-1.0)*x107*x155))+(((-1.113831606)*x155*x95))+((x131*x95))+((x130*x88))+(((-1.0)*x110*x155))+(((-1.0)*x218))+((x100*x126))+((x100*x124))+(((-1.0)*gconst6*x105*x120))+(((-1.0)*x124*x89))+(((-1.0)*x89*x90))+(((-1.0)*x123*x89))+((x100*x106)));
op[3]=((((3.341494818)*x120*x95))+(((0.151322334)*x120*x88))+x193+(((-1.0)*x233))+x223+x222+x230+x234+(((0.580482396)*gconst6*x120))+(((-1.0)*x219))+(((-1.0)*x229))+(((-1.0)*x226))+(((-1.0)*x227))+(((0.580482396)*gconst5*x120)));
op[4]=((((0.329472)*cj10*gconst3*gconst4))+(((-2.067245)*cj11*gconst6*py*sj10*sj11))+(((-0.054756)*gconst2*gconst4))+(((-0.003721)*gconst2*gconst4*(cj10*cj10)))+(((0.329472)*cj10*gconst0*gconst7))+(((-0.135887455932)*(cj10*cj10)*(sj11*sj11)))+(((-0.050440778)*cj10*gconst6*(sj11*sj11)))+(((-1.653796)*gconst1*gconst6*(cj11*cj11)*(sj10*sj10)))+(((0.082167)*gconst2*gconst5*(cj10*cj10)))+(((-0.193494132)*gconst1*(cj11*cj11)*(sj10*sj10)))+(((0.193494132)*gconst6*(cj11*cj11)*(sj10*sj10)))+(((0.045277626888)*(cj11*cj11)*(sj10*sj10)))+(((-0.544879475712)*cj10*(sj11*sj11)))+(((-0.413449)*gconst1*gconst2*(sj11*sj11)))+(((-2.0)*gconst1*gconst7*(py*py)))+(((-1.0)*gconst4*gconst6*(py*py)))+(((-0.193494132)*gconst6*(sj11*sj11)))+(((0.329472)*cj10*gconst2*gconst5))+(((0.067943727966)*(cj10*cj10)*(cj11*cj11)*(sj10*sj10)))+(((-1.113831606)*cj10*gconst5*(sj11*sj11)))+(((0.272439737856)*cj10*(cj11*cj11)*(sj10*sj10)))+(((0.329472)*cj10*gconst1*gconst6))+(((-2.0)*gconst0*gconst6*(py*py)))+(((-0.028548)*cj10*gconst0*gconst6))+(((0.082167)*gconst1*gconst6*(cj10*cj10)))+(((-0.003721)*gconst0*gconst6*(cj10*cj10)))+(((0.050440778)*cj10*gconst6*(cj11*cj11)*(sj10*sj10)))+(((-1.814409)*gconst3*gconst5*(cj10*cj10)))+(((-3.307592)*(py*py)*(sj11*sj11)))+(((-0.413449)*gconst5*gconst6*(sj11*sj11)))+(((-0.193494132)*gconst2*(cj11*cj11)*(sj10*sj10)))+(((0.193494132)*gconst2*(sj11*sj11)))+(((2.0)*gconst2*gconst5*(py*py)))+(((2.0)*gconst0*gconst7*(py*py)))+(((-0.090555253776)*(sj11*sj11)))+(((-0.028548)*cj10*gconst2*gconst4))+(((-1.0)*gconst0*gconst2*(py*py)))+(((-1.814409)*gconst1*gconst7*(cj10*cj10)))+(((-2.067245)*cj11*gconst2*py*sj10*sj11))+((gconst4*gconst7*(py*py)))+(((-0.050440778)*cj10*gconst2*(cj11*cj11)*(sj10*sj10)))+(((0.193494132)*gconst5*(cj11*cj11)*(sj10*sj10)))+(((2.0)*gconst1*gconst6*(py*py)))+(((0.082167)*gconst0*gconst7*(cj10*cj10)))+(((0.826898)*(cj11*cj11)*(py*py)*(sj10*sj10)))+(((-0.193494132)*gconst5*(sj11*sj11)))+(((-0.630396)*cj10*gconst3*gconst5))+(((1.113831606)*cj10*gconst1*(sj11*sj11)))+(((0.193494132)*gconst1*(sj11*sj11)))+(((-2.067245)*cj11*gconst1*py*sj10*sj11))+(((0.050440778)*cj10*gconst2*(sj11*sj11)))+(((0.054756)*gconst1*gconst6))+(((0.054756)*gconst2*gconst5))+(((-1.653796)*gconst2*gconst5*(cj11*cj11)*(sj10*sj10)))+((gconst1*gconst2*(py*py)))+(((0.082167)*gconst3*gconst4*(cj10*cj10)))+((gconst5*gconst6*(py*py)))+(((-1.0)*gconst5*gconst7*(py*py)))+(((-0.054756)*gconst1*gconst7))+(((-2.0)*gconst3*gconst5*(py*py)))+(((-2.067245)*cj11*gconst5*py*sj10*sj11))+(((0.826898)*gconst2*gconst5*(sj11*sj11)))+(((-0.054756)*gconst3*gconst5))+(((0.054756)*gconst3*gconst4))+(((-0.630396)*cj10*gconst1*gconst7))+(((-1.113831606)*cj10*gconst1*(cj11*cj11)*(sj10*sj10)))+(((-0.054756)*gconst0*gconst6))+(((2.0)*gconst3*gconst4*(py*py)))+(((-2.0)*gconst2*gconst4*(py*py)))+(((0.054756)*gconst0*gconst7))+(((-1.0)*gconst1*gconst3*(py*py)))+((gconst0*gconst3*(py*py)))+(((1.113831606)*cj10*gconst5*(cj11*cj11)*(sj10*sj10)))+(((0.826898)*gconst1*gconst6*(sj11*sj11))));
op[5]=((((3.341494818)*x111*x120))+(((0.151322334)*x120*x94))+(((-1.0)*x205))+(((0.580482396)*gconst1*x120))+(((-1.0)*x233))+(((-1.0)*x232))+(((-1.0)*x231))+x217+x219+x225+x234+(((0.580482396)*gconst2*x120))+(((-1.0)*x228))+(((-1.0)*x223)));
op[6]=(((x126*x99))+(((-1.0)*x123*x96))+(((-2.067245)*x104*x120))+(((-0.054756)*x96))+(((0.054756)*x86))+(((-1.0)*x83*x85))+(((-1.0)*x111*x131))+((x124*x86))+(((0.054756)*x99))+(((-1.0)*x90*x96))+((x124*x99))+(((-0.054756)*x109))+((x106*x99))+((x121*x86))+(((-1.0)*x235))+x218+x221+x224+((x106*x86))+(((-1.0)*x109*x124))+(((-1.0)*x109*x132))+(((-0.028548)*gconst0*x94))+(((-1.0)*x130*x94))+((x155*x85))+(((1.113831606)*x111*x155))+(((-1.653796)*x155*x86))+(((-1.0)*gconst1*x105*x120))+(((0.050440778)*x155*x94))+(((-1.0)*x114*x83))+((x126*x86))+((x114*x155))+(((-1.0)*x124*x96)));
op[7]=((((-1.0)*x231))+x229+x225+x205+(((-1.0)*x227))+(((-1.0)*x222)));
op[8]=((((-1.0)*x128*x86))+x220+(((-1.0)*x109*x129))+((x80*x86))+((x80*x99))+(((-1.0)*x216))+(((-1.0)*x129*x96)));
polyroots8(op,zeror,numroots);
IkReal j9array[8], cj9array[8], sj9array[8], tempj9array[1];
int numsolutions = 0;
for(int ij9 = 0; ij9 < numroots; ++ij9)
{
IkReal htj9 = zeror[ij9];
tempj9array[0]=((2.0)*(atan(htj9)));
for(int kj9 = 0; kj9 < 1; ++kj9)
{
j9array[numsolutions] = tempj9array[kj9];
if( j9array[numsolutions] > IKPI )
{
    j9array[numsolutions]-=IK2PI;
}
else if( j9array[numsolutions] < -IKPI )
{
    j9array[numsolutions]+=IK2PI;
}
sj9array[numsolutions] = IKsin(j9array[numsolutions]);
cj9array[numsolutions] = IKcos(j9array[numsolutions]);
numsolutions++;
}
}
bool j9valid[8]={true,true,true,true,true,true,true,true};
_nj9 = 8;
for(int ij9 = 0; ij9 < numsolutions; ++ij9)
    {
if( !j9valid[ij9] )
{
    continue;
}
    j9 = j9array[ij9]; cj9 = cj9array[ij9]; sj9 = sj9array[ij9];
htj9 = IKtan(j9/2);

_ij9[0] = ij9; _ij9[1] = -1;
for(int iij9 = ij9+1; iij9 < numsolutions; ++iij9)
{
if( j9valid[iij9] && IKabs(cj9array[ij9]-cj9array[iij9]) < IKFAST_SOLUTION_THRESH && IKabs(sj9array[ij9]-sj9array[iij9]) < IKFAST_SOLUTION_THRESH )
{
    j9valid[iij9]=false; _ij9[1] = iij9; break; 
}
}
{
IkReal j5array[2], cj5array[2], sj5array[2];
bool j5valid[2]={false};
_nj5 = 2;
IkReal x236=((0.352)*sj10);
IkReal x237=(cj9*px);
IkReal x238=((2.816)*cj10);
IkReal x239=(py*sj9);
IkReal x240=((-0.06)+x236+pz);
if((((0.358693)+((x237*x238))+(((4.0)*(pz*pz)))+(((-0.495616)*(cj10*cj10)))+(((-0.329472)*cj10))+(((0.936)*x237))+(((0.936)*x239))+((x238*x239))+(((-4.0)*pp)))) < -0.00001)
continue;
IkReal x241=((0.5)*(IKsqrt(((0.358693)+((x237*x238))+(((4.0)*(pz*pz)))+(((-0.495616)*(cj10*cj10)))+(((-0.329472)*cj10))+(((0.936)*x237))+(((0.936)*x239))+((x238*x239))+(((-4.0)*pp))))));
j5array[0]=(x240+(((-1.0)*x241)));
sj5array[0]=IKsin(j5array[0]);
cj5array[0]=IKcos(j5array[0]);
j5array[1]=(x241+x240);
sj5array[1]=IKsin(j5array[1]);
cj5array[1]=IKcos(j5array[1]);
j5valid[0] = true;
j5valid[1] = true;
for(int ij5 = 0; ij5 < 2; ++ij5)
{
if( !j5valid[ij5] )
{
    continue;
}
_ij5[0] = ij5; _ij5[1] = -1;
for(int iij5 = ij5+1; iij5 < 2; ++iij5)
{
if( j5valid[iij5] && IKabs(cj5array[ij5]-cj5array[iij5]) < IKFAST_SOLUTION_THRESH && IKabs(sj5array[ij5]-sj5array[iij5]) < IKFAST_SOLUTION_THRESH )
{
    j5valid[iij5]=false; _ij5[1] = iij5; break; 
}
}
j5 = j5array[ij5]; cj5 = cj5array[ij5]; sj5 = sj5array[ij5];

{
IkReal j12eval[1];
j12eval[0]=((((-1.0)*sj11*sj9))+(((-1.0)*cj11*cj9*sj10)));
if( IKabs(j12eval[0]) < 0.0000010000000000  )
{
{
IkReal j12eval[2];
j12eval[0]=cj10;
j12eval[1]=cj11;
if( IKabs(j12eval[0]) < 0.0000010000000000  || IKabs(j12eval[1]) < 0.0000010000000000  )
{
{
IkReal j12eval[1];
j12eval[0]=(((cj11*cj9))+((sj10*sj11*sj9)));
if( IKabs(j12eval[0]) < 0.0000010000000000  )
{
{
IkReal evalcond[2];
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((-1.5707963267949)+j10)))), 6.28318530717959)));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j12array[1], cj12array[1], sj12array[1];
bool j12valid[1]={false};
_nj12 = 1;
IkReal x242=((3.1104199066874)*cj9);
IkReal x243=((3.1104199066874)*sj9);
if( IKabs((((py*sj11*x242))+(((-1.0)*px*sj11*x243))+(((-1.0)*cj11*py*x243))+(((-1.0)*cj11*px*x242))+(((0.363919129082426)*cj11)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((-0.908242612752722)+(((3.1104199066874)*j5))+(((-3.1104199066874)*pz)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr((((py*sj11*x242))+(((-1.0)*px*sj11*x243))+(((-1.0)*cj11*py*x243))+(((-1.0)*cj11*px*x242))+(((0.363919129082426)*cj11))))+IKsqr(((-0.908242612752722)+(((3.1104199066874)*j5))+(((-3.1104199066874)*pz))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j12array[0]=IKatan2((((py*sj11*x242))+(((-1.0)*px*sj11*x243))+(((-1.0)*cj11*py*x243))+(((-1.0)*cj11*px*x242))+(((0.363919129082426)*cj11))), ((-0.908242612752722)+(((3.1104199066874)*j5))+(((-3.1104199066874)*pz))));
sj12array[0]=IKsin(j12array[0]);
cj12array[0]=IKcos(j12array[0]);
if( j12array[0] > IKPI )
{
    j12array[0]-=IK2PI;
}
else if( j12array[0] < -IKPI )
{    j12array[0]+=IK2PI;
}
j12valid[0] = true;
for(int ij12 = 0; ij12 < 1; ++ij12)
{
if( !j12valid[ij12] )
{
    continue;
}
_ij12[0] = ij12; _ij12[1] = -1;
for(int iij12 = ij12+1; iij12 < 1; ++iij12)
{
if( j12valid[iij12] && IKabs(cj12array[ij12]-cj12array[iij12]) < IKFAST_SOLUTION_THRESH && IKabs(sj12array[ij12]-sj12array[iij12]) < IKFAST_SOLUTION_THRESH )
{
    j12valid[iij12]=false; _ij12[1] = iij12; break; 
}
}
j12 = j12array[ij12]; cj12 = cj12array[ij12]; sj12 = sj12array[ij12];
{
IkReal evalcond[5];
IkReal x244=IKsin(j12);
IkReal x245=IKcos(j12);
IkReal x246=(cj11*cj9);
IkReal x247=((1.0)*py);
IkReal x248=(cj9*sj11);
IkReal x249=(cj11*sj9);
IkReal x250=(sj11*sj9);
IkReal x251=((0.3215)*x244);
evalcond[0]=((-0.292)+(((-0.3215)*x245))+(((-1.0)*pz))+j5);
evalcond[1]=((((-1.0)*x250*x251))+(((-1.0)*x246*x251))+(((-1.0)*px))+(((0.117)*cj9)));
evalcond[2]=((((0.117)*sj9))+((x248*x251))+(((-1.0)*x249*x251))+(((-1.0)*x247)));
evalcond[3]=((0.20231525)+(((-1.0)*(j5*j5)))+(((0.187756)*x245))+(((-1.0)*pp))+(((-0.075231)*cj11*x244))+(((2.0)*j5*pz)));
evalcond[4]=(((px*x246))+((px*x250))+x251+(((-0.117)*cj11))+((py*x249))+(((-1.0)*x247*x248)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((1.5707963267949)+j10)))), 6.28318530717959)));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j12array[1], cj12array[1], sj12array[1];
bool j12valid[1]={false};
_nj12 = 1;
IkReal x710=((3.1104199066874)*cj9);
IkReal x711=((3.1104199066874)*sj9);
if( IKabs((((cj11*py*x711))+(((-0.363919129082426)*cj11))+((cj11*px*x710))+((py*sj11*x710))+(((-1.0)*px*sj11*x711)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((-1.28149300155521)+(((3.1104199066874)*pz))+(((-3.1104199066874)*j5)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr((((cj11*py*x711))+(((-0.363919129082426)*cj11))+((cj11*px*x710))+((py*sj11*x710))+(((-1.0)*px*sj11*x711))))+IKsqr(((-1.28149300155521)+(((3.1104199066874)*pz))+(((-3.1104199066874)*j5))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j12array[0]=IKatan2((((cj11*py*x711))+(((-0.363919129082426)*cj11))+((cj11*px*x710))+((py*sj11*x710))+(((-1.0)*px*sj11*x711))), ((-1.28149300155521)+(((3.1104199066874)*pz))+(((-3.1104199066874)*j5))));
sj12array[0]=IKsin(j12array[0]);
cj12array[0]=IKcos(j12array[0]);
if( j12array[0] > IKPI )
{
    j12array[0]-=IK2PI;
}
else if( j12array[0] < -IKPI )
{    j12array[0]+=IK2PI;
}
j12valid[0] = true;
for(int ij12 = 0; ij12 < 1; ++ij12)
{
if( !j12valid[ij12] )
{
    continue;
}
_ij12[0] = ij12; _ij12[1] = -1;
for(int iij12 = ij12+1; iij12 < 1; ++iij12)
{
if( j12valid[iij12] && IKabs(cj12array[ij12]-cj12array[iij12]) < IKFAST_SOLUTION_THRESH && IKabs(sj12array[ij12]-sj12array[iij12]) < IKFAST_SOLUTION_THRESH )
{
    j12valid[iij12]=false; _ij12[1] = iij12; break; 
}
}
j12 = j12array[ij12]; cj12 = cj12array[ij12]; sj12 = sj12array[ij12];
{
IkReal evalcond[5];
IkReal x712=IKsin(j12);
IkReal x713=IKcos(j12);
IkReal x714=((1.0)*py);
IkReal x715=(cj9*sj11);
IkReal x716=((1.0)*px);
IkReal x717=(cj11*cj9);
IkReal x718=(cj11*sj9);
IkReal x719=(sj11*sj9);
IkReal x720=((0.3215)*x712);
evalcond[0]=((0.412)+(((0.3215)*x713))+(((-1.0)*pz))+j5);
evalcond[1]=(((x717*x720))+(((-1.0)*x716))+(((0.117)*cj9))+(((-1.0)*x719*x720)));
evalcond[2]=((((0.117)*sj9))+(((-1.0)*x714))+((x718*x720))+((x715*x720)));
evalcond[3]=((0.28679525)+(((-1.0)*(j5*j5)))+(((-1.0)*pp))+(((0.075231)*cj11*x712))+(((0.264916)*x713))+(((2.0)*j5*pz)));
evalcond[4]=((((-1.0)*x714*x715))+(((-1.0)*x714*x718))+(((0.117)*cj11))+(((-1.0)*x716*x717))+((px*x719))+x720);
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((-1.5707963267949)+j11)))), 6.28318530717959)));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j12eval[1];
sj11=1.0;
cj11=0;
j11=1.5707963267949;
j12eval[0]=sj10;
if( IKabs(j12eval[0]) < 0.0000010000000000  )
{
{
IkReal j12eval[2];
sj11=1.0;
cj11=0;
j11=1.5707963267949;
j12eval[0]=cj10;
j12eval[1]=cj9;
if( IKabs(j12eval[0]) < 0.0000010000000000  || IKabs(j12eval[1]) < 0.0000010000000000  )
{
{
IkReal j12eval[2];
sj11=1.0;
cj11=0;
j11=1.5707963267949;
j12eval[0]=cj10;
j12eval[1]=sj9;
if( IKabs(j12eval[0]) < 0.0000010000000000  || IKabs(j12eval[1]) < 0.0000010000000000  )
{
{
IkReal evalcond[1];
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((-1.5707963267949)+j10)))), 6.28318530717959)));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j12array[1], cj12array[1], sj12array[1];
bool j12valid[1]={false};
_nj12 = 1;
if( IKabs(((((-3.1104199066874)*px*sj9))+(((3.1104199066874)*cj9*py)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((-0.908242612752722)+(((3.1104199066874)*j5))+(((-3.1104199066874)*pz)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((((-3.1104199066874)*px*sj9))+(((3.1104199066874)*cj9*py))))+IKsqr(((-0.908242612752722)+(((3.1104199066874)*j5))+(((-3.1104199066874)*pz))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j12array[0]=IKatan2(((((-3.1104199066874)*px*sj9))+(((3.1104199066874)*cj9*py))), ((-0.908242612752722)+(((3.1104199066874)*j5))+(((-3.1104199066874)*pz))));
sj12array[0]=IKsin(j12array[0]);
cj12array[0]=IKcos(j12array[0]);
if( j12array[0] > IKPI )
{
    j12array[0]-=IK2PI;
}
else if( j12array[0] < -IKPI )
{    j12array[0]+=IK2PI;
}
j12valid[0] = true;
for(int ij12 = 0; ij12 < 1; ++ij12)
{
if( !j12valid[ij12] )
{
    continue;
}
_ij12[0] = ij12; _ij12[1] = -1;
for(int iij12 = ij12+1; iij12 < 1; ++iij12)
{
if( j12valid[iij12] && IKabs(cj12array[ij12]-cj12array[iij12]) < IKFAST_SOLUTION_THRESH && IKabs(sj12array[ij12]-sj12array[iij12]) < IKFAST_SOLUTION_THRESH )
{
    j12valid[iij12]=false; _ij12[1] = iij12; break; 
}
}
j12 = j12array[ij12]; cj12 = cj12array[ij12]; sj12 = sj12array[ij12];
{
IkReal evalcond[5];
IkReal x721=IKsin(j12);
IkReal x722=IKcos(j12);
IkReal x723=((1.0)*py);
IkReal x724=((0.3215)*x721);
evalcond[0]=((-0.292)+(((-0.3215)*x722))+(((-1.0)*pz))+j5);
evalcond[1]=((((-1.0)*sj9*x724))+(((-1.0)*px))+(((0.117)*cj9)));
evalcond[2]=((((0.117)*sj9))+(((-1.0)*x723))+((cj9*x724)));
evalcond[3]=((((-1.0)*cj9*x723))+((px*sj9))+x724);
evalcond[4]=((0.20231525)+(((-1.0)*(j5*j5)))+(((-1.0)*pp))+(((0.187756)*x722))+(((2.0)*j5*pz)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((1.5707963267949)+j10)))), 6.28318530717959)));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j12array[1], cj12array[1], sj12array[1];
bool j12valid[1]={false};
_nj12 = 1;
if( IKabs(((((-3.1104199066874)*px*sj9))+(((3.1104199066874)*cj9*py)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((-1.28149300155521)+(((3.1104199066874)*pz))+(((-3.1104199066874)*j5)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((((-3.1104199066874)*px*sj9))+(((3.1104199066874)*cj9*py))))+IKsqr(((-1.28149300155521)+(((3.1104199066874)*pz))+(((-3.1104199066874)*j5))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j12array[0]=IKatan2(((((-3.1104199066874)*px*sj9))+(((3.1104199066874)*cj9*py))), ((-1.28149300155521)+(((3.1104199066874)*pz))+(((-3.1104199066874)*j5))));
sj12array[0]=IKsin(j12array[0]);
cj12array[0]=IKcos(j12array[0]);
if( j12array[0] > IKPI )
{
    j12array[0]-=IK2PI;
}
else if( j12array[0] < -IKPI )
{    j12array[0]+=IK2PI;
}
j12valid[0] = true;
for(int ij12 = 0; ij12 < 1; ++ij12)
{
if( !j12valid[ij12] )
{
    continue;
}
_ij12[0] = ij12; _ij12[1] = -1;
for(int iij12 = ij12+1; iij12 < 1; ++iij12)
{
if( j12valid[iij12] && IKabs(cj12array[ij12]-cj12array[iij12]) < IKFAST_SOLUTION_THRESH && IKabs(sj12array[ij12]-sj12array[iij12]) < IKFAST_SOLUTION_THRESH )
{
    j12valid[iij12]=false; _ij12[1] = iij12; break; 
}
}
j12 = j12array[ij12]; cj12 = cj12array[ij12]; sj12 = sj12array[ij12];
{
IkReal evalcond[5];
IkReal x725=IKsin(j12);
IkReal x726=IKcos(j12);
IkReal x727=((1.0)*py);
IkReal x728=((0.3215)*x725);
evalcond[0]=((0.412)+(((0.3215)*x726))+(((-1.0)*pz))+j5);
evalcond[1]=((((-1.0)*sj9*x728))+(((-1.0)*px))+(((0.117)*cj9)));
evalcond[2]=((((0.117)*sj9))+(((-1.0)*x727))+((cj9*x728)));
evalcond[3]=((((-1.0)*cj9*x727))+((px*sj9))+x728);
evalcond[4]=((0.28679525)+(((-1.0)*(j5*j5)))+(((-1.0)*pp))+(((0.264916)*x726))+(((2.0)*j5*pz)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(j9))), 6.28318530717959)));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j12array[1], cj12array[1], sj12array[1];
bool j12valid[1]={false};
_nj12 = 1;
IkReal x729=((3.1104199066874)*sj10);
if( IKabs(((3.1104199066874)*py)) < IKFAST_ATAN2_MAGTHRESH && IKabs(((-1.09486780715397)+(((-0.363919129082426)*cj10))+((j5*x729))+(((3.1104199066874)*cj10*px))+(((0.186625194401244)*sj10))+(((-1.0)*pz*x729)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((3.1104199066874)*py))+IKsqr(((-1.09486780715397)+(((-0.363919129082426)*cj10))+((j5*x729))+(((3.1104199066874)*cj10*px))+(((0.186625194401244)*sj10))+(((-1.0)*pz*x729))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j12array[0]=IKatan2(((3.1104199066874)*py), ((-1.09486780715397)+(((-0.363919129082426)*cj10))+((j5*x729))+(((3.1104199066874)*cj10*px))+(((0.186625194401244)*sj10))+(((-1.0)*pz*x729))));
sj12array[0]=IKsin(j12array[0]);
cj12array[0]=IKcos(j12array[0]);
if( j12array[0] > IKPI )
{
    j12array[0]-=IK2PI;
}
else if( j12array[0] < -IKPI )
{    j12array[0]+=IK2PI;
}
j12valid[0] = true;
for(int ij12 = 0; ij12 < 1; ++ij12)
{
if( !j12valid[ij12] )
{
    continue;
}
_ij12[0] = ij12; _ij12[1] = -1;
for(int iij12 = ij12+1; iij12 < 1; ++iij12)
{
if( j12valid[iij12] && IKabs(cj12array[ij12]-cj12array[iij12]) < IKFAST_SOLUTION_THRESH && IKabs(sj12array[ij12]-sj12array[iij12]) < IKFAST_SOLUTION_THRESH )
{
    j12valid[iij12]=false; _ij12[1] = iij12; break; 
}
}
j12 = j12array[ij12]; cj12 = cj12array[ij12]; sj12 = sj12array[ij12];
{
IkReal evalcond[5];
IkReal x730=IKcos(j12);
IkReal x731=((1.0)*px);
IkReal x732=(cj10*x730);
IkReal x733=((0.3215)*x730);
evalcond[0]=((((-1.0)*py))+(((0.3215)*(IKsin(j12)))));
evalcond[1]=((0.117)+(((0.352)*cj10))+(((0.3215)*x732))+(((-1.0)*x731)));
evalcond[2]=((0.06)+(((-0.352)*sj10))+(((-1.0)*pz))+j5+(((-1.0)*sj10*x733)));
evalcond[3]=((0.352)+(((-0.06)*sj10))+(((0.117)*cj10))+(((-1.0)*j5*sj10))+((pz*sj10))+(((-1.0)*cj10*x731))+x733);
evalcond[4]=((0.24455525)+(((-1.0)*(j5*j5)))+(((-0.03858)*sj10*x730))+(((-0.04224)*sj10))+(((0.075231)*x732))+(((0.082368)*cj10))+(((0.226336)*x730))+(((-1.0)*pp))+(((2.0)*j5*pz)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((-3.14159265358979)+j9)))), 6.28318530717959)));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j12array[1], cj12array[1], sj12array[1];
bool j12valid[1]={false};
_nj12 = 1;
IkReal x734=((3.1104199066874)*sj10);
if( IKabs(((-3.1104199066874)*py)) < IKFAST_ATAN2_MAGTHRESH && IKabs(((-1.09486780715397)+(((-0.363919129082426)*cj10))+(((-3.1104199066874)*cj10*px))+((j5*x734))+(((0.186625194401244)*sj10))+(((-1.0)*pz*x734)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((-3.1104199066874)*py))+IKsqr(((-1.09486780715397)+(((-0.363919129082426)*cj10))+(((-3.1104199066874)*cj10*px))+((j5*x734))+(((0.186625194401244)*sj10))+(((-1.0)*pz*x734))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j12array[0]=IKatan2(((-3.1104199066874)*py), ((-1.09486780715397)+(((-0.363919129082426)*cj10))+(((-3.1104199066874)*cj10*px))+((j5*x734))+(((0.186625194401244)*sj10))+(((-1.0)*pz*x734))));
sj12array[0]=IKsin(j12array[0]);
cj12array[0]=IKcos(j12array[0]);
if( j12array[0] > IKPI )
{
    j12array[0]-=IK2PI;
}
else if( j12array[0] < -IKPI )
{    j12array[0]+=IK2PI;
}
j12valid[0] = true;
for(int ij12 = 0; ij12 < 1; ++ij12)
{
if( !j12valid[ij12] )
{
    continue;
}
_ij12[0] = ij12; _ij12[1] = -1;
for(int iij12 = ij12+1; iij12 < 1; ++iij12)
{
if( j12valid[iij12] && IKabs(cj12array[ij12]-cj12array[iij12]) < IKFAST_SOLUTION_THRESH && IKabs(sj12array[ij12]-sj12array[iij12]) < IKFAST_SOLUTION_THRESH )
{
    j12valid[iij12]=false; _ij12[1] = iij12; break; 
}
}
j12 = j12array[ij12]; cj12 = cj12array[ij12]; sj12 = sj12array[ij12];
{
IkReal evalcond[5];
IkReal x735=IKcos(j12);
IkReal x736=(cj10*x735);
IkReal x737=((0.3215)*x735);
evalcond[0]=((((-0.3215)*(IKsin(j12))))+(((-1.0)*py)));
evalcond[1]=((-0.117)+(((-0.3215)*x736))+(((-1.0)*px))+(((-0.352)*cj10)));
evalcond[2]=((0.06)+(((-0.352)*sj10))+(((-1.0)*pz))+j5+(((-1.0)*sj10*x737)));
evalcond[3]=((0.352)+((cj10*px))+(((-0.06)*sj10))+(((0.117)*cj10))+(((-1.0)*j5*sj10))+((pz*sj10))+x737);
evalcond[4]=((0.24455525)+(((-1.0)*(j5*j5)))+(((-0.03858)*sj10*x735))+(((-0.04224)*sj10))+(((0.075231)*x736))+(((0.082368)*cj10))+(((0.226336)*x735))+(((-1.0)*pp))+(((2.0)*j5*pz)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((-1.5707963267949)+j9)))), 6.28318530717959)));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j12array[1], cj12array[1], sj12array[1];
bool j12valid[1]={false};
_nj12 = 1;
IkReal x738=((3.1104199066874)*sj10);
if( IKabs(((-3.1104199066874)*px)) < IKFAST_ATAN2_MAGTHRESH && IKabs(((-1.09486780715397)+(((-0.363919129082426)*cj10))+((j5*x738))+(((3.1104199066874)*cj10*py))+(((0.186625194401244)*sj10))+(((-1.0)*pz*x738)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((-3.1104199066874)*px))+IKsqr(((-1.09486780715397)+(((-0.363919129082426)*cj10))+((j5*x738))+(((3.1104199066874)*cj10*py))+(((0.186625194401244)*sj10))+(((-1.0)*pz*x738))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j12array[0]=IKatan2(((-3.1104199066874)*px), ((-1.09486780715397)+(((-0.363919129082426)*cj10))+((j5*x738))+(((3.1104199066874)*cj10*py))+(((0.186625194401244)*sj10))+(((-1.0)*pz*x738))));
sj12array[0]=IKsin(j12array[0]);
cj12array[0]=IKcos(j12array[0]);
if( j12array[0] > IKPI )
{
    j12array[0]-=IK2PI;
}
else if( j12array[0] < -IKPI )
{    j12array[0]+=IK2PI;
}
j12valid[0] = true;
for(int ij12 = 0; ij12 < 1; ++ij12)
{
if( !j12valid[ij12] )
{
    continue;
}
_ij12[0] = ij12; _ij12[1] = -1;
for(int iij12 = ij12+1; iij12 < 1; ++iij12)
{
if( j12valid[iij12] && IKabs(cj12array[ij12]-cj12array[iij12]) < IKFAST_SOLUTION_THRESH && IKabs(sj12array[ij12]-sj12array[iij12]) < IKFAST_SOLUTION_THRESH )
{
    j12valid[iij12]=false; _ij12[1] = iij12; break; 
}
}
j12 = j12array[ij12]; cj12 = cj12array[ij12]; sj12 = sj12array[ij12];
{
IkReal evalcond[5];
IkReal x739=IKcos(j12);
IkReal x740=((1.0)*py);
IkReal x741=(cj10*x739);
IkReal x742=((0.3215)*x739);
evalcond[0]=((((-0.3215)*(IKsin(j12))))+(((-1.0)*px)));
evalcond[1]=((0.117)+(((0.3215)*x741))+(((0.352)*cj10))+(((-1.0)*x740)));
evalcond[2]=((0.06)+(((-0.352)*sj10))+(((-1.0)*sj10*x742))+(((-1.0)*pz))+j5);
evalcond[3]=((0.352)+(((-1.0)*cj10*x740))+(((-0.06)*sj10))+(((0.117)*cj10))+(((-1.0)*j5*sj10))+((pz*sj10))+x742);
evalcond[4]=((0.24455525)+(((-1.0)*(j5*j5)))+(((-0.03858)*sj10*x739))+(((-0.04224)*sj10))+(((0.082368)*cj10))+(((0.226336)*x739))+(((-1.0)*pp))+(((0.075231)*x741))+(((2.0)*j5*pz)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((1.5707963267949)+j9)))), 6.28318530717959)));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j12array[1], cj12array[1], sj12array[1];
bool j12valid[1]={false};
_nj12 = 1;
IkReal x743=((3.1104199066874)*sj10);
if( IKabs(((3.1104199066874)*px)) < IKFAST_ATAN2_MAGTHRESH && IKabs(((-1.09486780715397)+(((-0.363919129082426)*cj10))+(((-3.1104199066874)*cj10*py))+(((-1.0)*pz*x743))+(((0.186625194401244)*sj10))+((j5*x743)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((3.1104199066874)*px))+IKsqr(((-1.09486780715397)+(((-0.363919129082426)*cj10))+(((-3.1104199066874)*cj10*py))+(((-1.0)*pz*x743))+(((0.186625194401244)*sj10))+((j5*x743))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j12array[0]=IKatan2(((3.1104199066874)*px), ((-1.09486780715397)+(((-0.363919129082426)*cj10))+(((-3.1104199066874)*cj10*py))+(((-1.0)*pz*x743))+(((0.186625194401244)*sj10))+((j5*x743))));
sj12array[0]=IKsin(j12array[0]);
cj12array[0]=IKcos(j12array[0]);
if( j12array[0] > IKPI )
{
    j12array[0]-=IK2PI;
}
else if( j12array[0] < -IKPI )
{    j12array[0]+=IK2PI;
}
j12valid[0] = true;
for(int ij12 = 0; ij12 < 1; ++ij12)
{
if( !j12valid[ij12] )
{
    continue;
}
_ij12[0] = ij12; _ij12[1] = -1;
for(int iij12 = ij12+1; iij12 < 1; ++iij12)
{
if( j12valid[iij12] && IKabs(cj12array[ij12]-cj12array[iij12]) < IKFAST_SOLUTION_THRESH && IKabs(sj12array[ij12]-sj12array[iij12]) < IKFAST_SOLUTION_THRESH )
{
    j12valid[iij12]=false; _ij12[1] = iij12; break; 
}
}
j12 = j12array[ij12]; cj12 = cj12array[ij12]; sj12 = sj12array[ij12];
{
IkReal evalcond[5];
IkReal x744=IKcos(j12);
IkReal x745=(cj10*x744);
IkReal x746=((0.3215)*x744);
evalcond[0]=((((-1.0)*px))+(((0.3215)*(IKsin(j12)))));
evalcond[1]=((-0.117)+(((-0.3215)*x745))+(((-1.0)*py))+(((-0.352)*cj10)));
evalcond[2]=((0.06)+(((-0.352)*sj10))+(((-1.0)*sj10*x746))+(((-1.0)*pz))+j5);
evalcond[3]=((0.352)+((cj10*py))+(((-0.06)*sj10))+(((0.117)*cj10))+(((-1.0)*j5*sj10))+((pz*sj10))+x746);
evalcond[4]=((0.24455525)+(((-1.0)*(j5*j5)))+(((0.226336)*x744))+(((-0.04224)*sj10))+(((0.082368)*cj10))+(((-1.0)*pp))+(((-0.03858)*sj10*x744))+(((0.075231)*x745))+(((2.0)*j5*pz)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(j10))), 6.28318530717959)));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j12array[1], cj12array[1], sj12array[1];
bool j12valid[1]={false};
_nj12 = 1;
IkReal x747=((3.1104199066874)*px);
IkReal x748=((3.1104199066874)*py);
if( IKabs(((((-1.0)*sj9*x747))+((cj9*x748)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((-1.45878693623639)+((sj9*x748))+((cj9*x747)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((((-1.0)*sj9*x747))+((cj9*x748))))+IKsqr(((-1.45878693623639)+((sj9*x748))+((cj9*x747))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j12array[0]=IKatan2(((((-1.0)*sj9*x747))+((cj9*x748))), ((-1.45878693623639)+((sj9*x748))+((cj9*x747))));
sj12array[0]=IKsin(j12array[0]);
cj12array[0]=IKcos(j12array[0]);
if( j12array[0] > IKPI )
{
    j12array[0]-=IK2PI;
}
else if( j12array[0] < -IKPI )
{    j12array[0]+=IK2PI;
}
j12valid[0] = true;
for(int ij12 = 0; ij12 < 1; ++ij12)
{
if( !j12valid[ij12] )
{
    continue;
}
_ij12[0] = ij12; _ij12[1] = -1;
for(int iij12 = ij12+1; iij12 < 1; ++iij12)
{
if( j12valid[iij12] && IKabs(cj12array[ij12]-cj12array[iij12]) < IKFAST_SOLUTION_THRESH && IKabs(sj12array[ij12]-sj12array[iij12]) < IKFAST_SOLUTION_THRESH )
{
    j12valid[iij12]=false; _ij12[1] = iij12; break; 
}
}
j12 = j12array[ij12]; cj12 = cj12array[ij12]; sj12 = sj12array[ij12];
{
IkReal evalcond[5];
IkReal x749=IKcos(j12);
IkReal x750=IKsin(j12);
IkReal x751=((1.0)*py);
IkReal x752=((0.3215)*cj9);
IkReal x753=((1.0)*px);
IkReal x754=((0.3215)*x749);
IkReal x755=((0.3215)*x750);
evalcond[0]=((((-1.0)*cj9*x751))+((px*sj9))+x755);
evalcond[1]=((0.469)+(((-1.0)*cj9*x753))+x754+(((-1.0)*sj9*x751)));
evalcond[2]=((((0.469)*cj9))+(((-1.0)*sj9*x755))+((x749*x752))+(((-1.0)*x753)));
evalcond[3]=((((0.469)*sj9))+((sj9*x754))+((x750*x752))+(((-1.0)*x751)));
evalcond[4]=((0.32692325)+(((0.301567)*x749))+(((-1.0)*(j5*j5)))+(((-1.0)*pp))+(((2.0)*j5*pz)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((-3.14159265358979)+j10)))), 6.28318530717959)));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j12array[1], cj12array[1], sj12array[1];
bool j12valid[1]={false};
_nj12 = 1;
IkReal x756=((3.1104199066874)*px);
IkReal x757=((3.1104199066874)*py);
if( IKabs((((cj9*x757))+(((-1.0)*sj9*x756)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((-0.73094867807154)+(((-1.0)*cj9*x756))+(((-1.0)*sj9*x757)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr((((cj9*x757))+(((-1.0)*sj9*x756))))+IKsqr(((-0.73094867807154)+(((-1.0)*cj9*x756))+(((-1.0)*sj9*x757))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j12array[0]=IKatan2((((cj9*x757))+(((-1.0)*sj9*x756))), ((-0.73094867807154)+(((-1.0)*cj9*x756))+(((-1.0)*sj9*x757))));
sj12array[0]=IKsin(j12array[0]);
cj12array[0]=IKcos(j12array[0]);
if( j12array[0] > IKPI )
{
    j12array[0]-=IK2PI;
}
else if( j12array[0] < -IKPI )
{    j12array[0]+=IK2PI;
}
j12valid[0] = true;
for(int ij12 = 0; ij12 < 1; ++ij12)
{
if( !j12valid[ij12] )
{
    continue;
}
_ij12[0] = ij12; _ij12[1] = -1;
for(int iij12 = ij12+1; iij12 < 1; ++iij12)
{
if( j12valid[iij12] && IKabs(cj12array[ij12]-cj12array[iij12]) < IKFAST_SOLUTION_THRESH && IKabs(sj12array[ij12]-sj12array[iij12]) < IKFAST_SOLUTION_THRESH )
{
    j12valid[iij12]=false; _ij12[1] = iij12; break; 
}
}
j12 = j12array[ij12]; cj12 = cj12array[ij12]; sj12 = sj12array[ij12];
{
IkReal evalcond[5];
IkReal x758=IKsin(j12);
IkReal x759=IKcos(j12);
IkReal x760=((1.0)*py);
IkReal x761=((0.3215)*cj9);
IkReal x762=((0.3215)*x759);
IkReal x763=((0.3215)*x758);
evalcond[0]=((0.235)+((cj9*px))+x762+((py*sj9)));
evalcond[1]=((((-1.0)*cj9*x760))+((px*sj9))+x763);
evalcond[2]=((((-1.0)*sj9*x763))+(((-1.0)*px))+(((-0.235)*cj9))+(((-1.0)*x759*x761)));
evalcond[3]=((((-1.0)*sj9*x762))+(((-0.235)*sj9))+(((-1.0)*x760))+((x758*x761)));
evalcond[4]=((0.16218725)+(((0.151105)*x759))+(((-1.0)*(j5*j5)))+(((-1.0)*pp))+(((2.0)*j5*pz)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
if( 1 )
{
bgotonextstatement=false;
continue; // branch miss [j12]

}
} while(0);
if( bgotonextstatement )
{
}
}
}
}
}
}
}
}
}
}

} else
{
{
IkReal j12array[1], cj12array[1], sj12array[1];
bool j12valid[1]={false};
_nj12 = 1;
IkReal x764=((2000.0)*py);
IkReal x765=(px*sj9);
CheckValue<IkReal> x766=IKPowWithIntegerCheck(cj10,-1);
if(!x766.valid){
continue;
}
CheckValue<IkReal> x767=IKPowWithIntegerCheck(sj9,-1);
if(!x767.valid){
continue;
}
if( IKabs(((((3.1104199066874)*cj9*py))+(((-3.1104199066874)*x765)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((0.0015552099533437)*(x766.value)*(x767.value)*(((((-1.0)*x764*(cj9*cj9)))+(((-704.0)*cj10*sj9))+(((2000.0)*cj9*x765))+(((-234.0)*sj9))+x764)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((((3.1104199066874)*cj9*py))+(((-3.1104199066874)*x765))))+IKsqr(((0.0015552099533437)*(x766.value)*(x767.value)*(((((-1.0)*x764*(cj9*cj9)))+(((-704.0)*cj10*sj9))+(((2000.0)*cj9*x765))+(((-234.0)*sj9))+x764))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j12array[0]=IKatan2(((((3.1104199066874)*cj9*py))+(((-3.1104199066874)*x765))), ((0.0015552099533437)*(x766.value)*(x767.value)*(((((-1.0)*x764*(cj9*cj9)))+(((-704.0)*cj10*sj9))+(((2000.0)*cj9*x765))+(((-234.0)*sj9))+x764))));
sj12array[0]=IKsin(j12array[0]);
cj12array[0]=IKcos(j12array[0]);
if( j12array[0] > IKPI )
{
    j12array[0]-=IK2PI;
}
else if( j12array[0] < -IKPI )
{    j12array[0]+=IK2PI;
}
j12valid[0] = true;
for(int ij12 = 0; ij12 < 1; ++ij12)
{
if( !j12valid[ij12] )
{
    continue;
}
_ij12[0] = ij12; _ij12[1] = -1;
for(int iij12 = ij12+1; iij12 < 1; ++iij12)
{
if( j12valid[iij12] && IKabs(cj12array[ij12]-cj12array[iij12]) < IKFAST_SOLUTION_THRESH && IKabs(sj12array[ij12]-sj12array[iij12]) < IKFAST_SOLUTION_THRESH )
{
    j12valid[iij12]=false; _ij12[1] = iij12; break; 
}
}
j12 = j12array[ij12]; cj12 = cj12array[ij12]; sj12 = sj12array[ij12];
{
IkReal evalcond[6];
IkReal x768=IKcos(j12);
IkReal x769=IKsin(j12);
IkReal x770=((1.0)*py);
IkReal x771=(cj10*sj9);
IkReal x772=(cj10*cj9);
IkReal x773=((1.0)*px);
IkReal x774=((0.3215)*x768);
IkReal x775=((0.3215)*x769);
evalcond[0]=(((px*sj9))+x775+(((-1.0)*cj9*x770)));
evalcond[1]=((0.06)+(((-0.352)*sj10))+(((-1.0)*sj10*x774))+(((-1.0)*pz))+j5);
evalcond[2]=((((0.352)*x772))+((x772*x774))+(((0.117)*cj9))+(((-1.0)*x773))+(((-1.0)*sj9*x775)));
evalcond[3]=((((0.117)*sj9))+(((0.352)*x771))+((x771*x774))+((cj9*x775))+(((-1.0)*x770)));
evalcond[4]=((0.352)+(((-0.06)*sj10))+(((0.117)*cj10))+(((-1.0)*j5*sj10))+((pz*sj10))+(((-1.0)*x772*x773))+x774+(((-1.0)*x770*x771)));
evalcond[5]=((0.24455525)+(((-1.0)*(j5*j5)))+(((-0.03858)*sj10*x768))+(((-0.04224)*sj10))+(((0.082368)*cj10))+(((-1.0)*pp))+(((0.075231)*cj10*x768))+(((0.226336)*x768))+(((2.0)*j5*pz)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}

}

} else
{
{
IkReal j12array[1], cj12array[1], sj12array[1];
bool j12valid[1]={false};
_nj12 = 1;
IkReal x776=(cj9*py);
CheckValue<IkReal> x777=IKPowWithIntegerCheck(cj10,-1);
if(!x777.valid){
continue;
}
CheckValue<IkReal> x778=IKPowWithIntegerCheck(cj9,-1);
if(!x778.valid){
continue;
}
if( IKabs(((((-3.1104199066874)*px*sj9))+(((3.1104199066874)*x776)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((0.0015552099533437)*(x777.value)*(x778.value)*(((((2000.0)*sj9*x776))+(((-704.0)*cj10*cj9))+(((2000.0)*px*(cj9*cj9)))+(((-234.0)*cj9)))))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((((-3.1104199066874)*px*sj9))+(((3.1104199066874)*x776))))+IKsqr(((0.0015552099533437)*(x777.value)*(x778.value)*(((((2000.0)*sj9*x776))+(((-704.0)*cj10*cj9))+(((2000.0)*px*(cj9*cj9)))+(((-234.0)*cj9))))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j12array[0]=IKatan2(((((-3.1104199066874)*px*sj9))+(((3.1104199066874)*x776))), ((0.0015552099533437)*(x777.value)*(x778.value)*(((((2000.0)*sj9*x776))+(((-704.0)*cj10*cj9))+(((2000.0)*px*(cj9*cj9)))+(((-234.0)*cj9))))));
sj12array[0]=IKsin(j12array[0]);
cj12array[0]=IKcos(j12array[0]);
if( j12array[0] > IKPI )
{
    j12array[0]-=IK2PI;
}
else if( j12array[0] < -IKPI )
{    j12array[0]+=IK2PI;
}
j12valid[0] = true;
for(int ij12 = 0; ij12 < 1; ++ij12)
{
if( !j12valid[ij12] )
{
    continue;
}
_ij12[0] = ij12; _ij12[1] = -1;
for(int iij12 = ij12+1; iij12 < 1; ++iij12)
{
if( j12valid[iij12] && IKabs(cj12array[ij12]-cj12array[iij12]) < IKFAST_SOLUTION_THRESH && IKabs(sj12array[ij12]-sj12array[iij12]) < IKFAST_SOLUTION_THRESH )
{
    j12valid[iij12]=false; _ij12[1] = iij12; break; 
}
}
j12 = j12array[ij12]; cj12 = cj12array[ij12]; sj12 = sj12array[ij12];
{
IkReal evalcond[6];
IkReal x779=IKcos(j12);
IkReal x780=IKsin(j12);
IkReal x781=((1.0)*py);
IkReal x782=(cj10*sj9);
IkReal x783=(cj10*cj9);
IkReal x784=((1.0)*px);
IkReal x785=((0.3215)*x779);
IkReal x786=((0.3215)*x780);
evalcond[0]=((((-1.0)*cj9*x781))+((px*sj9))+x786);
evalcond[1]=((0.06)+(((-0.352)*sj10))+(((-1.0)*sj10*x785))+(((-1.0)*pz))+j5);
evalcond[2]=((((-1.0)*sj9*x786))+(((-1.0)*x784))+((x783*x785))+(((0.117)*cj9))+(((0.352)*x783)));
evalcond[3]=((((0.117)*sj9))+(((-1.0)*x781))+((x782*x785))+((cj9*x786))+(((0.352)*x782)));
evalcond[4]=((0.352)+(((-0.06)*sj10))+(((-1.0)*x781*x782))+(((0.117)*cj10))+(((-1.0)*j5*sj10))+((pz*sj10))+x785+(((-1.0)*x783*x784)));
evalcond[5]=((0.24455525)+(((-1.0)*(j5*j5)))+(((-0.04224)*sj10))+(((0.226336)*x779))+(((0.082368)*cj10))+(((0.075231)*cj10*x779))+(((-1.0)*pp))+(((-0.03858)*sj10*x779))+(((2.0)*j5*pz)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}

}

} else
{
{
IkReal j12array[1], cj12array[1], sj12array[1];
bool j12valid[1]={false};
_nj12 = 1;
CheckValue<IkReal> x787=IKPowWithIntegerCheck(sj10,-1);
if(!x787.valid){
continue;
}
if( IKabs(((((-3.1104199066874)*px*sj9))+(((3.1104199066874)*cj9*py)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((0.0015552099533437)*(x787.value)*(((120.0)+(((-704.0)*sj10))+(((2000.0)*j5))+(((-2000.0)*pz)))))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((((-3.1104199066874)*px*sj9))+(((3.1104199066874)*cj9*py))))+IKsqr(((0.0015552099533437)*(x787.value)*(((120.0)+(((-704.0)*sj10))+(((2000.0)*j5))+(((-2000.0)*pz))))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j12array[0]=IKatan2(((((-3.1104199066874)*px*sj9))+(((3.1104199066874)*cj9*py))), ((0.0015552099533437)*(x787.value)*(((120.0)+(((-704.0)*sj10))+(((2000.0)*j5))+(((-2000.0)*pz))))));
sj12array[0]=IKsin(j12array[0]);
cj12array[0]=IKcos(j12array[0]);
if( j12array[0] > IKPI )
{
    j12array[0]-=IK2PI;
}
else if( j12array[0] < -IKPI )
{    j12array[0]+=IK2PI;
}
j12valid[0] = true;
for(int ij12 = 0; ij12 < 1; ++ij12)
{
if( !j12valid[ij12] )
{
    continue;
}
_ij12[0] = ij12; _ij12[1] = -1;
for(int iij12 = ij12+1; iij12 < 1; ++iij12)
{
if( j12valid[iij12] && IKabs(cj12array[ij12]-cj12array[iij12]) < IKFAST_SOLUTION_THRESH && IKabs(sj12array[ij12]-sj12array[iij12]) < IKFAST_SOLUTION_THRESH )
{
    j12valid[iij12]=false; _ij12[1] = iij12; break; 
}
}
j12 = j12array[ij12]; cj12 = cj12array[ij12]; sj12 = sj12array[ij12];
{
IkReal evalcond[6];
IkReal x788=IKcos(j12);
IkReal x789=IKsin(j12);
IkReal x790=((1.0)*py);
IkReal x791=(cj10*sj9);
IkReal x792=(cj10*cj9);
IkReal x793=((1.0)*px);
IkReal x794=((0.3215)*x788);
IkReal x795=((0.3215)*x789);
evalcond[0]=((((-1.0)*cj9*x790))+((px*sj9))+x795);
evalcond[1]=((0.06)+(((-0.352)*sj10))+(((-1.0)*sj10*x794))+(((-1.0)*pz))+j5);
evalcond[2]=((((-1.0)*x793))+(((-1.0)*sj9*x795))+((x792*x794))+(((0.117)*cj9))+(((0.352)*x792)));
evalcond[3]=((((0.117)*sj9))+(((-1.0)*x790))+((cj9*x795))+((x791*x794))+(((0.352)*x791)));
evalcond[4]=((0.352)+(((-1.0)*x792*x793))+(((-0.06)*sj10))+(((0.117)*cj10))+(((-1.0)*j5*sj10))+((pz*sj10))+(((-1.0)*x790*x791))+x794);
evalcond[5]=((0.24455525)+(((-1.0)*(j5*j5)))+(((-0.04224)*sj10))+(((-0.03858)*sj10*x788))+(((0.082368)*cj10))+(((0.075231)*cj10*x788))+(((-1.0)*pp))+(((0.226336)*x788))+(((2.0)*j5*pz)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}

}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((1.5707963267949)+j11)))), 6.28318530717959)));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j12eval[1];
sj11=-1.0;
cj11=0;
j11=-1.5707963267949;
j12eval[0]=sj10;
if( IKabs(j12eval[0]) < 0.0000010000000000  )
{
{
IkReal j12eval[2];
sj11=-1.0;
cj11=0;
j11=-1.5707963267949;
j12eval[0]=cj10;
j12eval[1]=cj9;
if( IKabs(j12eval[0]) < 0.0000010000000000  || IKabs(j12eval[1]) < 0.0000010000000000  )
{
{
IkReal j12eval[2];
sj11=-1.0;
cj11=0;
j11=-1.5707963267949;
j12eval[0]=cj10;
j12eval[1]=sj9;
if( IKabs(j12eval[0]) < 0.0000010000000000  || IKabs(j12eval[1]) < 0.0000010000000000  )
{
{
IkReal evalcond[1];
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((-1.5707963267949)+j10)))), 6.28318530717959)));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j12array[1], cj12array[1], sj12array[1];
bool j12valid[1]={false};
_nj12 = 1;
if( IKabs(((((-3.1104199066874)*cj9*py))+(((3.1104199066874)*px*sj9)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((-0.908242612752722)+(((3.1104199066874)*j5))+(((-3.1104199066874)*pz)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((((-3.1104199066874)*cj9*py))+(((3.1104199066874)*px*sj9))))+IKsqr(((-0.908242612752722)+(((3.1104199066874)*j5))+(((-3.1104199066874)*pz))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j12array[0]=IKatan2(((((-3.1104199066874)*cj9*py))+(((3.1104199066874)*px*sj9))), ((-0.908242612752722)+(((3.1104199066874)*j5))+(((-3.1104199066874)*pz))));
sj12array[0]=IKsin(j12array[0]);
cj12array[0]=IKcos(j12array[0]);
if( j12array[0] > IKPI )
{
    j12array[0]-=IK2PI;
}
else if( j12array[0] < -IKPI )
{    j12array[0]+=IK2PI;
}
j12valid[0] = true;
for(int ij12 = 0; ij12 < 1; ++ij12)
{
if( !j12valid[ij12] )
{
    continue;
}
_ij12[0] = ij12; _ij12[1] = -1;
for(int iij12 = ij12+1; iij12 < 1; ++iij12)
{
if( j12valid[iij12] && IKabs(cj12array[ij12]-cj12array[iij12]) < IKFAST_SOLUTION_THRESH && IKabs(sj12array[ij12]-sj12array[iij12]) < IKFAST_SOLUTION_THRESH )
{
    j12valid[iij12]=false; _ij12[1] = iij12; break; 
}
}
j12 = j12array[ij12]; cj12 = cj12array[ij12]; sj12 = sj12array[ij12];
{
IkReal evalcond[5];
IkReal x796=IKsin(j12);
IkReal x797=IKcos(j12);
IkReal x798=((1.0)*px);
IkReal x799=((0.3215)*x796);
evalcond[0]=((-0.292)+(((-0.3215)*x797))+(((-1.0)*pz))+j5);
evalcond[1]=((((-1.0)*x798))+(((0.117)*cj9))+((sj9*x799)));
evalcond[2]=((((0.117)*sj9))+(((-1.0)*py))+(((-1.0)*cj9*x799)));
evalcond[3]=((((-1.0)*sj9*x798))+((cj9*py))+x799);
evalcond[4]=((0.20231525)+(((-1.0)*(j5*j5)))+(((-1.0)*pp))+(((0.187756)*x797))+(((2.0)*j5*pz)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((1.5707963267949)+j10)))), 6.28318530717959)));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j12array[1], cj12array[1], sj12array[1];
bool j12valid[1]={false};
_nj12 = 1;
if( IKabs(((((-3.1104199066874)*cj9*py))+(((3.1104199066874)*px*sj9)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((-1.28149300155521)+(((3.1104199066874)*pz))+(((-3.1104199066874)*j5)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((((-3.1104199066874)*cj9*py))+(((3.1104199066874)*px*sj9))))+IKsqr(((-1.28149300155521)+(((3.1104199066874)*pz))+(((-3.1104199066874)*j5))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j12array[0]=IKatan2(((((-3.1104199066874)*cj9*py))+(((3.1104199066874)*px*sj9))), ((-1.28149300155521)+(((3.1104199066874)*pz))+(((-3.1104199066874)*j5))));
sj12array[0]=IKsin(j12array[0]);
cj12array[0]=IKcos(j12array[0]);
if( j12array[0] > IKPI )
{
    j12array[0]-=IK2PI;
}
else if( j12array[0] < -IKPI )
{    j12array[0]+=IK2PI;
}
j12valid[0] = true;
for(int ij12 = 0; ij12 < 1; ++ij12)
{
if( !j12valid[ij12] )
{
    continue;
}
_ij12[0] = ij12; _ij12[1] = -1;
for(int iij12 = ij12+1; iij12 < 1; ++iij12)
{
if( j12valid[iij12] && IKabs(cj12array[ij12]-cj12array[iij12]) < IKFAST_SOLUTION_THRESH && IKabs(sj12array[ij12]-sj12array[iij12]) < IKFAST_SOLUTION_THRESH )
{
    j12valid[iij12]=false; _ij12[1] = iij12; break; 
}
}
j12 = j12array[ij12]; cj12 = cj12array[ij12]; sj12 = sj12array[ij12];
{
IkReal evalcond[5];
IkReal x800=IKsin(j12);
IkReal x801=IKcos(j12);
IkReal x802=((1.0)*px);
IkReal x803=((0.3215)*x800);
evalcond[0]=((0.412)+(((-1.0)*pz))+(((0.3215)*x801))+j5);
evalcond[1]=(((sj9*x803))+(((0.117)*cj9))+(((-1.0)*x802)));
evalcond[2]=((((0.117)*sj9))+(((-1.0)*cj9*x803))+(((-1.0)*py)));
evalcond[3]=(((cj9*py))+(((-1.0)*sj9*x802))+x803);
evalcond[4]=((0.28679525)+(((-1.0)*(j5*j5)))+(((-1.0)*pp))+(((0.264916)*x801))+(((2.0)*j5*pz)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(j9))), 6.28318530717959)));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j12array[1], cj12array[1], sj12array[1];
bool j12valid[1]={false};
_nj12 = 1;
IkReal x804=((3.1104199066874)*sj10);
if( IKabs(((-3.1104199066874)*py)) < IKFAST_ATAN2_MAGTHRESH && IKabs(((-1.09486780715397)+(((-0.363919129082426)*cj10))+((j5*x804))+(((3.1104199066874)*cj10*px))+(((0.186625194401244)*sj10))+(((-1.0)*pz*x804)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((-3.1104199066874)*py))+IKsqr(((-1.09486780715397)+(((-0.363919129082426)*cj10))+((j5*x804))+(((3.1104199066874)*cj10*px))+(((0.186625194401244)*sj10))+(((-1.0)*pz*x804))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j12array[0]=IKatan2(((-3.1104199066874)*py), ((-1.09486780715397)+(((-0.363919129082426)*cj10))+((j5*x804))+(((3.1104199066874)*cj10*px))+(((0.186625194401244)*sj10))+(((-1.0)*pz*x804))));
sj12array[0]=IKsin(j12array[0]);
cj12array[0]=IKcos(j12array[0]);
if( j12array[0] > IKPI )
{
    j12array[0]-=IK2PI;
}
else if( j12array[0] < -IKPI )
{    j12array[0]+=IK2PI;
}
j12valid[0] = true;
for(int ij12 = 0; ij12 < 1; ++ij12)
{
if( !j12valid[ij12] )
{
    continue;
}
_ij12[0] = ij12; _ij12[1] = -1;
for(int iij12 = ij12+1; iij12 < 1; ++iij12)
{
if( j12valid[iij12] && IKabs(cj12array[ij12]-cj12array[iij12]) < IKFAST_SOLUTION_THRESH && IKabs(sj12array[ij12]-sj12array[iij12]) < IKFAST_SOLUTION_THRESH )
{
    j12valid[iij12]=false; _ij12[1] = iij12; break; 
}
}
j12 = j12array[ij12]; cj12 = cj12array[ij12]; sj12 = sj12array[ij12];
{
IkReal evalcond[5];
IkReal x805=IKcos(j12);
IkReal x806=((1.0)*px);
IkReal x807=(cj10*x805);
IkReal x808=((0.3215)*x805);
evalcond[0]=((((-0.3215)*(IKsin(j12))))+(((-1.0)*py)));
evalcond[1]=((0.117)+(((0.352)*cj10))+(((0.3215)*x807))+(((-1.0)*x806)));
evalcond[2]=((0.06)+(((-0.352)*sj10))+(((-1.0)*pz))+(((-1.0)*sj10*x808))+j5);
evalcond[3]=((0.352)+(((-1.0)*cj10*x806))+(((-0.06)*sj10))+(((0.117)*cj10))+(((-1.0)*j5*sj10))+((pz*sj10))+x808);
evalcond[4]=((0.24455525)+(((-1.0)*(j5*j5)))+(((-0.04224)*sj10))+(((0.082368)*cj10))+(((-0.03858)*sj10*x805))+(((-1.0)*pp))+(((0.075231)*x807))+(((0.226336)*x805))+(((2.0)*j5*pz)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((-3.14159265358979)+j9)))), 6.28318530717959)));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j12array[1], cj12array[1], sj12array[1];
bool j12valid[1]={false};
_nj12 = 1;
IkReal x809=((3.1104199066874)*sj10);
if( IKabs(((3.1104199066874)*py)) < IKFAST_ATAN2_MAGTHRESH && IKabs(((-1.09486780715397)+(((-0.363919129082426)*cj10))+((j5*x809))+(((-3.1104199066874)*cj10*px))+(((0.186625194401244)*sj10))+(((-1.0)*pz*x809)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((3.1104199066874)*py))+IKsqr(((-1.09486780715397)+(((-0.363919129082426)*cj10))+((j5*x809))+(((-3.1104199066874)*cj10*px))+(((0.186625194401244)*sj10))+(((-1.0)*pz*x809))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j12array[0]=IKatan2(((3.1104199066874)*py), ((-1.09486780715397)+(((-0.363919129082426)*cj10))+((j5*x809))+(((-3.1104199066874)*cj10*px))+(((0.186625194401244)*sj10))+(((-1.0)*pz*x809))));
sj12array[0]=IKsin(j12array[0]);
cj12array[0]=IKcos(j12array[0]);
if( j12array[0] > IKPI )
{
    j12array[0]-=IK2PI;
}
else if( j12array[0] < -IKPI )
{    j12array[0]+=IK2PI;
}
j12valid[0] = true;
for(int ij12 = 0; ij12 < 1; ++ij12)
{
if( !j12valid[ij12] )
{
    continue;
}
_ij12[0] = ij12; _ij12[1] = -1;
for(int iij12 = ij12+1; iij12 < 1; ++iij12)
{
if( j12valid[iij12] && IKabs(cj12array[ij12]-cj12array[iij12]) < IKFAST_SOLUTION_THRESH && IKabs(sj12array[ij12]-sj12array[iij12]) < IKFAST_SOLUTION_THRESH )
{
    j12valid[iij12]=false; _ij12[1] = iij12; break; 
}
}
j12 = j12array[ij12]; cj12 = cj12array[ij12]; sj12 = sj12array[ij12];
{
IkReal evalcond[5];
IkReal x810=IKcos(j12);
IkReal x811=(cj10*x810);
IkReal x812=((0.3215)*x810);
evalcond[0]=((((-1.0)*py))+(((0.3215)*(IKsin(j12)))));
evalcond[1]=((-0.117)+(((-0.3215)*x811))+(((-1.0)*px))+(((-0.352)*cj10)));
evalcond[2]=((0.06)+(((-0.352)*sj10))+(((-1.0)*pz))+j5+(((-1.0)*sj10*x812)));
evalcond[3]=((0.352)+((cj10*px))+(((-0.06)*sj10))+(((0.117)*cj10))+(((-1.0)*j5*sj10))+((pz*sj10))+x812);
evalcond[4]=((0.24455525)+(((-1.0)*(j5*j5)))+(((-0.04224)*sj10))+(((0.226336)*x810))+(((0.082368)*cj10))+(((-1.0)*pp))+(((-0.03858)*sj10*x810))+(((0.075231)*x811))+(((2.0)*j5*pz)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((-1.5707963267949)+j9)))), 6.28318530717959)));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j12array[1], cj12array[1], sj12array[1];
bool j12valid[1]={false};
_nj12 = 1;
IkReal x813=((3.1104199066874)*sj10);
if( IKabs(((3.1104199066874)*px)) < IKFAST_ATAN2_MAGTHRESH && IKabs(((-1.09486780715397)+(((-0.363919129082426)*cj10))+(((-1.0)*pz*x813))+(((3.1104199066874)*cj10*py))+(((0.186625194401244)*sj10))+((j5*x813)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((3.1104199066874)*px))+IKsqr(((-1.09486780715397)+(((-0.363919129082426)*cj10))+(((-1.0)*pz*x813))+(((3.1104199066874)*cj10*py))+(((0.186625194401244)*sj10))+((j5*x813))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j12array[0]=IKatan2(((3.1104199066874)*px), ((-1.09486780715397)+(((-0.363919129082426)*cj10))+(((-1.0)*pz*x813))+(((3.1104199066874)*cj10*py))+(((0.186625194401244)*sj10))+((j5*x813))));
sj12array[0]=IKsin(j12array[0]);
cj12array[0]=IKcos(j12array[0]);
if( j12array[0] > IKPI )
{
    j12array[0]-=IK2PI;
}
else if( j12array[0] < -IKPI )
{    j12array[0]+=IK2PI;
}
j12valid[0] = true;
for(int ij12 = 0; ij12 < 1; ++ij12)
{
if( !j12valid[ij12] )
{
    continue;
}
_ij12[0] = ij12; _ij12[1] = -1;
for(int iij12 = ij12+1; iij12 < 1; ++iij12)
{
if( j12valid[iij12] && IKabs(cj12array[ij12]-cj12array[iij12]) < IKFAST_SOLUTION_THRESH && IKabs(sj12array[ij12]-sj12array[iij12]) < IKFAST_SOLUTION_THRESH )
{
    j12valid[iij12]=false; _ij12[1] = iij12; break; 
}
}
j12 = j12array[ij12]; cj12 = cj12array[ij12]; sj12 = sj12array[ij12];
{
IkReal evalcond[5];
IkReal x814=IKcos(j12);
IkReal x815=((1.0)*py);
IkReal x816=(cj10*x814);
IkReal x817=((0.3215)*x814);
evalcond[0]=((((-1.0)*px))+(((0.3215)*(IKsin(j12)))));
evalcond[1]=((0.117)+(((0.352)*cj10))+(((0.3215)*x816))+(((-1.0)*x815)));
evalcond[2]=((0.06)+(((-0.352)*sj10))+(((-1.0)*pz))+j5+(((-1.0)*sj10*x817)));
evalcond[3]=((0.352)+(((-0.06)*sj10))+(((0.117)*cj10))+(((-1.0)*j5*sj10))+((pz*sj10))+(((-1.0)*cj10*x815))+x817);
evalcond[4]=((0.24455525)+(((-1.0)*(j5*j5)))+(((-0.04224)*sj10))+(((0.226336)*x814))+(((0.082368)*cj10))+(((-1.0)*pp))+(((-0.03858)*sj10*x814))+(((0.075231)*x816))+(((2.0)*j5*pz)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((1.5707963267949)+j9)))), 6.28318530717959)));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j12array[1], cj12array[1], sj12array[1];
bool j12valid[1]={false};
_nj12 = 1;
IkReal x818=((3.1104199066874)*sj10);
if( IKabs(((-3.1104199066874)*px)) < IKFAST_ATAN2_MAGTHRESH && IKabs(((-1.09486780715397)+(((-0.363919129082426)*cj10))+(((-3.1104199066874)*cj10*py))+(((-1.0)*pz*x818))+(((0.186625194401244)*sj10))+((j5*x818)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((-3.1104199066874)*px))+IKsqr(((-1.09486780715397)+(((-0.363919129082426)*cj10))+(((-3.1104199066874)*cj10*py))+(((-1.0)*pz*x818))+(((0.186625194401244)*sj10))+((j5*x818))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j12array[0]=IKatan2(((-3.1104199066874)*px), ((-1.09486780715397)+(((-0.363919129082426)*cj10))+(((-3.1104199066874)*cj10*py))+(((-1.0)*pz*x818))+(((0.186625194401244)*sj10))+((j5*x818))));
sj12array[0]=IKsin(j12array[0]);
cj12array[0]=IKcos(j12array[0]);
if( j12array[0] > IKPI )
{
    j12array[0]-=IK2PI;
}
else if( j12array[0] < -IKPI )
{    j12array[0]+=IK2PI;
}
j12valid[0] = true;
for(int ij12 = 0; ij12 < 1; ++ij12)
{
if( !j12valid[ij12] )
{
    continue;
}
_ij12[0] = ij12; _ij12[1] = -1;
for(int iij12 = ij12+1; iij12 < 1; ++iij12)
{
if( j12valid[iij12] && IKabs(cj12array[ij12]-cj12array[iij12]) < IKFAST_SOLUTION_THRESH && IKabs(sj12array[ij12]-sj12array[iij12]) < IKFAST_SOLUTION_THRESH )
{
    j12valid[iij12]=false; _ij12[1] = iij12; break; 
}
}
j12 = j12array[ij12]; cj12 = cj12array[ij12]; sj12 = sj12array[ij12];
{
IkReal evalcond[5];
IkReal x819=IKcos(j12);
IkReal x820=(cj10*x819);
IkReal x821=((0.3215)*x819);
evalcond[0]=((((-0.3215)*(IKsin(j12))))+(((-1.0)*px)));
evalcond[1]=((-0.117)+(((-0.3215)*x820))+(((-1.0)*py))+(((-0.352)*cj10)));
evalcond[2]=((0.06)+(((-0.352)*sj10))+(((-1.0)*sj10*x821))+(((-1.0)*pz))+j5);
evalcond[3]=((0.352)+((cj10*py))+(((-0.06)*sj10))+(((0.117)*cj10))+(((-1.0)*j5*sj10))+((pz*sj10))+x821);
evalcond[4]=((0.24455525)+(((-1.0)*(j5*j5)))+(((0.075231)*x820))+(((-0.04224)*sj10))+(((0.226336)*x819))+(((0.082368)*cj10))+(((-1.0)*pp))+(((-0.03858)*sj10*x819))+(((2.0)*j5*pz)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(j10))), 6.28318530717959)));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j12array[1], cj12array[1], sj12array[1];
bool j12valid[1]={false};
_nj12 = 1;
IkReal x822=((3.1104199066874)*px);
IkReal x823=((3.1104199066874)*py);
if( IKabs((((sj9*x822))+(((-1.0)*cj9*x823)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((-1.45878693623639)+((sj9*x823))+((cj9*x822)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr((((sj9*x822))+(((-1.0)*cj9*x823))))+IKsqr(((-1.45878693623639)+((sj9*x823))+((cj9*x822))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j12array[0]=IKatan2((((sj9*x822))+(((-1.0)*cj9*x823))), ((-1.45878693623639)+((sj9*x823))+((cj9*x822))));
sj12array[0]=IKsin(j12array[0]);
cj12array[0]=IKcos(j12array[0]);
if( j12array[0] > IKPI )
{
    j12array[0]-=IK2PI;
}
else if( j12array[0] < -IKPI )
{    j12array[0]+=IK2PI;
}
j12valid[0] = true;
for(int ij12 = 0; ij12 < 1; ++ij12)
{
if( !j12valid[ij12] )
{
    continue;
}
_ij12[0] = ij12; _ij12[1] = -1;
for(int iij12 = ij12+1; iij12 < 1; ++iij12)
{
if( j12valid[iij12] && IKabs(cj12array[ij12]-cj12array[iij12]) < IKFAST_SOLUTION_THRESH && IKabs(sj12array[ij12]-sj12array[iij12]) < IKFAST_SOLUTION_THRESH )
{
    j12valid[iij12]=false; _ij12[1] = iij12; break; 
}
}
j12 = j12array[ij12]; cj12 = cj12array[ij12]; sj12 = sj12array[ij12];
{
IkReal evalcond[5];
IkReal x824=IKsin(j12);
IkReal x825=IKcos(j12);
IkReal x826=((0.3215)*cj9);
IkReal x827=((1.0)*px);
IkReal x828=((1.0)*py);
IkReal x829=((0.3215)*x825);
IkReal x830=((0.3215)*x824);
evalcond[0]=((((-1.0)*sj9*x827))+((cj9*py))+x830);
evalcond[1]=((0.469)+(((-1.0)*sj9*x828))+x829+(((-1.0)*cj9*x827)));
evalcond[2]=((((-1.0)*x827))+((x825*x826))+((sj9*x830))+(((0.469)*cj9)));
evalcond[3]=((((0.469)*sj9))+(((-1.0)*x828))+(((-1.0)*x824*x826))+((sj9*x829)));
evalcond[4]=((0.32692325)+(((-1.0)*(j5*j5)))+(((0.301567)*x825))+(((-1.0)*pp))+(((2.0)*j5*pz)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((-3.14159265358979)+j10)))), 6.28318530717959)));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j12array[1], cj12array[1], sj12array[1];
bool j12valid[1]={false};
_nj12 = 1;
IkReal x831=((3.1104199066874)*px);
IkReal x832=((3.1104199066874)*py);
if( IKabs((((sj9*x831))+(((-1.0)*cj9*x832)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((-0.73094867807154)+(((-1.0)*cj9*x831))+(((-1.0)*sj9*x832)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr((((sj9*x831))+(((-1.0)*cj9*x832))))+IKsqr(((-0.73094867807154)+(((-1.0)*cj9*x831))+(((-1.0)*sj9*x832))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j12array[0]=IKatan2((((sj9*x831))+(((-1.0)*cj9*x832))), ((-0.73094867807154)+(((-1.0)*cj9*x831))+(((-1.0)*sj9*x832))));
sj12array[0]=IKsin(j12array[0]);
cj12array[0]=IKcos(j12array[0]);
if( j12array[0] > IKPI )
{
    j12array[0]-=IK2PI;
}
else if( j12array[0] < -IKPI )
{    j12array[0]+=IK2PI;
}
j12valid[0] = true;
for(int ij12 = 0; ij12 < 1; ++ij12)
{
if( !j12valid[ij12] )
{
    continue;
}
_ij12[0] = ij12; _ij12[1] = -1;
for(int iij12 = ij12+1; iij12 < 1; ++iij12)
{
if( j12valid[iij12] && IKabs(cj12array[ij12]-cj12array[iij12]) < IKFAST_SOLUTION_THRESH && IKabs(sj12array[ij12]-sj12array[iij12]) < IKFAST_SOLUTION_THRESH )
{
    j12valid[iij12]=false; _ij12[1] = iij12; break; 
}
}
j12 = j12array[ij12]; cj12 = cj12array[ij12]; sj12 = sj12array[ij12];
{
IkReal evalcond[5];
IkReal x833=IKsin(j12);
IkReal x834=IKcos(j12);
IkReal x835=((1.0)*px);
IkReal x836=((0.3215)*x833);
IkReal x837=((0.3215)*x834);
evalcond[0]=((0.235)+((cj9*px))+x837+((py*sj9)));
evalcond[1]=(((cj9*py))+x836+(((-1.0)*sj9*x835)));
evalcond[2]=(((sj9*x836))+(((-1.0)*x835))+(((-0.235)*cj9))+(((-1.0)*cj9*x837)));
evalcond[3]=((((-0.235)*sj9))+(((-1.0)*py))+(((-1.0)*cj9*x836))+(((-1.0)*sj9*x837)));
evalcond[4]=((0.16218725)+(((-1.0)*(j5*j5)))+(((-1.0)*pp))+(((0.151105)*x834))+(((2.0)*j5*pz)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
if( 1 )
{
bgotonextstatement=false;
continue; // branch miss [j12]

}
} while(0);
if( bgotonextstatement )
{
}
}
}
}
}
}
}
}
}
}

} else
{
{
IkReal j12array[1], cj12array[1], sj12array[1];
bool j12valid[1]={false};
_nj12 = 1;
IkReal x838=((2000.0)*py);
IkReal x839=(px*sj9);
CheckValue<IkReal> x840=IKPowWithIntegerCheck(cj10,-1);
if(!x840.valid){
continue;
}
CheckValue<IkReal> x841=IKPowWithIntegerCheck(sj9,-1);
if(!x841.valid){
continue;
}
if( IKabs(((((-3.1104199066874)*cj9*py))+(((3.1104199066874)*x839)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((0.0015552099533437)*(x840.value)*(x841.value)*(((((2000.0)*cj9*x839))+(((-704.0)*cj10*sj9))+(((-234.0)*sj9))+x838+(((-1.0)*x838*(cj9*cj9))))))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((((-3.1104199066874)*cj9*py))+(((3.1104199066874)*x839))))+IKsqr(((0.0015552099533437)*(x840.value)*(x841.value)*(((((2000.0)*cj9*x839))+(((-704.0)*cj10*sj9))+(((-234.0)*sj9))+x838+(((-1.0)*x838*(cj9*cj9)))))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j12array[0]=IKatan2(((((-3.1104199066874)*cj9*py))+(((3.1104199066874)*x839))), ((0.0015552099533437)*(x840.value)*(x841.value)*(((((2000.0)*cj9*x839))+(((-704.0)*cj10*sj9))+(((-234.0)*sj9))+x838+(((-1.0)*x838*(cj9*cj9)))))));
sj12array[0]=IKsin(j12array[0]);
cj12array[0]=IKcos(j12array[0]);
if( j12array[0] > IKPI )
{
    j12array[0]-=IK2PI;
}
else if( j12array[0] < -IKPI )
{    j12array[0]+=IK2PI;
}
j12valid[0] = true;
for(int ij12 = 0; ij12 < 1; ++ij12)
{
if( !j12valid[ij12] )
{
    continue;
}
_ij12[0] = ij12; _ij12[1] = -1;
for(int iij12 = ij12+1; iij12 < 1; ++iij12)
{
if( j12valid[iij12] && IKabs(cj12array[ij12]-cj12array[iij12]) < IKFAST_SOLUTION_THRESH && IKabs(sj12array[ij12]-sj12array[iij12]) < IKFAST_SOLUTION_THRESH )
{
    j12valid[iij12]=false; _ij12[1] = iij12; break; 
}
}
j12 = j12array[ij12]; cj12 = cj12array[ij12]; sj12 = sj12array[ij12];
{
IkReal evalcond[6];
IkReal x842=IKcos(j12);
IkReal x843=IKsin(j12);
IkReal x844=((1.0)*py);
IkReal x845=(cj10*sj9);
IkReal x846=(cj10*cj9);
IkReal x847=((1.0)*px);
IkReal x848=((0.3215)*x842);
IkReal x849=((0.3215)*x843);
evalcond[0]=(((cj9*py))+x849+(((-1.0)*sj9*x847)));
evalcond[1]=((0.06)+(((-0.352)*sj10))+(((-1.0)*sj10*x848))+(((-1.0)*pz))+j5);
evalcond[2]=(((x846*x848))+((sj9*x849))+(((0.352)*x846))+(((-1.0)*x847))+(((0.117)*cj9)));
evalcond[3]=((((0.117)*sj9))+(((0.352)*x845))+(((-1.0)*x844))+((x845*x848))+(((-1.0)*cj9*x849)));
evalcond[4]=((0.352)+(((-0.06)*sj10))+(((0.117)*cj10))+(((-1.0)*j5*sj10))+((pz*sj10))+(((-1.0)*x846*x847))+(((-1.0)*x844*x845))+x848);
evalcond[5]=((0.24455525)+(((-1.0)*(j5*j5)))+(((-0.04224)*sj10))+(((0.075231)*cj10*x842))+(((0.082368)*cj10))+(((-1.0)*pp))+(((-0.03858)*sj10*x842))+(((0.226336)*x842))+(((2.0)*j5*pz)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}

}

} else
{
{
IkReal j12array[1], cj12array[1], sj12array[1];
bool j12valid[1]={false};
_nj12 = 1;
IkReal x850=(cj9*py);
CheckValue<IkReal> x851=IKPowWithIntegerCheck(cj10,-1);
if(!x851.valid){
continue;
}
CheckValue<IkReal> x852=IKPowWithIntegerCheck(cj9,-1);
if(!x852.valid){
continue;
}
if( IKabs(((((-3.1104199066874)*x850))+(((3.1104199066874)*px*sj9)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((0.0015552099533437)*(x851.value)*(x852.value)*(((((2000.0)*sj9*x850))+(((-704.0)*cj10*cj9))+(((2000.0)*px*(cj9*cj9)))+(((-234.0)*cj9)))))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((((-3.1104199066874)*x850))+(((3.1104199066874)*px*sj9))))+IKsqr(((0.0015552099533437)*(x851.value)*(x852.value)*(((((2000.0)*sj9*x850))+(((-704.0)*cj10*cj9))+(((2000.0)*px*(cj9*cj9)))+(((-234.0)*cj9))))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j12array[0]=IKatan2(((((-3.1104199066874)*x850))+(((3.1104199066874)*px*sj9))), ((0.0015552099533437)*(x851.value)*(x852.value)*(((((2000.0)*sj9*x850))+(((-704.0)*cj10*cj9))+(((2000.0)*px*(cj9*cj9)))+(((-234.0)*cj9))))));
sj12array[0]=IKsin(j12array[0]);
cj12array[0]=IKcos(j12array[0]);
if( j12array[0] > IKPI )
{
    j12array[0]-=IK2PI;
}
else if( j12array[0] < -IKPI )
{    j12array[0]+=IK2PI;
}
j12valid[0] = true;
for(int ij12 = 0; ij12 < 1; ++ij12)
{
if( !j12valid[ij12] )
{
    continue;
}
_ij12[0] = ij12; _ij12[1] = -1;
for(int iij12 = ij12+1; iij12 < 1; ++iij12)
{
if( j12valid[iij12] && IKabs(cj12array[ij12]-cj12array[iij12]) < IKFAST_SOLUTION_THRESH && IKabs(sj12array[ij12]-sj12array[iij12]) < IKFAST_SOLUTION_THRESH )
{
    j12valid[iij12]=false; _ij12[1] = iij12; break; 
}
}
j12 = j12array[ij12]; cj12 = cj12array[ij12]; sj12 = sj12array[ij12];
{
IkReal evalcond[6];
IkReal x853=IKcos(j12);
IkReal x854=IKsin(j12);
IkReal x855=((1.0)*py);
IkReal x856=(cj10*sj9);
IkReal x857=(cj10*cj9);
IkReal x858=((1.0)*px);
IkReal x859=((0.3215)*x853);
IkReal x860=((0.3215)*x854);
evalcond[0]=((((-1.0)*sj9*x858))+((cj9*py))+x860);
evalcond[1]=((0.06)+(((-0.352)*sj10))+(((-1.0)*pz))+(((-1.0)*sj10*x859))+j5);
evalcond[2]=((((-1.0)*x858))+((sj9*x860))+(((0.117)*cj9))+((x857*x859))+(((0.352)*x857)));
evalcond[3]=((((0.117)*sj9))+(((-1.0)*x855))+((x856*x859))+(((-1.0)*cj9*x860))+(((0.352)*x856)));
evalcond[4]=((0.352)+(((-0.06)*sj10))+(((0.117)*cj10))+(((-1.0)*j5*sj10))+((pz*sj10))+(((-1.0)*x855*x856))+x859+(((-1.0)*x857*x858)));
evalcond[5]=((0.24455525)+(((-1.0)*(j5*j5)))+(((-0.04224)*sj10))+(((-0.03858)*sj10*x853))+(((0.082368)*cj10))+(((-1.0)*pp))+(((0.226336)*x853))+(((0.075231)*cj10*x853))+(((2.0)*j5*pz)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}

}

} else
{
{
IkReal j12array[1], cj12array[1], sj12array[1];
bool j12valid[1]={false};
_nj12 = 1;
CheckValue<IkReal> x861=IKPowWithIntegerCheck(sj10,-1);
if(!x861.valid){
continue;
}
if( IKabs(((((-3.1104199066874)*cj9*py))+(((3.1104199066874)*px*sj9)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((0.0015552099533437)*(x861.value)*(((120.0)+(((-704.0)*sj10))+(((2000.0)*j5))+(((-2000.0)*pz)))))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((((-3.1104199066874)*cj9*py))+(((3.1104199066874)*px*sj9))))+IKsqr(((0.0015552099533437)*(x861.value)*(((120.0)+(((-704.0)*sj10))+(((2000.0)*j5))+(((-2000.0)*pz))))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j12array[0]=IKatan2(((((-3.1104199066874)*cj9*py))+(((3.1104199066874)*px*sj9))), ((0.0015552099533437)*(x861.value)*(((120.0)+(((-704.0)*sj10))+(((2000.0)*j5))+(((-2000.0)*pz))))));
sj12array[0]=IKsin(j12array[0]);
cj12array[0]=IKcos(j12array[0]);
if( j12array[0] > IKPI )
{
    j12array[0]-=IK2PI;
}
else if( j12array[0] < -IKPI )
{    j12array[0]+=IK2PI;
}
j12valid[0] = true;
for(int ij12 = 0; ij12 < 1; ++ij12)
{
if( !j12valid[ij12] )
{
    continue;
}
_ij12[0] = ij12; _ij12[1] = -1;
for(int iij12 = ij12+1; iij12 < 1; ++iij12)
{
if( j12valid[iij12] && IKabs(cj12array[ij12]-cj12array[iij12]) < IKFAST_SOLUTION_THRESH && IKabs(sj12array[ij12]-sj12array[iij12]) < IKFAST_SOLUTION_THRESH )
{
    j12valid[iij12]=false; _ij12[1] = iij12; break; 
}
}
j12 = j12array[ij12]; cj12 = cj12array[ij12]; sj12 = sj12array[ij12];
{
IkReal evalcond[6];
IkReal x862=IKcos(j12);
IkReal x863=IKsin(j12);
IkReal x864=((1.0)*py);
IkReal x865=(cj10*sj9);
IkReal x866=(cj10*cj9);
IkReal x867=((1.0)*px);
IkReal x868=((0.3215)*x862);
IkReal x869=((0.3215)*x863);
evalcond[0]=(((cj9*py))+(((-1.0)*sj9*x867))+x869);
evalcond[1]=((0.06)+(((-0.352)*sj10))+(((-1.0)*pz))+(((-1.0)*sj10*x868))+j5);
evalcond[2]=((((-1.0)*x867))+((sj9*x869))+((x866*x868))+(((0.117)*cj9))+(((0.352)*x866)));
evalcond[3]=((((-1.0)*x864))+(((0.117)*sj9))+(((-1.0)*cj9*x869))+(((0.352)*x865))+((x865*x868)));
evalcond[4]=((0.352)+(((-0.06)*sj10))+(((-1.0)*x866*x867))+(((0.117)*cj10))+(((-1.0)*j5*sj10))+((pz*sj10))+(((-1.0)*x864*x865))+x868);
evalcond[5]=((0.24455525)+(((-1.0)*(j5*j5)))+(((-0.04224)*sj10))+(((0.226336)*x862))+(((0.082368)*cj10))+(((-0.03858)*sj10*x862))+(((-1.0)*pp))+(((0.075231)*cj10*x862))+(((2.0)*j5*pz)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}

}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((IKabs(((-3.14159265358979)+(IKfmod(((3.14159265358979)+j10), 6.28318530717959)))))+(IKabs(((-3.14159265358979)+(IKfmod(((3.14159265358979)+j11), 6.28318530717959))))));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j12array[1], cj12array[1], sj12array[1];
bool j12valid[1]={false};
_nj12 = 1;
if( IKabs(((0.186625194401244)+(((3.1104199066874)*j5))+(((-3.1104199066874)*pz)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((-1.45878693623639)+(((3.1104199066874)*py*sj9))+(((3.1104199066874)*cj9*px)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((0.186625194401244)+(((3.1104199066874)*j5))+(((-3.1104199066874)*pz))))+IKsqr(((-1.45878693623639)+(((3.1104199066874)*py*sj9))+(((3.1104199066874)*cj9*px))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j12array[0]=IKatan2(((0.186625194401244)+(((3.1104199066874)*j5))+(((-3.1104199066874)*pz))), ((-1.45878693623639)+(((3.1104199066874)*py*sj9))+(((3.1104199066874)*cj9*px))));
sj12array[0]=IKsin(j12array[0]);
cj12array[0]=IKcos(j12array[0]);
if( j12array[0] > IKPI )
{
    j12array[0]-=IK2PI;
}
else if( j12array[0] < -IKPI )
{    j12array[0]+=IK2PI;
}
j12valid[0] = true;
for(int ij12 = 0; ij12 < 1; ++ij12)
{
if( !j12valid[ij12] )
{
    continue;
}
_ij12[0] = ij12; _ij12[1] = -1;
for(int iij12 = ij12+1; iij12 < 1; ++iij12)
{
if( j12valid[iij12] && IKabs(cj12array[ij12]-cj12array[iij12]) < IKFAST_SOLUTION_THRESH && IKabs(sj12array[ij12]-sj12array[iij12]) < IKFAST_SOLUTION_THRESH )
{
    j12valid[iij12]=false; _ij12[1] = iij12; break; 
}
}
j12 = j12array[ij12]; cj12 = cj12array[ij12]; sj12 = sj12array[ij12];
{
IkReal evalcond[5];
IkReal x870=IKcos(j12);
IkReal x871=IKsin(j12);
IkReal x872=((1.0)*px);
IkReal x873=((1.0)*py);
IkReal x874=((0.3215)*x870);
evalcond[0]=((0.06)+(((-1.0)*pz))+(((-0.3215)*x871))+j5);
evalcond[1]=(((cj9*x874))+(((0.469)*cj9))+(((-1.0)*x872)));
evalcond[2]=(((sj9*x874))+(((0.469)*sj9))+(((-1.0)*x873)));
evalcond[3]=((0.469)+(((-1.0)*sj9*x873))+(((-1.0)*cj9*x872))+x874);
evalcond[4]=((0.32692325)+(((-1.0)*(j5*j5)))+(((0.301567)*x870))+(((-1.0)*pp))+(((-0.03858)*x871))+(((2.0)*j5*pz)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((IKabs(((-3.14159265358979)+(IKfmod(j11, 6.28318530717959)))))+(IKabs(((-3.14159265358979)+(IKfmod(((3.14159265358979)+j10), 6.28318530717959))))));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j12array[1], cj12array[1], sj12array[1];
bool j12valid[1]={false};
_nj12 = 1;
if( IKabs(((-0.186625194401244)+(((3.1104199066874)*pz))+(((-3.1104199066874)*j5)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((-1.45878693623639)+(((3.1104199066874)*py*sj9))+(((3.1104199066874)*cj9*px)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((-0.186625194401244)+(((3.1104199066874)*pz))+(((-3.1104199066874)*j5))))+IKsqr(((-1.45878693623639)+(((3.1104199066874)*py*sj9))+(((3.1104199066874)*cj9*px))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j12array[0]=IKatan2(((-0.186625194401244)+(((3.1104199066874)*pz))+(((-3.1104199066874)*j5))), ((-1.45878693623639)+(((3.1104199066874)*py*sj9))+(((3.1104199066874)*cj9*px))));
sj12array[0]=IKsin(j12array[0]);
cj12array[0]=IKcos(j12array[0]);
if( j12array[0] > IKPI )
{
    j12array[0]-=IK2PI;
}
else if( j12array[0] < -IKPI )
{    j12array[0]+=IK2PI;
}
j12valid[0] = true;
for(int ij12 = 0; ij12 < 1; ++ij12)
{
if( !j12valid[ij12] )
{
    continue;
}
_ij12[0] = ij12; _ij12[1] = -1;
for(int iij12 = ij12+1; iij12 < 1; ++iij12)
{
if( j12valid[iij12] && IKabs(cj12array[ij12]-cj12array[iij12]) < IKFAST_SOLUTION_THRESH && IKabs(sj12array[ij12]-sj12array[iij12]) < IKFAST_SOLUTION_THRESH )
{
    j12valid[iij12]=false; _ij12[1] = iij12; break; 
}
}
j12 = j12array[ij12]; cj12 = cj12array[ij12]; sj12 = sj12array[ij12];
{
IkReal evalcond[5];
IkReal x875=IKcos(j12);
IkReal x876=IKsin(j12);
IkReal x877=((1.0)*px);
IkReal x878=((1.0)*py);
IkReal x879=((0.3215)*x875);
evalcond[0]=((0.06)+(((-1.0)*pz))+(((0.3215)*x876))+j5);
evalcond[1]=(((cj9*x879))+(((0.469)*cj9))+(((-1.0)*x877)));
evalcond[2]=(((sj9*x879))+(((0.469)*sj9))+(((-1.0)*x878)));
evalcond[3]=((0.469)+(((-1.0)*sj9*x878))+(((-1.0)*cj9*x877))+x879);
evalcond[4]=((0.32692325)+(((-1.0)*(j5*j5)))+(((0.301567)*x875))+(((-1.0)*pp))+(((0.03858)*x876))+(((2.0)*j5*pz)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((IKabs(((-3.14159265358979)+(IKfmod(((3.14159265358979)+j10), 6.28318530717959)))))+(IKabs(((-3.14159265358979)+(IKfmod(((3.14159265358979)+j9), 6.28318530717959))))));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j12array[1], cj12array[1], sj12array[1];
bool j12valid[1]={false};
_nj12 = 1;
IkReal x880=((3.1104199066874)*cj11);
if( IKabs(((((-1.0)*pz*x880))+(((3.1104199066874)*py*sj11))+(((0.186625194401244)*cj11))+((j5*x880)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((-1.45878693623639)+(((3.1104199066874)*px)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((((-1.0)*pz*x880))+(((3.1104199066874)*py*sj11))+(((0.186625194401244)*cj11))+((j5*x880))))+IKsqr(((-1.45878693623639)+(((3.1104199066874)*px))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j12array[0]=IKatan2(((((-1.0)*pz*x880))+(((3.1104199066874)*py*sj11))+(((0.186625194401244)*cj11))+((j5*x880))), ((-1.45878693623639)+(((3.1104199066874)*px))));
sj12array[0]=IKsin(j12array[0]);
cj12array[0]=IKcos(j12array[0]);
if( j12array[0] > IKPI )
{
    j12array[0]-=IK2PI;
}
else if( j12array[0] < -IKPI )
{    j12array[0]+=IK2PI;
}
j12valid[0] = true;
for(int ij12 = 0; ij12 < 1; ++ij12)
{
if( !j12valid[ij12] )
{
    continue;
}
_ij12[0] = ij12; _ij12[1] = -1;
for(int iij12 = ij12+1; iij12 < 1; ++iij12)
{
if( j12valid[iij12] && IKabs(cj12array[ij12]-cj12array[iij12]) < IKFAST_SOLUTION_THRESH && IKabs(sj12array[ij12]-sj12array[iij12]) < IKFAST_SOLUTION_THRESH )
{
    j12valid[iij12]=false; _ij12[1] = iij12; break; 
}
}
j12 = j12array[ij12]; cj12 = cj12array[ij12]; sj12 = sj12array[ij12];
{
IkReal evalcond[5];
IkReal x881=IKsin(j12);
IkReal x882=IKcos(j12);
IkReal x883=((1.0)*py);
IkReal x884=((0.3215)*x881);
evalcond[0]=((0.469)+(((0.3215)*x882))+(((-1.0)*px)));
evalcond[1]=(((sj11*x884))+(((-1.0)*x883)));
evalcond[2]=((0.06)+(((-1.0)*cj11*x884))+(((-1.0)*pz))+j5);
evalcond[3]=((((-1.0)*cj11*j5))+(((-1.0)*sj11*x883))+(((-0.06)*cj11))+x884+((cj11*pz)));
evalcond[4]=((0.32692325)+(((-1.0)*(j5*j5)))+(((0.301567)*x882))+(((-1.0)*pp))+(((-0.03858)*cj11*x881))+(((2.0)*j5*pz)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((IKabs(((-3.14159265358979)+(IKfmod(j9, 6.28318530717959)))))+(IKabs(((-3.14159265358979)+(IKfmod(((3.14159265358979)+j10), 6.28318530717959))))));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j12array[1], cj12array[1], sj12array[1];
bool j12valid[1]={false};
_nj12 = 1;
IkReal x885=((3.1104199066874)*cj11);
if( IKabs(((((-1.0)*pz*x885))+(((0.186625194401244)*cj11))+(((-3.1104199066874)*py*sj11))+((j5*x885)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((-1.45878693623639)+(((-3.1104199066874)*px)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((((-1.0)*pz*x885))+(((0.186625194401244)*cj11))+(((-3.1104199066874)*py*sj11))+((j5*x885))))+IKsqr(((-1.45878693623639)+(((-3.1104199066874)*px))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j12array[0]=IKatan2(((((-1.0)*pz*x885))+(((0.186625194401244)*cj11))+(((-3.1104199066874)*py*sj11))+((j5*x885))), ((-1.45878693623639)+(((-3.1104199066874)*px))));
sj12array[0]=IKsin(j12array[0]);
cj12array[0]=IKcos(j12array[0]);
if( j12array[0] > IKPI )
{
    j12array[0]-=IK2PI;
}
else if( j12array[0] < -IKPI )
{    j12array[0]+=IK2PI;
}
j12valid[0] = true;
for(int ij12 = 0; ij12 < 1; ++ij12)
{
if( !j12valid[ij12] )
{
    continue;
}
_ij12[0] = ij12; _ij12[1] = -1;
for(int iij12 = ij12+1; iij12 < 1; ++iij12)
{
if( j12valid[iij12] && IKabs(cj12array[ij12]-cj12array[iij12]) < IKFAST_SOLUTION_THRESH && IKabs(sj12array[ij12]-sj12array[iij12]) < IKFAST_SOLUTION_THRESH )
{
    j12valid[iij12]=false; _ij12[1] = iij12; break; 
}
}
j12 = j12array[ij12]; cj12 = cj12array[ij12]; sj12 = sj12array[ij12];
{
IkReal evalcond[5];
IkReal x886=IKsin(j12);
IkReal x887=IKcos(j12);
IkReal x888=((0.3215)*x886);
evalcond[0]=((0.469)+(((0.3215)*x887))+px);
evalcond[1]=((((-1.0)*py))+(((-1.0)*sj11*x888)));
evalcond[2]=((0.06)+(((-1.0)*cj11*x888))+(((-1.0)*pz))+j5);
evalcond[3]=((((-1.0)*cj11*j5))+((py*sj11))+(((-0.06)*cj11))+x888+((cj11*pz)));
evalcond[4]=((0.32692325)+(((-1.0)*(j5*j5)))+(((0.301567)*x887))+(((-1.0)*pp))+(((-0.03858)*cj11*x886))+(((2.0)*j5*pz)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((IKabs(((-3.14159265358979)+(IKfmod(j10, 6.28318530717959)))))+(IKabs(((-3.14159265358979)+(IKfmod(((3.14159265358979)+j11), 6.28318530717959))))));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j12array[1], cj12array[1], sj12array[1];
bool j12valid[1]={false};
_nj12 = 1;
if( IKabs(((-0.186625194401244)+(((3.1104199066874)*pz))+(((-3.1104199066874)*j5)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((-0.73094867807154)+(((-3.1104199066874)*cj9*px))+(((-3.1104199066874)*py*sj9)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((-0.186625194401244)+(((3.1104199066874)*pz))+(((-3.1104199066874)*j5))))+IKsqr(((-0.73094867807154)+(((-3.1104199066874)*cj9*px))+(((-3.1104199066874)*py*sj9))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j12array[0]=IKatan2(((-0.186625194401244)+(((3.1104199066874)*pz))+(((-3.1104199066874)*j5))), ((-0.73094867807154)+(((-3.1104199066874)*cj9*px))+(((-3.1104199066874)*py*sj9))));
sj12array[0]=IKsin(j12array[0]);
cj12array[0]=IKcos(j12array[0]);
if( j12array[0] > IKPI )
{
    j12array[0]-=IK2PI;
}
else if( j12array[0] < -IKPI )
{    j12array[0]+=IK2PI;
}
j12valid[0] = true;
for(int ij12 = 0; ij12 < 1; ++ij12)
{
if( !j12valid[ij12] )
{
    continue;
}
_ij12[0] = ij12; _ij12[1] = -1;
for(int iij12 = ij12+1; iij12 < 1; ++iij12)
{
if( j12valid[iij12] && IKabs(cj12array[ij12]-cj12array[iij12]) < IKFAST_SOLUTION_THRESH && IKabs(sj12array[ij12]-sj12array[iij12]) < IKFAST_SOLUTION_THRESH )
{
    j12valid[iij12]=false; _ij12[1] = iij12; break; 
}
}
j12 = j12array[ij12]; cj12 = cj12array[ij12]; sj12 = sj12array[ij12];
{
IkReal evalcond[5];
IkReal x889=IKcos(j12);
IkReal x890=IKsin(j12);
IkReal x891=((0.3215)*x889);
evalcond[0]=((0.06)+(((0.3215)*x890))+(((-1.0)*pz))+j5);
evalcond[1]=((0.235)+((cj9*px))+x891+((py*sj9)));
evalcond[2]=((((-1.0)*px))+(((-0.235)*cj9))+(((-1.0)*cj9*x891)));
evalcond[3]=((((-1.0)*sj9*x891))+(((-0.235)*sj9))+(((-1.0)*py)));
evalcond[4]=((0.16218725)+(((-1.0)*(j5*j5)))+(((0.03858)*x890))+(((0.151105)*x889))+(((-1.0)*pp))+(((2.0)*j5*pz)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((IKabs(((-3.14159265358979)+(IKfmod(j10, 6.28318530717959)))))+(IKabs(((-3.14159265358979)+(IKfmod(j11, 6.28318530717959))))));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j12array[1], cj12array[1], sj12array[1];
bool j12valid[1]={false};
_nj12 = 1;
if( IKabs(((0.186625194401244)+(((3.1104199066874)*j5))+(((-3.1104199066874)*pz)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((-0.73094867807154)+(((-3.1104199066874)*cj9*px))+(((-3.1104199066874)*py*sj9)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((0.186625194401244)+(((3.1104199066874)*j5))+(((-3.1104199066874)*pz))))+IKsqr(((-0.73094867807154)+(((-3.1104199066874)*cj9*px))+(((-3.1104199066874)*py*sj9))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j12array[0]=IKatan2(((0.186625194401244)+(((3.1104199066874)*j5))+(((-3.1104199066874)*pz))), ((-0.73094867807154)+(((-3.1104199066874)*cj9*px))+(((-3.1104199066874)*py*sj9))));
sj12array[0]=IKsin(j12array[0]);
cj12array[0]=IKcos(j12array[0]);
if( j12array[0] > IKPI )
{
    j12array[0]-=IK2PI;
}
else if( j12array[0] < -IKPI )
{    j12array[0]+=IK2PI;
}
j12valid[0] = true;
for(int ij12 = 0; ij12 < 1; ++ij12)
{
if( !j12valid[ij12] )
{
    continue;
}
_ij12[0] = ij12; _ij12[1] = -1;
for(int iij12 = ij12+1; iij12 < 1; ++iij12)
{
if( j12valid[iij12] && IKabs(cj12array[ij12]-cj12array[iij12]) < IKFAST_SOLUTION_THRESH && IKabs(sj12array[ij12]-sj12array[iij12]) < IKFAST_SOLUTION_THRESH )
{
    j12valid[iij12]=false; _ij12[1] = iij12; break; 
}
}
j12 = j12array[ij12]; cj12 = cj12array[ij12]; sj12 = sj12array[ij12];
{
IkReal evalcond[5];
IkReal x892=IKcos(j12);
IkReal x893=IKsin(j12);
IkReal x894=((0.3215)*x892);
evalcond[0]=((0.06)+(((-0.3215)*x893))+(((-1.0)*pz))+j5);
evalcond[1]=((0.235)+((cj9*px))+x894+((py*sj9)));
evalcond[2]=((((-1.0)*px))+(((-0.235)*cj9))+(((-1.0)*cj9*x894)));
evalcond[3]=((((-1.0)*sj9*x894))+(((-0.235)*sj9))+(((-1.0)*py)));
evalcond[4]=((0.16218725)+(((0.151105)*x892))+(((-1.0)*(j5*j5)))+(((-1.0)*pp))+(((-0.03858)*x893))+(((2.0)*j5*pz)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((IKabs(((-3.14159265358979)+(IKfmod(j10, 6.28318530717959)))))+(IKabs(((-3.14159265358979)+(IKfmod(((3.14159265358979)+j9), 6.28318530717959))))));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j12array[1], cj12array[1], sj12array[1];
bool j12valid[1]={false};
_nj12 = 1;
IkReal x895=((3.1104199066874)*cj11);
if( IKabs(((((-1.0)*j5*x895))+((pz*x895))+(((-0.186625194401244)*cj11))+(((3.1104199066874)*py*sj11)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((-0.73094867807154)+(((-3.1104199066874)*px)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((((-1.0)*j5*x895))+((pz*x895))+(((-0.186625194401244)*cj11))+(((3.1104199066874)*py*sj11))))+IKsqr(((-0.73094867807154)+(((-3.1104199066874)*px))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j12array[0]=IKatan2(((((-1.0)*j5*x895))+((pz*x895))+(((-0.186625194401244)*cj11))+(((3.1104199066874)*py*sj11))), ((-0.73094867807154)+(((-3.1104199066874)*px))));
sj12array[0]=IKsin(j12array[0]);
cj12array[0]=IKcos(j12array[0]);
if( j12array[0] > IKPI )
{
    j12array[0]-=IK2PI;
}
else if( j12array[0] < -IKPI )
{    j12array[0]+=IK2PI;
}
j12valid[0] = true;
for(int ij12 = 0; ij12 < 1; ++ij12)
{
if( !j12valid[ij12] )
{
    continue;
}
_ij12[0] = ij12; _ij12[1] = -1;
for(int iij12 = ij12+1; iij12 < 1; ++iij12)
{
if( j12valid[iij12] && IKabs(cj12array[ij12]-cj12array[iij12]) < IKFAST_SOLUTION_THRESH && IKabs(sj12array[ij12]-sj12array[iij12]) < IKFAST_SOLUTION_THRESH )
{
    j12valid[iij12]=false; _ij12[1] = iij12; break; 
}
}
j12 = j12array[ij12]; cj12 = cj12array[ij12]; sj12 = sj12array[ij12];
{
IkReal evalcond[5];
IkReal x896=IKsin(j12);
IkReal x897=IKcos(j12);
IkReal x898=((1.0)*py);
IkReal x899=((1.0)*pz);
IkReal x900=((0.3215)*x896);
evalcond[0]=((0.235)+(((0.3215)*x897))+px);
evalcond[1]=((((-1.0)*x898))+((sj11*x900)));
evalcond[2]=((0.06)+(((-1.0)*x899))+((cj11*x900))+j5);
evalcond[3]=((((0.06)*cj11))+(((-1.0)*cj11*x899))+((cj11*j5))+(((-1.0)*sj11*x898))+x900);
evalcond[4]=((0.16218725)+(((0.151105)*x897))+(((-1.0)*(j5*j5)))+(((-1.0)*pp))+(((0.03858)*cj11*x896))+(((2.0)*j5*pz)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((IKabs(((-3.14159265358979)+(IKfmod(j10, 6.28318530717959)))))+(IKabs(((-3.14159265358979)+(IKfmod(j9, 6.28318530717959))))));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j12array[1], cj12array[1], sj12array[1];
bool j12valid[1]={false};
_nj12 = 1;
IkReal x901=((3.1104199066874)*cj11);
if( IKabs(((((-0.186625194401244)*cj11))+(((-1.0)*j5*x901))+(((-3.1104199066874)*py*sj11))+((pz*x901)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((-0.73094867807154)+(((3.1104199066874)*px)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((((-0.186625194401244)*cj11))+(((-1.0)*j5*x901))+(((-3.1104199066874)*py*sj11))+((pz*x901))))+IKsqr(((-0.73094867807154)+(((3.1104199066874)*px))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j12array[0]=IKatan2(((((-0.186625194401244)*cj11))+(((-1.0)*j5*x901))+(((-3.1104199066874)*py*sj11))+((pz*x901))), ((-0.73094867807154)+(((3.1104199066874)*px))));
sj12array[0]=IKsin(j12array[0]);
cj12array[0]=IKcos(j12array[0]);
if( j12array[0] > IKPI )
{
    j12array[0]-=IK2PI;
}
else if( j12array[0] < -IKPI )
{    j12array[0]+=IK2PI;
}
j12valid[0] = true;
for(int ij12 = 0; ij12 < 1; ++ij12)
{
if( !j12valid[ij12] )
{
    continue;
}
_ij12[0] = ij12; _ij12[1] = -1;
for(int iij12 = ij12+1; iij12 < 1; ++iij12)
{
if( j12valid[iij12] && IKabs(cj12array[ij12]-cj12array[iij12]) < IKFAST_SOLUTION_THRESH && IKabs(sj12array[ij12]-sj12array[iij12]) < IKFAST_SOLUTION_THRESH )
{
    j12valid[iij12]=false; _ij12[1] = iij12; break; 
}
}
j12 = j12array[ij12]; cj12 = cj12array[ij12]; sj12 = sj12array[ij12];
{
IkReal evalcond[5];
IkReal x902=IKsin(j12);
IkReal x903=IKcos(j12);
IkReal x904=((1.0)*pz);
IkReal x905=((0.3215)*x902);
evalcond[0]=((0.235)+(((0.3215)*x903))+(((-1.0)*px)));
evalcond[1]=((((-1.0)*py))+(((-1.0)*sj11*x905)));
evalcond[2]=((0.06)+(((-1.0)*x904))+((cj11*x905))+j5);
evalcond[3]=((((0.06)*cj11))+(((-1.0)*cj11*x904))+((cj11*j5))+((py*sj11))+x905);
evalcond[4]=((0.16218725)+(((-1.0)*(j5*j5)))+(((-1.0)*pp))+(((0.151105)*x903))+(((0.03858)*cj11*x902))+(((2.0)*j5*pz)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((IKabs(((-3.14159265358979)+(IKfmod(((1.5707963267949)+j9), 6.28318530717959)))))+(IKabs(((-3.14159265358979)+(IKfmod(((3.14159265358979)+j11), 6.28318530717959))))));
evalcond[1]=px;
if( IKabs(evalcond[0]) < 0.0000050000000000  && IKabs(evalcond[1]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j12array[1], cj12array[1], sj12array[1];
bool j12valid[1]={false};
_nj12 = 1;
IkReal x906=((3.1104199066874)*sj10);
IkReal x907=((3.1104199066874)*cj10);
if( IKabs(((((-1.0)*pz*x907))+(((-1.0)*py*x906))+(((0.363919129082426)*sj10))+((j5*x907))+(((0.186625194401244)*cj10)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((-1.09486780715397)+(((-0.363919129082426)*cj10))+(((-1.0)*pz*x906))+((j5*x906))+(((0.186625194401244)*sj10))+((py*x907)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((((-1.0)*pz*x907))+(((-1.0)*py*x906))+(((0.363919129082426)*sj10))+((j5*x907))+(((0.186625194401244)*cj10))))+IKsqr(((-1.09486780715397)+(((-0.363919129082426)*cj10))+(((-1.0)*pz*x906))+((j5*x906))+(((0.186625194401244)*sj10))+((py*x907))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j12array[0]=IKatan2(((((-1.0)*pz*x907))+(((-1.0)*py*x906))+(((0.363919129082426)*sj10))+((j5*x907))+(((0.186625194401244)*cj10))), ((-1.09486780715397)+(((-0.363919129082426)*cj10))+(((-1.0)*pz*x906))+((j5*x906))+(((0.186625194401244)*sj10))+((py*x907))));
sj12array[0]=IKsin(j12array[0]);
cj12array[0]=IKcos(j12array[0]);
if( j12array[0] > IKPI )
{
    j12array[0]-=IK2PI;
}
else if( j12array[0] < -IKPI )
{    j12array[0]+=IK2PI;
}
j12valid[0] = true;
for(int ij12 = 0; ij12 < 1; ++ij12)
{
if( !j12valid[ij12] )
{
    continue;
}
_ij12[0] = ij12; _ij12[1] = -1;
for(int iij12 = ij12+1; iij12 < 1; ++iij12)
{
if( j12valid[iij12] && IKabs(cj12array[ij12]-cj12array[iij12]) < IKFAST_SOLUTION_THRESH && IKabs(sj12array[ij12]-sj12array[iij12]) < IKFAST_SOLUTION_THRESH )
{
    j12valid[iij12]=false; _ij12[1] = iij12; break; 
}
}
j12 = j12array[ij12]; cj12 = cj12array[ij12]; sj12 = sj12array[ij12];
{
IkReal evalcond[5];
IkReal x908=IKsin(j12);
IkReal x909=IKcos(j12);
IkReal x910=((1.0)*py);
IkReal x911=((1.0)*j5);
IkReal x912=(cj10*x908);
IkReal x913=(cj10*x909);
IkReal x914=((0.3215)*x908);
IkReal x915=((0.3215)*x909);
evalcond[0]=((0.117)+(((0.352)*cj10))+(((0.3215)*x913))+(((-1.0)*x910))+(((-1.0)*sj10*x914)));
evalcond[1]=((0.06)+(((-0.352)*sj10))+(((-0.3215)*x912))+(((-1.0)*pz))+(((-1.0)*sj10*x915))+j5);
evalcond[2]=((((-0.117)*sj10))+((cj10*pz))+((py*sj10))+(((-1.0)*cj10*x911))+(((-0.06)*cj10))+x914);
evalcond[3]=((0.352)+(((-0.06)*sj10))+(((0.117)*cj10))+((pz*sj10))+(((-1.0)*cj10*x910))+x915+(((-1.0)*sj10*x911)));
evalcond[4]=((0.24455525)+(((-0.03858)*x912))+(((-0.04224)*sj10))+(((0.082368)*cj10))+(((-0.03858)*sj10*x909))+(((0.075231)*x913))+(((-1.0)*pp))+(((-1.0)*j5*x911))+(((0.226336)*x909))+(((-0.075231)*sj10*x908))+(((2.0)*j5*pz)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((IKabs(((-3.14159265358979)+(IKfmod(((4.71238898038469)+j9), 6.28318530717959)))))+(IKabs(((-3.14159265358979)+(IKfmod(((3.14159265358979)+j11), 6.28318530717959))))));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j12array[1], cj12array[1], sj12array[1];
bool j12valid[1]={false};
_nj12 = 1;
IkReal x916=((3.1104199066874)*sj10);
IkReal x917=((3.1104199066874)*cj10);
if( IKabs(((((0.363919129082426)*sj10))+(((-1.0)*pz*x917))+(((0.186625194401244)*cj10))+((j5*x917))+((py*x916)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((-1.09486780715397)+(((-0.363919129082426)*cj10))+(((-1.0)*py*x917))+(((-1.0)*pz*x916))+((j5*x916))+(((0.186625194401244)*sj10)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((((0.363919129082426)*sj10))+(((-1.0)*pz*x917))+(((0.186625194401244)*cj10))+((j5*x917))+((py*x916))))+IKsqr(((-1.09486780715397)+(((-0.363919129082426)*cj10))+(((-1.0)*py*x917))+(((-1.0)*pz*x916))+((j5*x916))+(((0.186625194401244)*sj10))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j12array[0]=IKatan2(((((0.363919129082426)*sj10))+(((-1.0)*pz*x917))+(((0.186625194401244)*cj10))+((j5*x917))+((py*x916))), ((-1.09486780715397)+(((-0.363919129082426)*cj10))+(((-1.0)*py*x917))+(((-1.0)*pz*x916))+((j5*x916))+(((0.186625194401244)*sj10))));
sj12array[0]=IKsin(j12array[0]);
cj12array[0]=IKcos(j12array[0]);
if( j12array[0] > IKPI )
{
    j12array[0]-=IK2PI;
}
else if( j12array[0] < -IKPI )
{    j12array[0]+=IK2PI;
}
j12valid[0] = true;
for(int ij12 = 0; ij12 < 1; ++ij12)
{
if( !j12valid[ij12] )
{
    continue;
}
_ij12[0] = ij12; _ij12[1] = -1;
for(int iij12 = ij12+1; iij12 < 1; ++iij12)
{
if( j12valid[iij12] && IKabs(cj12array[ij12]-cj12array[iij12]) < IKFAST_SOLUTION_THRESH && IKabs(sj12array[ij12]-sj12array[iij12]) < IKFAST_SOLUTION_THRESH )
{
    j12valid[iij12]=false; _ij12[1] = iij12; break; 
}
}
j12 = j12array[ij12]; cj12 = cj12array[ij12]; sj12 = sj12array[ij12];
{
IkReal evalcond[5];
IkReal x918=IKsin(j12);
IkReal x919=IKcos(j12);
IkReal x920=((1.0)*py);
IkReal x921=((1.0)*j5);
IkReal x922=(cj10*x918);
IkReal x923=((0.3215)*x919);
IkReal x924=((0.3215)*x918);
evalcond[0]=((-0.117)+(((-1.0)*x920))+((sj10*x924))+(((-1.0)*cj10*x923))+(((-0.352)*cj10)));
evalcond[1]=((0.06)+(((-0.352)*sj10))+(((-1.0)*pz))+(((-0.3215)*x922))+(((-1.0)*sj10*x923))+j5);
evalcond[2]=((0.352)+((cj10*py))+(((-0.06)*sj10))+(((0.117)*cj10))+((pz*sj10))+(((-1.0)*sj10*x921))+x923);
evalcond[3]=((((-0.117)*sj10))+((cj10*pz))+(((-0.06)*cj10))+(((-1.0)*sj10*x920))+x924+(((-1.0)*cj10*x921)));
evalcond[4]=((0.24455525)+(((-0.03858)*sj10*x919))+(((-0.03858)*x922))+(((-0.04224)*sj10))+(((0.082368)*cj10))+(((-1.0)*pp))+(((0.075231)*cj10*x919))+(((-0.075231)*sj10*x918))+(((-1.0)*j5*x921))+(((0.226336)*x919))+(((2.0)*j5*pz)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((IKabs(((-3.14159265358979)+(IKfmod(j11, 6.28318530717959)))))+(IKabs(((-3.14159265358979)+(IKfmod(((1.5707963267949)+j9), 6.28318530717959))))));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j12array[1], cj12array[1], sj12array[1];
bool j12valid[1]={false};
_nj12 = 1;
IkReal x925=((3.1104199066874)*sj10);
IkReal x926=((3.1104199066874)*cj10);
if( IKabs(((((-0.186625194401244)*cj10))+(((-0.363919129082426)*sj10))+((py*x925))+((pz*x926))+(((-1.0)*j5*x926)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((-1.09486780715397)+(((-0.363919129082426)*cj10))+((j5*x925))+((py*x926))+(((0.186625194401244)*sj10))+(((-1.0)*pz*x925)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((((-0.186625194401244)*cj10))+(((-0.363919129082426)*sj10))+((py*x925))+((pz*x926))+(((-1.0)*j5*x926))))+IKsqr(((-1.09486780715397)+(((-0.363919129082426)*cj10))+((j5*x925))+((py*x926))+(((0.186625194401244)*sj10))+(((-1.0)*pz*x925))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j12array[0]=IKatan2(((((-0.186625194401244)*cj10))+(((-0.363919129082426)*sj10))+((py*x925))+((pz*x926))+(((-1.0)*j5*x926))), ((-1.09486780715397)+(((-0.363919129082426)*cj10))+((j5*x925))+((py*x926))+(((0.186625194401244)*sj10))+(((-1.0)*pz*x925))));
sj12array[0]=IKsin(j12array[0]);
cj12array[0]=IKcos(j12array[0]);
if( j12array[0] > IKPI )
{
    j12array[0]-=IK2PI;
}
else if( j12array[0] < -IKPI )
{    j12array[0]+=IK2PI;
}
j12valid[0] = true;
for(int ij12 = 0; ij12 < 1; ++ij12)
{
if( !j12valid[ij12] )
{
    continue;
}
_ij12[0] = ij12; _ij12[1] = -1;
for(int iij12 = ij12+1; iij12 < 1; ++iij12)
{
if( j12valid[iij12] && IKabs(cj12array[ij12]-cj12array[iij12]) < IKFAST_SOLUTION_THRESH && IKabs(sj12array[ij12]-sj12array[iij12]) < IKFAST_SOLUTION_THRESH )
{
    j12valid[iij12]=false; _ij12[1] = iij12; break; 
}
}
j12 = j12array[ij12]; cj12 = cj12array[ij12]; sj12 = sj12array[ij12];
{
IkReal evalcond[5];
IkReal x927=IKsin(j12);
IkReal x928=IKcos(j12);
IkReal x929=((1.0)*py);
IkReal x930=((1.0)*pz);
IkReal x931=(cj10*x927);
IkReal x932=(cj10*x928);
IkReal x933=((0.3215)*x927);
IkReal x934=((0.3215)*x928);
evalcond[0]=((0.117)+(((-1.0)*x929))+(((0.352)*cj10))+((sj10*x933))+(((0.3215)*x932)));
evalcond[1]=((0.06)+(((-0.352)*sj10))+(((0.3215)*x931))+(((-1.0)*sj10*x934))+j5+(((-1.0)*x930)));
evalcond[2]=((((0.06)*cj10))+(((-1.0)*sj10*x929))+((cj10*j5))+(((0.117)*sj10))+(((-1.0)*cj10*x930))+x933);
evalcond[3]=((0.352)+(((-0.06)*sj10))+(((0.117)*cj10))+(((-1.0)*j5*sj10))+((pz*sj10))+x934+(((-1.0)*cj10*x929)));
evalcond[4]=((0.24455525)+(((0.226336)*x928))+(((-1.0)*(j5*j5)))+(((0.075231)*sj10*x927))+(((-0.04224)*sj10))+(((0.082368)*cj10))+(((-1.0)*pp))+(((0.03858)*x931))+(((-0.03858)*sj10*x928))+(((0.075231)*x932))+(((2.0)*j5*pz)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((IKabs(((-3.14159265358979)+(IKfmod(j11, 6.28318530717959)))))+(IKabs(((-3.14159265358979)+(IKfmod(((4.71238898038469)+j9), 6.28318530717959))))));
evalcond[1]=px;
if( IKabs(evalcond[0]) < 0.0000050000000000  && IKabs(evalcond[1]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j12array[1], cj12array[1], sj12array[1];
bool j12valid[1]={false};
_nj12 = 1;
IkReal x935=((3.1104199066874)*sj10);
IkReal x936=((3.1104199066874)*cj10);
if( IKabs(((((-0.186625194401244)*cj10))+(((-0.363919129082426)*sj10))+(((-1.0)*py*x935))+((pz*x936))+(((-1.0)*j5*x936)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((-1.09486780715397)+(((-0.363919129082426)*cj10))+((j5*x935))+(((0.186625194401244)*sj10))+(((-1.0)*py*x936))+(((-1.0)*pz*x935)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((((-0.186625194401244)*cj10))+(((-0.363919129082426)*sj10))+(((-1.0)*py*x935))+((pz*x936))+(((-1.0)*j5*x936))))+IKsqr(((-1.09486780715397)+(((-0.363919129082426)*cj10))+((j5*x935))+(((0.186625194401244)*sj10))+(((-1.0)*py*x936))+(((-1.0)*pz*x935))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j12array[0]=IKatan2(((((-0.186625194401244)*cj10))+(((-0.363919129082426)*sj10))+(((-1.0)*py*x935))+((pz*x936))+(((-1.0)*j5*x936))), ((-1.09486780715397)+(((-0.363919129082426)*cj10))+((j5*x935))+(((0.186625194401244)*sj10))+(((-1.0)*py*x936))+(((-1.0)*pz*x935))));
sj12array[0]=IKsin(j12array[0]);
cj12array[0]=IKcos(j12array[0]);
if( j12array[0] > IKPI )
{
    j12array[0]-=IK2PI;
}
else if( j12array[0] < -IKPI )
{    j12array[0]+=IK2PI;
}
j12valid[0] = true;
for(int ij12 = 0; ij12 < 1; ++ij12)
{
if( !j12valid[ij12] )
{
    continue;
}
_ij12[0] = ij12; _ij12[1] = -1;
for(int iij12 = ij12+1; iij12 < 1; ++iij12)
{
if( j12valid[iij12] && IKabs(cj12array[ij12]-cj12array[iij12]) < IKFAST_SOLUTION_THRESH && IKabs(sj12array[ij12]-sj12array[iij12]) < IKFAST_SOLUTION_THRESH )
{
    j12valid[iij12]=false; _ij12[1] = iij12; break; 
}
}
j12 = j12array[ij12]; cj12 = cj12array[ij12]; sj12 = sj12array[ij12];
{
IkReal evalcond[5];
IkReal x937=IKsin(j12);
IkReal x938=IKcos(j12);
IkReal x939=((1.0)*pz);
IkReal x940=(cj10*x937);
IkReal x941=(cj10*x938);
IkReal x942=((0.3215)*x937);
IkReal x943=((0.3215)*x938);
evalcond[0]=((-0.117)+(((-0.3215)*x941))+(((-1.0)*sj10*x942))+(((-1.0)*py))+(((-0.352)*cj10)));
evalcond[1]=((0.06)+(((-0.352)*sj10))+(((-1.0)*sj10*x943))+(((0.3215)*x940))+j5+(((-1.0)*x939)));
evalcond[2]=((((0.06)*cj10))+((py*sj10))+((cj10*j5))+(((0.117)*sj10))+(((-1.0)*cj10*x939))+x942);
evalcond[3]=((0.352)+((cj10*py))+(((-0.06)*sj10))+(((0.117)*cj10))+(((-1.0)*j5*sj10))+((pz*sj10))+x943);
evalcond[4]=((0.24455525)+(((0.226336)*x938))+(((-1.0)*(j5*j5)))+(((0.075231)*sj10*x937))+(((-0.04224)*sj10))+(((0.03858)*x940))+(((0.082368)*cj10))+(((-1.0)*pp))+(((-0.03858)*sj10*x938))+(((0.075231)*x941))+(((2.0)*j5*pz)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
if( 1 )
{
bgotonextstatement=false;
continue; // branch miss [j12]

}
} while(0);
if( bgotonextstatement )
{
}
}
}
}
}
}
}
}
}
}
}
}
}
}
}
}
}
}

} else
{
{
IkReal j12array[1], cj12array[1], sj12array[1];
bool j12valid[1]={false};
_nj12 = 1;
IkReal x944=(sj11*sj9);
IkReal x945=((1286000.0)*j5);
IkReal x946=(cj9*sj10);
IkReal x947=((1286000.0)*pz);
IkReal x948=(cj10*cj9);
IkReal x949=(cj11*cj9);
CheckValue<IkReal> x950=IKPowWithIntegerCheck(((((643.0)*sj10*x944))+(((643.0)*x949))),-1);
if(!x950.valid){
continue;
}
CheckValue<IkReal> x951=IKPowWithIntegerCheck(((((-413449.0)*x949))+(((-413449.0)*sj10*x944))),-1);
if(!x951.valid){
continue;
}
if( IKabs(((x950.value)*(((((-2000.0)*pz*x948))+(((-2000.0)*px*sj10))+(((120.0)*x948))+(((234.0)*x946))+(((2000.0)*j5*x948)))))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((x951.value)*(((((-77160.0)*x944))+(((-1.0)*cj11*x945*x946))+((cj11*x946*x947))+(((-77160.0)*cj11*x946))+(((452672.0)*x949))+(((150462.0)*cj11*x948))+(((-1.0)*x944*x945))+(((452672.0)*sj10*x944))+((x944*x947))+(((-1286000.0)*cj10*cj11*px)))))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((x950.value)*(((((-2000.0)*pz*x948))+(((-2000.0)*px*sj10))+(((120.0)*x948))+(((234.0)*x946))+(((2000.0)*j5*x948))))))+IKsqr(((x951.value)*(((((-77160.0)*x944))+(((-1.0)*cj11*x945*x946))+((cj11*x946*x947))+(((-77160.0)*cj11*x946))+(((452672.0)*x949))+(((150462.0)*cj11*x948))+(((-1.0)*x944*x945))+(((452672.0)*sj10*x944))+((x944*x947))+(((-1286000.0)*cj10*cj11*px))))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j12array[0]=IKatan2(((x950.value)*(((((-2000.0)*pz*x948))+(((-2000.0)*px*sj10))+(((120.0)*x948))+(((234.0)*x946))+(((2000.0)*j5*x948))))), ((x951.value)*(((((-77160.0)*x944))+(((-1.0)*cj11*x945*x946))+((cj11*x946*x947))+(((-77160.0)*cj11*x946))+(((452672.0)*x949))+(((150462.0)*cj11*x948))+(((-1.0)*x944*x945))+(((452672.0)*sj10*x944))+((x944*x947))+(((-1286000.0)*cj10*cj11*px))))));
sj12array[0]=IKsin(j12array[0]);
cj12array[0]=IKcos(j12array[0]);
if( j12array[0] > IKPI )
{
    j12array[0]-=IK2PI;
}
else if( j12array[0] < -IKPI )
{    j12array[0]+=IK2PI;
}
j12valid[0] = true;
for(int ij12 = 0; ij12 < 1; ++ij12)
{
if( !j12valid[ij12] )
{
    continue;
}
_ij12[0] = ij12; _ij12[1] = -1;
for(int iij12 = ij12+1; iij12 < 1; ++iij12)
{
if( j12valid[iij12] && IKabs(cj12array[ij12]-cj12array[iij12]) < IKFAST_SOLUTION_THRESH && IKabs(sj12array[ij12]-sj12array[iij12]) < IKFAST_SOLUTION_THRESH )
{
    j12valid[iij12]=false; _ij12[1] = iij12; break; 
}
}
j12 = j12array[ij12]; cj12 = cj12array[ij12]; sj12 = sj12array[ij12];
{
IkReal evalcond[6];
IkReal x952=IKcos(j12);
IkReal x953=IKsin(j12);
IkReal x954=((1.0)*py);
IkReal x955=(cj9*sj11);
IkReal x956=(cj10*sj9);
IkReal x957=((1.0)*cj10);
IkReal x958=(cj10*cj9);
IkReal x959=(sj11*sj9);
IkReal x960=(cj11*sj10);
IkReal x961=(cj9*px);
IkReal x962=(cj10*cj11);
IkReal x963=((0.3215)*x952);
IkReal x964=((0.3215)*x953);
evalcond[0]=((0.06)+(((-0.352)*sj10))+(((-1.0)*x962*x964))+(((-1.0)*sj10*x963))+(((-1.0)*pz))+j5);
evalcond[1]=((0.352)+(((-0.06)*sj10))+(((0.117)*cj10))+(((-1.0)*j5*sj10))+((pz*sj10))+(((-1.0)*x957*x961))+(((-1.0)*x954*x956))+x963);
evalcond[2]=((((-1.0)*cj9*x960*x964))+(((-1.0)*px))+(((-1.0)*x959*x964))+(((0.352)*x958))+(((0.117)*cj9))+((x958*x963)));
evalcond[3]=((((0.117)*sj9))+(((-1.0)*sj9*x960*x964))+((x956*x963))+(((0.352)*x956))+(((-1.0)*x954))+((x955*x964)));
evalcond[4]=(((py*sj9*x960))+((px*x959))+(((-0.06)*x962))+((x960*x961))+((pz*x962))+(((-1.0)*cj11*j5*x957))+(((-1.0)*x954*x955))+x964+(((-0.117)*x960)));
evalcond[5]=((0.24455525)+(((-1.0)*(j5*j5)))+(((-0.03858)*x953*x962))+(((0.226336)*x952))+(((-0.04224)*sj10))+(((0.075231)*cj10*x952))+(((0.082368)*cj10))+(((-0.075231)*x953*x960))+(((-1.0)*pp))+(((-0.03858)*sj10*x952))+(((2.0)*j5*pz)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}

}

} else
{
{
IkReal j12array[1], cj12array[1], sj12array[1];
bool j12valid[1]={false};
_nj12 = 1;
IkReal x965=cj10*cj10;
IkReal x966=((3.1104199066874)*sj10);
IkReal x967=(cj10*sj10);
IkReal x968=(cj9*px);
IkReal x969=(cj10*py*sj9);
IkReal x970=((2000.0)*x965);
CheckValue<IkReal> x971=IKPowWithIntegerCheck(cj10,-1);
if(!x971.valid){
continue;
}
CheckValue<IkReal> x972=IKPowWithIntegerCheck(cj11,-1);
if(!x972.valid){
continue;
}
if( IKabs(((0.0015552099533437)*(x971.value)*(x972.value)*((((j5*x970))+(((-2000.0)*py*sj9*x967))+(((-1.0)*pz*x970))+(((120.0)*x965))+(((-2000.0)*x967*x968))+(((234.0)*x967)))))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((-1.09486780715397)+((j5*x966))+(((-0.363919129082426)*cj10))+(((-1.0)*pz*x966))+(((3.1104199066874)*cj10*x968))+(((0.186625194401244)*sj10))+(((3.1104199066874)*x969)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((0.0015552099533437)*(x971.value)*(x972.value)*((((j5*x970))+(((-2000.0)*py*sj9*x967))+(((-1.0)*pz*x970))+(((120.0)*x965))+(((-2000.0)*x967*x968))+(((234.0)*x967))))))+IKsqr(((-1.09486780715397)+((j5*x966))+(((-0.363919129082426)*cj10))+(((-1.0)*pz*x966))+(((3.1104199066874)*cj10*x968))+(((0.186625194401244)*sj10))+(((3.1104199066874)*x969))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j12array[0]=IKatan2(((0.0015552099533437)*(x971.value)*(x972.value)*((((j5*x970))+(((-2000.0)*py*sj9*x967))+(((-1.0)*pz*x970))+(((120.0)*x965))+(((-2000.0)*x967*x968))+(((234.0)*x967))))), ((-1.09486780715397)+((j5*x966))+(((-0.363919129082426)*cj10))+(((-1.0)*pz*x966))+(((3.1104199066874)*cj10*x968))+(((0.186625194401244)*sj10))+(((3.1104199066874)*x969))));
sj12array[0]=IKsin(j12array[0]);
cj12array[0]=IKcos(j12array[0]);
if( j12array[0] > IKPI )
{
    j12array[0]-=IK2PI;
}
else if( j12array[0] < -IKPI )
{    j12array[0]+=IK2PI;
}
j12valid[0] = true;
for(int ij12 = 0; ij12 < 1; ++ij12)
{
if( !j12valid[ij12] )
{
    continue;
}
_ij12[0] = ij12; _ij12[1] = -1;
for(int iij12 = ij12+1; iij12 < 1; ++iij12)
{
if( j12valid[iij12] && IKabs(cj12array[ij12]-cj12array[iij12]) < IKFAST_SOLUTION_THRESH && IKabs(sj12array[ij12]-sj12array[iij12]) < IKFAST_SOLUTION_THRESH )
{
    j12valid[iij12]=false; _ij12[1] = iij12; break; 
}
}
j12 = j12array[ij12]; cj12 = cj12array[ij12]; sj12 = sj12array[ij12];
{
IkReal evalcond[6];
IkReal x973=IKcos(j12);
IkReal x974=IKsin(j12);
IkReal x975=((1.0)*py);
IkReal x976=(cj9*sj11);
IkReal x977=(cj10*sj9);
IkReal x978=((1.0)*cj10);
IkReal x979=(cj10*cj9);
IkReal x980=(sj11*sj9);
IkReal x981=(cj11*sj10);
IkReal x982=(cj9*px);
IkReal x983=(cj10*cj11);
IkReal x984=((0.3215)*x973);
IkReal x985=((0.3215)*x974);
evalcond[0]=((0.06)+(((-0.352)*sj10))+(((-1.0)*sj10*x984))+(((-1.0)*pz))+j5+(((-1.0)*x983*x985)));
evalcond[1]=((0.352)+(((-0.06)*sj10))+(((0.117)*cj10))+(((-1.0)*j5*sj10))+((pz*sj10))+(((-1.0)*x978*x982))+x984+(((-1.0)*x975*x977)));
evalcond[2]=((((-1.0)*cj9*x981*x985))+((x979*x984))+(((-1.0)*px))+(((0.117)*cj9))+(((-1.0)*x980*x985))+(((0.352)*x979)));
evalcond[3]=((((0.117)*sj9))+(((-1.0)*sj9*x981*x985))+((x977*x984))+((x976*x985))+(((0.352)*x977))+(((-1.0)*x975)));
evalcond[4]=(((x981*x982))+(((-0.117)*x981))+((py*sj9*x981))+(((-0.06)*x983))+((pz*x983))+(((-1.0)*cj11*j5*x978))+x985+((px*x980))+(((-1.0)*x975*x976)));
evalcond[5]=((0.24455525)+(((-1.0)*(j5*j5)))+(((-0.04224)*sj10))+(((0.226336)*x973))+(((0.075231)*cj10*x973))+(((0.082368)*cj10))+(((-0.03858)*sj10*x973))+(((-0.03858)*x974*x983))+(((-1.0)*pp))+(((-0.075231)*x974*x981))+(((2.0)*j5*pz)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}

}

} else
{
{
IkReal j12array[1], cj12array[1], sj12array[1];
bool j12valid[1]={false};
_nj12 = 1;
IkReal x986=cj10*cj10;
IkReal x987=(j5*sj10);
IkReal x988=((0.117)*cj9);
IkReal x989=(cj9*sj10);
IkReal x990=(py*sj9);
IkReal x991=((3.1104199066874)*cj10);
IkReal x992=((1.0)*x986);
CheckValue<IkReal> x993=IKPowWithIntegerCheck(((((-0.3215)*cj11*x989))+(((-0.3215)*sj11*sj9))),-1);
if(!x993.valid){
continue;
}
if( IKabs(((x993.value)*(((((-1.0)*x988))+((x986*x988))+(((-1.0)*cj10*cj9*x987))+px+(((-0.06)*cj10*x989))+(((-1.0)*px*x992*(cj9*cj9)))+((cj10*pz*x989))+(((-1.0)*cj9*x990*x992)))))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((-1.09486780715397)+(((-0.363919129082426)*cj10))+((x990*x991))+(((-3.1104199066874)*pz*sj10))+(((0.186625194401244)*sj10))+(((3.1104199066874)*x987))+((cj9*px*x991)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((x993.value)*(((((-1.0)*x988))+((x986*x988))+(((-1.0)*cj10*cj9*x987))+px+(((-0.06)*cj10*x989))+(((-1.0)*px*x992*(cj9*cj9)))+((cj10*pz*x989))+(((-1.0)*cj9*x990*x992))))))+IKsqr(((-1.09486780715397)+(((-0.363919129082426)*cj10))+((x990*x991))+(((-3.1104199066874)*pz*sj10))+(((0.186625194401244)*sj10))+(((3.1104199066874)*x987))+((cj9*px*x991))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j12array[0]=IKatan2(((x993.value)*(((((-1.0)*x988))+((x986*x988))+(((-1.0)*cj10*cj9*x987))+px+(((-0.06)*cj10*x989))+(((-1.0)*px*x992*(cj9*cj9)))+((cj10*pz*x989))+(((-1.0)*cj9*x990*x992))))), ((-1.09486780715397)+(((-0.363919129082426)*cj10))+((x990*x991))+(((-3.1104199066874)*pz*sj10))+(((0.186625194401244)*sj10))+(((3.1104199066874)*x987))+((cj9*px*x991))));
sj12array[0]=IKsin(j12array[0]);
cj12array[0]=IKcos(j12array[0]);
if( j12array[0] > IKPI )
{
    j12array[0]-=IK2PI;
}
else if( j12array[0] < -IKPI )
{    j12array[0]+=IK2PI;
}
j12valid[0] = true;
for(int ij12 = 0; ij12 < 1; ++ij12)
{
if( !j12valid[ij12] )
{
    continue;
}
_ij12[0] = ij12; _ij12[1] = -1;
for(int iij12 = ij12+1; iij12 < 1; ++iij12)
{
if( j12valid[iij12] && IKabs(cj12array[ij12]-cj12array[iij12]) < IKFAST_SOLUTION_THRESH && IKabs(sj12array[ij12]-sj12array[iij12]) < IKFAST_SOLUTION_THRESH )
{
    j12valid[iij12]=false; _ij12[1] = iij12; break; 
}
}
j12 = j12array[ij12]; cj12 = cj12array[ij12]; sj12 = sj12array[ij12];
{
IkReal evalcond[6];
IkReal x994=IKcos(j12);
IkReal x995=IKsin(j12);
IkReal x996=((1.0)*py);
IkReal x997=(cj9*sj11);
IkReal x998=(cj10*sj9);
IkReal x999=((1.0)*cj10);
IkReal x1000=(cj10*cj9);
IkReal x1001=(sj11*sj9);
IkReal x1002=(cj11*sj10);
IkReal x1003=(cj9*px);
IkReal x1004=(cj10*cj11);
IkReal x1005=((0.3215)*x994);
IkReal x1006=((0.3215)*x995);
evalcond[0]=((0.06)+(((-0.352)*sj10))+(((-1.0)*sj10*x1005))+(((-1.0)*pz))+(((-1.0)*x1004*x1006))+j5);
evalcond[1]=((0.352)+x1005+(((-1.0)*x1003*x999))+(((-0.06)*sj10))+(((0.117)*cj10))+(((-1.0)*x996*x998))+(((-1.0)*j5*sj10))+((pz*sj10)));
evalcond[2]=(((x1000*x1005))+(((-1.0)*px))+(((0.352)*x1000))+(((0.117)*cj9))+(((-1.0)*x1001*x1006))+(((-1.0)*cj9*x1002*x1006)));
evalcond[3]=((((0.352)*x998))+(((0.117)*sj9))+(((-1.0)*x996))+((x1005*x998))+(((-1.0)*sj9*x1002*x1006))+((x1006*x997)));
evalcond[4]=(((py*sj9*x1002))+((px*x1001))+x1006+(((-0.117)*x1002))+(((-1.0)*x996*x997))+((pz*x1004))+((x1002*x1003))+(((-1.0)*cj11*j5*x999))+(((-0.06)*x1004)));
evalcond[5]=((0.24455525)+(((-0.075231)*x1002*x995))+(((-1.0)*(j5*j5)))+(((-0.03858)*x1004*x995))+(((-0.04224)*sj10))+(((0.082368)*cj10))+(((0.226336)*x994))+(((0.075231)*cj10*x994))+(((-1.0)*pp))+(((-0.03858)*sj10*x994))+(((2.0)*j5*pz)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}

}
}
}
    }

} else
{
IkReal op[4+1], zeror[4];
int numroots;
IkReal x1007=pz*pz;
IkReal x1008=sj10*sj10;
IkReal x1009=((2.41867799897932)*pp);
IkReal x1010=((0.363919129082426)*cj11*sj10);
IkReal x1011=((2.41867799897932)*x1007);
IkReal x1012=(cj10*cj11*sj10);
op[0]=((0.0353592583365784)+(((-0.00224997520855051)*x1008))+x1011+(((-1.0)*x1009))+(((0.0172621048787154)*cj10)));
op[1]=((((-1.0)*x1010))+(((-0.0948678071539658)*x1012)));
op[2]=((1.16558632382712)+(((-1.0)*(cj10*cj10)*(cj11*cj11)))+(((0.398443338839857)*cj10))+(((4.83735599795864)*x1007))+(((-4.83735599795864)*pp))+(((-0.0993677575710668)*x1008)));
op[3]=((((-1.0)*x1010))+(((-2.09486780715397)*x1012)));
op[4]=((1.13022706549054)+x1011+(((-1.0)*x1009))+(((0.381181233961142)*cj10))+(((-1.09711778236252)*x1008)));
polyroots4(op,zeror,numroots);
IkReal j12array[4], cj12array[4], sj12array[4], tempj12array[1];
int numsolutions = 0;
for(int ij12 = 0; ij12 < numroots; ++ij12)
{
IkReal htj12 = zeror[ij12];
tempj12array[0]=((2.0)*(atan(htj12)));
for(int kj12 = 0; kj12 < 1; ++kj12)
{
j12array[numsolutions] = tempj12array[kj12];
if( j12array[numsolutions] > IKPI )
{
    j12array[numsolutions]-=IK2PI;
}
else if( j12array[numsolutions] < -IKPI )
{
    j12array[numsolutions]+=IK2PI;
}
sj12array[numsolutions] = IKsin(j12array[numsolutions]);
cj12array[numsolutions] = IKcos(j12array[numsolutions]);
numsolutions++;
}
}
bool j12valid[4]={true,true,true,true};
_nj12 = 4;
for(int ij12 = 0; ij12 < numsolutions; ++ij12)
    {
if( !j12valid[ij12] )
{
    continue;
}
    j12 = j12array[ij12]; cj12 = cj12array[ij12]; sj12 = sj12array[ij12];
htj12 = IKtan(j12/2);

_ij12[0] = ij12; _ij12[1] = -1;
for(int iij12 = ij12+1; iij12 < numsolutions; ++iij12)
{
if( j12valid[iij12] && IKabs(cj12array[ij12]-cj12array[iij12]) < IKFAST_SOLUTION_THRESH && IKabs(sj12array[ij12]-sj12array[iij12]) < IKFAST_SOLUTION_THRESH )
{
    j12valid[iij12]=false; _ij12[1] = iij12; break; 
}
}
{
IkReal j5array[1], cj5array[1], sj5array[1];
bool j5valid[1]={false};
_nj5 = 1;
j5array[0]=((-0.06)+(((0.352)*sj10))+(((0.3215)*cj12*sj10))+pz+(((0.3215)*cj10*cj11*sj12)));
sj5array[0]=IKsin(j5array[0]);
cj5array[0]=IKcos(j5array[0]);
j5valid[0] = true;
for(int ij5 = 0; ij5 < 1; ++ij5)
{
if( !j5valid[ij5] )
{
    continue;
}
_ij5[0] = ij5; _ij5[1] = -1;
for(int iij5 = ij5+1; iij5 < 1; ++iij5)
{
if( j5valid[iij5] && IKabs(cj5array[ij5]-cj5array[iij5]) < IKFAST_SOLUTION_THRESH && IKabs(sj5array[ij5]-sj5array[iij5]) < IKFAST_SOLUTION_THRESH )
{
    j5valid[iij5]=false; _ij5[1] = iij5; break; 
}
}
j5 = j5array[ij5]; cj5 = cj5array[ij5]; sj5 = sj5array[ij5];

{
IkReal j9eval[3];
IkReal x1013=cj10*cj10;
IkReal x1014=cj12*cj12;
IkReal x1015=cj11*cj11;
IkReal x1016=((1286000.0)*py);
IkReal x1017=(cj10*cj12);
IkReal x1018=((1286000.0)*px);
IkReal x1019=((1408000.0)*cj10);
IkReal x1020=(sj11*sj12);
IkReal x1021=(cj11*sj10*sj12);
IkReal x1022=((1.37393162393162)*x1014);
IkReal x1023=((413449.0)*x1014);
IkReal x1024=(cj12*x1013);
IkReal x1025=(x1013*x1015);
j9eval[0]=((1.55589118847284)+(((-3.00854700854701)*cj10*x1021))+(((1.09486780715397)*cj10))+x1017+(((-1.0)*x1021))+(((-1.0)*x1022))+((x1022*x1025))+(((3.00854700854701)*x1024))+(((-1.37393162393162)*x1025))+((x1013*x1022))+(((1.64698063298374)*x1013))+(((-2.74786324786325)*x1017*x1021)));
j9eval[1]=IKsign(((468205.0)+(((-413449.0)*x1025))+(((300924.0)*x1017))+(((-1.0)*x1023))+(((495616.0)*x1013))+((x1023*x1025))+(((-826898.0)*x1017*x1021))+(((-300924.0)*x1021))+(((905344.0)*x1024))+((x1013*x1023))+(((329472.0)*cj10))+(((-905344.0)*cj10*x1021))));
j9eval[2]=((IKabs((((x1016*x1017))+(((-1.0)*x1018*x1020))+(((-1.0)*x1016*x1021))+((py*x1019))+(((468000.0)*py)))))+(IKabs((((x1017*x1018))+(((-1.0)*x1018*x1021))+(((468000.0)*px))+((x1016*x1020))+((px*x1019))))));
if( IKabs(j9eval[0]) < 0.0000010000000000  || IKabs(j9eval[1]) < 0.0000010000000000  || IKabs(j9eval[2]) < 0.0000010000000000  )
{
{
IkReal j9eval[2];
IkReal x1026=cj10*cj10;
IkReal x1027=(cj10*py);
IkReal x1028=(py*x1026);
IkReal x1029=(cj11*sj10*sj12);
IkReal x1030=(cj10*px*sj11*sj12);
j9eval[0]=(x1027+(((-2.74786324786325)*x1027*x1029))+(((3.00854700854701)*x1028))+(((2.74786324786325)*x1030))+(((2.74786324786325)*cj12*x1028)));
j9eval[1]=IKsign(((((704.0)*x1028))+(((643.0)*cj12*x1028))+(((643.0)*x1030))+(((-643.0)*x1027*x1029))+(((234.0)*x1027))));
if( IKabs(j9eval[0]) < 0.0000010000000000  || IKabs(j9eval[1]) < 0.0000010000000000  )
{
{
IkReal j9eval[2];
IkReal x1031=cj10*cj10;
IkReal x1032=(cj10*px);
IkReal x1033=(cj11*sj10*sj12);
IkReal x1034=(px*x1031);
IkReal x1035=(cj12*x1034);
IkReal x1036=(cj10*py*sj11*sj12);
j9eval[0]=((((-2.74786324786325)*x1036))+x1032+(((3.00854700854701)*x1034))+(((-2.74786324786325)*x1032*x1033))+(((2.74786324786325)*x1035)));
j9eval[1]=IKsign(((((643.0)*x1035))+(((234.0)*x1032))+(((-643.0)*x1032*x1033))+(((-643.0)*x1036))+(((704.0)*x1034))));
if( IKabs(j9eval[0]) < 0.0000010000000000  || IKabs(j9eval[1]) < 0.0000010000000000  )
{
{
IkReal evalcond[1];
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((-1.5707963267949)+j10)))), 6.28318530717959)));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j9eval[3];
sj10=1.0;
cj10=0;
j10=1.5707963267949;
IkReal x1037=cj12*cj12;
IkReal x1038=((1286000.0)*sj12);
IkReal x1039=(cj11*sj12);
j9eval[0]=((1.55589118847284)+(((-1.0)*x1039))+(((-1.37393162393162)*x1037)));
j9eval[1]=IKsign(((468205.0)+(((-413449.0)*x1037))+(((-300924.0)*x1039))));
j9eval[2]=((IKabs((((py*sj11*x1038))+(((468000.0)*px))+(((-1.0)*cj11*px*x1038)))))+(IKabs(((((-1.0)*px*sj11*x1038))+(((-1.0)*cj11*py*x1038))+(((468000.0)*py))))));
if( IKabs(j9eval[0]) < 0.0000010000000000  || IKabs(j9eval[1]) < 0.0000010000000000  || IKabs(j9eval[2]) < 0.0000010000000000  )
{
{
IkReal j9eval[3];
sj10=1.0;
cj10=0;
j10=1.5707963267949;
IkReal x1040=cj11*cj11;
IkReal x1041=pz*pz;
IkReal x1042=(cj11*pp);
IkReal x1043=(cj11*sj11);
IkReal x1044=((234.0)*cj11);
IkReal x1045=(cj11*x1041);
IkReal x1046=((643.0)*py*sj12);
IkReal x1047=((643.0)*px*sj12);
j9eval[0]=(x1045+(((-1.0)*x1042)));
j9eval[1]=((IKabs((((x1043*x1047))+((x1040*x1046))+(((-1.0)*py*x1044)))))+(IKabs((((x1040*x1047))+(((-1.0)*px*x1044))+(((-1.0)*x1043*x1046))))));
j9eval[2]=IKsign(((((117000.0)*x1045))+(((-117000.0)*x1042))));
if( IKabs(j9eval[0]) < 0.0000010000000000  || IKabs(j9eval[1]) < 0.0000010000000000  || IKabs(j9eval[2]) < 0.0000010000000000  )
{
{
IkReal j9eval[3];
sj10=1.0;
cj10=0;
j10=1.5707963267949;
IkReal x1048=cj11*cj11;
IkReal x1049=cj12*cj12;
IkReal x1050=(sj11*sj12);
IkReal x1051=((24186.7665)*x1048);
IkReal x1052=(cj11*py*sj12);
IkReal x1053=((24186.7665)*cj11*sj11);
j9eval[0]=((((2.74786324786325)*x1052))+(((-2.74786324786325)*px*x1050))+(((-1.0)*py)));
j9eval[1]=IKsign(((((-75231.0)*px*x1050))+(((75231.0)*x1052))+(((-27378.0)*py))));
j9eval[2]=((IKabs(((-3203.226)+(((-1.0)*x1051))+(((234000.0)*(px*px)))+(((17604.054)*cj11*sj12))+((x1049*x1051)))))+(IKabs(((((-8802.027)*x1050))+(((-234000.0)*px*py))+x1053+(((-1.0)*x1049*x1053))))));
if( IKabs(j9eval[0]) < 0.0000010000000000  || IKabs(j9eval[1]) < 0.0000010000000000  || IKabs(j9eval[2]) < 0.0000010000000000  )
{
{
IkReal evalcond[1];
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((-1.5707963267949)+j11)))), 6.28318530717959)));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j9eval[3];
sj10=1.0;
cj10=0;
j10=1.5707963267949;
sj11=1.0;
cj11=0;
j11=1.5707963267949;
IkReal x1054=pz*pz;
IkReal x1055=((643.0)*sj12);
j9eval[0]=(pp+(((-1.0)*x1054)));
j9eval[1]=IKsign(((((-2000.0)*x1054))+(((2000.0)*pp))));
j9eval[2]=((IKabs((((py*x1055))+(((234.0)*px)))))+(IKabs(((((-1.0)*px*x1055))+(((234.0)*py))))));
if( IKabs(j9eval[0]) < 0.0000010000000000  || IKabs(j9eval[1]) < 0.0000010000000000  || IKabs(j9eval[2]) < 0.0000010000000000  )
{
{
IkReal j9eval[1];
sj10=1.0;
cj10=0;
j10=1.5707963267949;
sj11=1.0;
cj11=0;
j11=1.5707963267949;
j9eval[0]=((((2.74786324786325)*px*sj12))+py);
if( IKabs(j9eval[0]) < 0.0000010000000000  )
{
{
IkReal j9eval[1];
sj10=1.0;
cj10=0;
j10=1.5707963267949;
sj11=1.0;
cj11=0;
j11=1.5707963267949;
j9eval[0]=((((-2.74786324786325)*py*sj12))+px);
if( IKabs(j9eval[0]) < 0.0000010000000000  )
{
{
IkReal evalcond[1];
bool bgotonextstatement = true;
do
{
evalcond[0]=((IKabs(px))+(IKabs(py)));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j9eval[1];
IkReal x1056=((-1.0)*pz);
sj10=1.0;
cj10=0;
j10=1.5707963267949;
sj11=1.0;
cj11=0;
j11=1.5707963267949;
px=0;
py=0;
pp=pz*pz;
npx=(pz*r20);
npy=(pz*r21);
npz=(pz*r22);
rxp0_0=(pz*r10);
rxp0_1=(r00*x1056);
rxp0_2=0;
rxp1_0=(pz*r11);
rxp1_1=(r01*x1056);
rxp1_2=0;
rxp2_0=(pz*r12);
rxp2_1=(r02*x1056);
rxp2_2=0;
j9eval[0]=1.0;
if( IKabs(j9eval[0]) < 0.0000000100000000  )
{
continue; // 3 cases reached

} else
{
IkReal op[2+1], zeror[2];
int numroots;
op[0]=-1.0;
op[1]=0;
op[2]=1.0;
polyroots2(op,zeror,numroots);
IkReal j9array[2], cj9array[2], sj9array[2], tempj9array[1];
int numsolutions = 0;
for(int ij9 = 0; ij9 < numroots; ++ij9)
{
IkReal htj9 = zeror[ij9];
tempj9array[0]=((2.0)*(atan(htj9)));
for(int kj9 = 0; kj9 < 1; ++kj9)
{
j9array[numsolutions] = tempj9array[kj9];
if( j9array[numsolutions] > IKPI )
{
    j9array[numsolutions]-=IK2PI;
}
else if( j9array[numsolutions] < -IKPI )
{
    j9array[numsolutions]+=IK2PI;
}
sj9array[numsolutions] = IKsin(j9array[numsolutions]);
cj9array[numsolutions] = IKcos(j9array[numsolutions]);
numsolutions++;
}
}
bool j9valid[2]={true,true};
_nj9 = 2;
for(int ij9 = 0; ij9 < numsolutions; ++ij9)
    {
if( !j9valid[ij9] )
{
    continue;
}
    j9 = j9array[ij9]; cj9 = cj9array[ij9]; sj9 = sj9array[ij9];
htj9 = IKtan(j9/2);

_ij9[0] = ij9; _ij9[1] = -1;
for(int iij9 = ij9+1; iij9 < numsolutions; ++iij9)
{
if( j9valid[iij9] && IKabs(cj9array[ij9]-cj9array[iij9]) < IKFAST_SOLUTION_THRESH && IKabs(sj9array[ij9]-sj9array[iij9]) < IKFAST_SOLUTION_THRESH )
{
    j9valid[iij9]=false; _ij9[1] = iij9; break; 
}
}
rotationfunction0(solutions);
    }

}

}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((IKabs(px))+(IKabs(((-3.14159265358979)+(IKfmod(((3.14159265358979)+j12), 6.28318530717959))))));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j9array[2], cj9array[2], sj9array[2];
bool j9valid[2]={false};
_nj9 = 2;
sj9array[0]=((8.54700854700855)*py);
if( sj9array[0] >= -1-IKFAST_SINCOS_THRESH && sj9array[0] <= 1+IKFAST_SINCOS_THRESH )
{
    j9valid[0] = j9valid[1] = true;
    j9array[0] = IKasin(sj9array[0]);
    cj9array[0] = IKcos(j9array[0]);
    sj9array[1] = sj9array[0];
    j9array[1] = j9array[0] > 0 ? (IKPI-j9array[0]) : (-IKPI-j9array[0]);
    cj9array[1] = -cj9array[0];
}
else if( isnan(sj9array[0]) )
{
    // probably any value will work
    j9valid[0] = true;
    cj9array[0] = 1; sj9array[0] = 0; j9array[0] = 0;
}
for(int ij9 = 0; ij9 < 2; ++ij9)
{
if( !j9valid[ij9] )
{
    continue;
}
_ij9[0] = ij9; _ij9[1] = -1;
for(int iij9 = ij9+1; iij9 < 2; ++iij9)
{
if( j9valid[iij9] && IKabs(cj9array[ij9]-cj9array[iij9]) < IKFAST_SOLUTION_THRESH && IKabs(sj9array[ij9]-sj9array[iij9]) < IKFAST_SOLUTION_THRESH )
{
    j9valid[iij9]=false; _ij9[1] = iij9; break; 
}
}
j9 = j9array[ij9]; cj9 = cj9array[ij9]; sj9 = sj9array[ij9];
{
IkReal evalcond[4];
IkReal x1057=IKcos(j9);
IkReal x1058=IKsin(j9);
IkReal x1059=(py*x1058);
evalcond[0]=((0.117)*x1057);
evalcond[1]=((-1.0)*py*x1057);
evalcond[2]=((-0.027378)+(((0.234)*x1059)));
evalcond[3]=((0.117)+(((-1.0)*x1059)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((IKabs(((-3.14159265358979)+(IKfmod(j12, 6.28318530717959)))))+(IKabs(px)));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j9array[2], cj9array[2], sj9array[2];
bool j9valid[2]={false};
_nj9 = 2;
sj9array[0]=((8.54700854700855)*py);
if( sj9array[0] >= -1-IKFAST_SINCOS_THRESH && sj9array[0] <= 1+IKFAST_SINCOS_THRESH )
{
    j9valid[0] = j9valid[1] = true;
    j9array[0] = IKasin(sj9array[0]);
    cj9array[0] = IKcos(j9array[0]);
    sj9array[1] = sj9array[0];
    j9array[1] = j9array[0] > 0 ? (IKPI-j9array[0]) : (-IKPI-j9array[0]);
    cj9array[1] = -cj9array[0];
}
else if( isnan(sj9array[0]) )
{
    // probably any value will work
    j9valid[0] = true;
    cj9array[0] = 1; sj9array[0] = 0; j9array[0] = 0;
}
for(int ij9 = 0; ij9 < 2; ++ij9)
{
if( !j9valid[ij9] )
{
    continue;
}
_ij9[0] = ij9; _ij9[1] = -1;
for(int iij9 = ij9+1; iij9 < 2; ++iij9)
{
if( j9valid[iij9] && IKabs(cj9array[ij9]-cj9array[iij9]) < IKFAST_SOLUTION_THRESH && IKabs(sj9array[ij9]-sj9array[iij9]) < IKFAST_SOLUTION_THRESH )
{
    j9valid[iij9]=false; _ij9[1] = iij9; break; 
}
}
j9 = j9array[ij9]; cj9 = cj9array[ij9]; sj9 = sj9array[ij9];
{
IkReal evalcond[4];
IkReal x1060=IKcos(j9);
IkReal x1061=IKsin(j9);
IkReal x1062=(py*x1061);
evalcond[0]=((0.117)*x1060);
evalcond[1]=((-1.0)*py*x1060);
evalcond[2]=((-0.027378)+(((0.234)*x1062)));
evalcond[3]=((0.117)+(((-1.0)*x1062)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
if( 1 )
{
bgotonextstatement=false;
continue; // branch miss [j9]

}
} while(0);
if( bgotonextstatement )
{
}
}
}
}
}

} else
{
{
IkReal j9array[1], cj9array[1], sj9array[1];
bool j9valid[1]={false};
_nj9 = 1;
IkReal x1063=(py*sj12);
CheckValue<IkReal> x1064=IKPowWithIntegerCheck(((((-643000.0)*x1063))+(((234000.0)*px))),-1);
if(!x1064.valid){
continue;
}
CheckValue<IkReal> x1065=IKPowWithIntegerCheck(((((117000.0)*px))+(((-321500.0)*x1063))),-1);
if(!x1065.valid){
continue;
}
if( IKabs(((x1064.value)*(((((-75231.0)*sj12))+(((2000000.0)*px*py)))))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((x1065.value)*(((13689.0)+(((-1000000.0)*(py*py))))))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((x1064.value)*(((((-75231.0)*sj12))+(((2000000.0)*px*py))))))+IKsqr(((x1065.value)*(((13689.0)+(((-1000000.0)*(py*py)))))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j9array[0]=IKatan2(((x1064.value)*(((((-75231.0)*sj12))+(((2000000.0)*px*py))))), ((x1065.value)*(((13689.0)+(((-1000000.0)*(py*py)))))));
sj9array[0]=IKsin(j9array[0]);
cj9array[0]=IKcos(j9array[0]);
if( j9array[0] > IKPI )
{
    j9array[0]-=IK2PI;
}
else if( j9array[0] < -IKPI )
{    j9array[0]+=IK2PI;
}
j9valid[0] = true;
for(int ij9 = 0; ij9 < 1; ++ij9)
{
if( !j9valid[ij9] )
{
    continue;
}
_ij9[0] = ij9; _ij9[1] = -1;
for(int iij9 = ij9+1; iij9 < 1; ++iij9)
{
if( j9valid[iij9] && IKabs(cj9array[ij9]-cj9array[iij9]) < IKFAST_SOLUTION_THRESH && IKabs(sj9array[ij9]-sj9array[iij9]) < IKFAST_SOLUTION_THRESH )
{
    j9valid[iij9]=false; _ij9[1] = iij9; break; 
}
}
j9 = j9array[ij9]; cj9 = cj9array[ij9]; sj9 = sj9array[ij9];
{
IkReal evalcond[5];
IkReal x1066=IKcos(j9);
IkReal x1067=IKsin(j9);
IkReal x1068=((0.3215)*sj12);
IkReal x1069=((1.0)*px);
IkReal x1070=((1.0)*py);
evalcond[0]=((-0.027378)+(((0.234)*px*x1066))+(((0.234)*py*x1067)));
evalcond[1]=((0.117)+(((-1.0)*x1067*x1070))+(((-1.0)*x1066*x1069)));
evalcond[2]=((((0.117)*x1066))+(((-1.0)*x1067*x1068))+(((-1.0)*x1069)));
evalcond[3]=(((x1066*x1068))+(((0.117)*x1067))+(((-1.0)*x1070)));
evalcond[4]=(x1068+((px*x1067))+(((-1.0)*x1066*x1070)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}

}

} else
{
{
IkReal j9array[1], cj9array[1], sj9array[1];
bool j9valid[1]={false};
_nj9 = 1;
IkReal x1071=(px*sj12);
CheckValue<IkReal> x1072=IKPowWithIntegerCheck(((((117000.0)*py))+(((321500.0)*x1071))),-1);
if(!x1072.valid){
continue;
}
CheckValue<IkReal> x1073=IKPowWithIntegerCheck(((((643000.0)*x1071))+(((234000.0)*py))),-1);
if(!x1073.valid){
continue;
}
if( IKabs(((x1072.value)*(((13689.0)+(((-1000000.0)*(px*px))))))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((x1073.value)*(((((2000000.0)*px*py))+(((75231.0)*sj12)))))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((x1072.value)*(((13689.0)+(((-1000000.0)*(px*px)))))))+IKsqr(((x1073.value)*(((((2000000.0)*px*py))+(((75231.0)*sj12))))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j9array[0]=IKatan2(((x1072.value)*(((13689.0)+(((-1000000.0)*(px*px)))))), ((x1073.value)*(((((2000000.0)*px*py))+(((75231.0)*sj12))))));
sj9array[0]=IKsin(j9array[0]);
cj9array[0]=IKcos(j9array[0]);
if( j9array[0] > IKPI )
{
    j9array[0]-=IK2PI;
}
else if( j9array[0] < -IKPI )
{    j9array[0]+=IK2PI;
}
j9valid[0] = true;
for(int ij9 = 0; ij9 < 1; ++ij9)
{
if( !j9valid[ij9] )
{
    continue;
}
_ij9[0] = ij9; _ij9[1] = -1;
for(int iij9 = ij9+1; iij9 < 1; ++iij9)
{
if( j9valid[iij9] && IKabs(cj9array[ij9]-cj9array[iij9]) < IKFAST_SOLUTION_THRESH && IKabs(sj9array[ij9]-sj9array[iij9]) < IKFAST_SOLUTION_THRESH )
{
    j9valid[iij9]=false; _ij9[1] = iij9; break; 
}
}
j9 = j9array[ij9]; cj9 = cj9array[ij9]; sj9 = sj9array[ij9];
{
IkReal evalcond[5];
IkReal x1074=IKcos(j9);
IkReal x1075=IKsin(j9);
IkReal x1076=((0.3215)*sj12);
IkReal x1077=((1.0)*px);
IkReal x1078=((1.0)*py);
evalcond[0]=((-0.027378)+(((0.234)*py*x1075))+(((0.234)*px*x1074)));
evalcond[1]=((0.117)+(((-1.0)*x1075*x1078))+(((-1.0)*x1074*x1077)));
evalcond[2]=((((-1.0)*x1075*x1076))+(((0.117)*x1074))+(((-1.0)*x1077)));
evalcond[3]=(((x1074*x1076))+(((0.117)*x1075))+(((-1.0)*x1078)));
evalcond[4]=((((-1.0)*x1074*x1078))+x1076+((px*x1075)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}

}

} else
{
{
IkReal j9array[1], cj9array[1], sj9array[1];
bool j9valid[1]={false};
_nj9 = 1;
IkReal x1079=((643.0)*sj12);
CheckValue<IkReal> x1080 = IKatan2WithCheck(IkReal(((((-1.0)*px*x1079))+(((234.0)*py)))),IkReal((((py*x1079))+(((234.0)*px)))),IKFAST_ATAN2_MAGTHRESH);
if(!x1080.valid){
continue;
}
CheckValue<IkReal> x1081=IKPowWithIntegerCheck(IKsign(((((2000.0)*pp))+(((-2000.0)*(pz*pz))))),-1);
if(!x1081.valid){
continue;
}
j9array[0]=((-1.5707963267949)+(x1080.value)+(((1.5707963267949)*(x1081.value))));
sj9array[0]=IKsin(j9array[0]);
cj9array[0]=IKcos(j9array[0]);
if( j9array[0] > IKPI )
{
    j9array[0]-=IK2PI;
}
else if( j9array[0] < -IKPI )
{    j9array[0]+=IK2PI;
}
j9valid[0] = true;
for(int ij9 = 0; ij9 < 1; ++ij9)
{
if( !j9valid[ij9] )
{
    continue;
}
_ij9[0] = ij9; _ij9[1] = -1;
for(int iij9 = ij9+1; iij9 < 1; ++iij9)
{
if( j9valid[iij9] && IKabs(cj9array[ij9]-cj9array[iij9]) < IKFAST_SOLUTION_THRESH && IKabs(sj9array[ij9]-sj9array[iij9]) < IKFAST_SOLUTION_THRESH )
{
    j9valid[iij9]=false; _ij9[1] = iij9; break; 
}
}
j9 = j9array[ij9]; cj9 = cj9array[ij9]; sj9 = sj9array[ij9];
{
IkReal evalcond[5];
IkReal x1082=IKcos(j9);
IkReal x1083=IKsin(j9);
IkReal x1084=((0.3215)*sj12);
IkReal x1085=((1.0)*px);
IkReal x1086=((1.0)*py);
evalcond[0]=((-0.027378)+(((0.234)*px*x1082))+(((0.234)*py*x1083)));
evalcond[1]=((0.117)+(((-1.0)*x1082*x1085))+(((-1.0)*x1083*x1086)));
evalcond[2]=((((0.117)*x1082))+(((-1.0)*x1083*x1084))+(((-1.0)*x1085)));
evalcond[3]=(((x1082*x1084))+(((0.117)*x1083))+(((-1.0)*x1086)));
evalcond[4]=(x1084+((px*x1083))+(((-1.0)*x1082*x1086)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}

}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((1.5707963267949)+j11)))), 6.28318530717959)));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j9eval[3];
sj10=1.0;
cj10=0;
j10=1.5707963267949;
sj11=-1.0;
cj11=0;
j11=-1.5707963267949;
IkReal x1087=pz*pz;
IkReal x1088=((643.0)*sj12);
j9eval[0]=((((-1.0)*x1087))+pp);
j9eval[1]=IKsign(((((-2000.0)*x1087))+(((2000.0)*pp))));
j9eval[2]=((IKabs(((((-1.0)*py*x1088))+(((234.0)*px)))))+(IKabs((((px*x1088))+(((234.0)*py))))));
if( IKabs(j9eval[0]) < 0.0000010000000000  || IKabs(j9eval[1]) < 0.0000010000000000  || IKabs(j9eval[2]) < 0.0000010000000000  )
{
{
IkReal j9eval[1];
sj10=1.0;
cj10=0;
j10=1.5707963267949;
sj11=-1.0;
cj11=0;
j11=-1.5707963267949;
j9eval[0]=((((-1.0)*py))+(((2.74786324786325)*px*sj12)));
if( IKabs(j9eval[0]) < 0.0000010000000000  )
{
{
IkReal j9eval[1];
sj10=1.0;
cj10=0;
j10=1.5707963267949;
sj11=-1.0;
cj11=0;
j11=-1.5707963267949;
j9eval[0]=((((2.74786324786325)*py*sj12))+px);
if( IKabs(j9eval[0]) < 0.0000010000000000  )
{
{
IkReal evalcond[1];
bool bgotonextstatement = true;
do
{
evalcond[0]=((IKabs(px))+(IKabs(py)));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j9eval[1];
IkReal x1089=((-1.0)*pz);
sj10=1.0;
cj10=0;
j10=1.5707963267949;
sj11=-1.0;
cj11=0;
j11=-1.5707963267949;
px=0;
py=0;
pp=pz*pz;
npx=(pz*r20);
npy=(pz*r21);
npz=(pz*r22);
rxp0_0=(pz*r10);
rxp0_1=(r00*x1089);
rxp0_2=0;
rxp1_0=(pz*r11);
rxp1_1=(r01*x1089);
rxp1_2=0;
rxp2_0=(pz*r12);
rxp2_1=(r02*x1089);
rxp2_2=0;
j9eval[0]=1.0;
if( IKabs(j9eval[0]) < 0.0000000100000000  )
{
continue; // 3 cases reached

} else
{
IkReal op[2+1], zeror[2];
int numroots;
op[0]=-1.0;
op[1]=0;
op[2]=1.0;
polyroots2(op,zeror,numroots);
IkReal j9array[2], cj9array[2], sj9array[2], tempj9array[1];
int numsolutions = 0;
for(int ij9 = 0; ij9 < numroots; ++ij9)
{
IkReal htj9 = zeror[ij9];
tempj9array[0]=((2.0)*(atan(htj9)));
for(int kj9 = 0; kj9 < 1; ++kj9)
{
j9array[numsolutions] = tempj9array[kj9];
if( j9array[numsolutions] > IKPI )
{
    j9array[numsolutions]-=IK2PI;
}
else if( j9array[numsolutions] < -IKPI )
{
    j9array[numsolutions]+=IK2PI;
}
sj9array[numsolutions] = IKsin(j9array[numsolutions]);
cj9array[numsolutions] = IKcos(j9array[numsolutions]);
numsolutions++;
}
}
bool j9valid[2]={true,true};
_nj9 = 2;
for(int ij9 = 0; ij9 < numsolutions; ++ij9)
    {
if( !j9valid[ij9] )
{
    continue;
}
    j9 = j9array[ij9]; cj9 = cj9array[ij9]; sj9 = sj9array[ij9];
htj9 = IKtan(j9/2);

_ij9[0] = ij9; _ij9[1] = -1;
for(int iij9 = ij9+1; iij9 < numsolutions; ++iij9)
{
if( j9valid[iij9] && IKabs(cj9array[ij9]-cj9array[iij9]) < IKFAST_SOLUTION_THRESH && IKabs(sj9array[ij9]-sj9array[iij9]) < IKFAST_SOLUTION_THRESH )
{
    j9valid[iij9]=false; _ij9[1] = iij9; break; 
}
}
rotationfunction0(solutions);
    }

}

}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((IKabs(px))+(IKabs(((-3.14159265358979)+(IKfmod(((3.14159265358979)+j12), 6.28318530717959))))));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j9array[2], cj9array[2], sj9array[2];
bool j9valid[2]={false};
_nj9 = 2;
sj9array[0]=((8.54700854700855)*py);
if( sj9array[0] >= -1-IKFAST_SINCOS_THRESH && sj9array[0] <= 1+IKFAST_SINCOS_THRESH )
{
    j9valid[0] = j9valid[1] = true;
    j9array[0] = IKasin(sj9array[0]);
    cj9array[0] = IKcos(j9array[0]);
    sj9array[1] = sj9array[0];
    j9array[1] = j9array[0] > 0 ? (IKPI-j9array[0]) : (-IKPI-j9array[0]);
    cj9array[1] = -cj9array[0];
}
else if( isnan(sj9array[0]) )
{
    // probably any value will work
    j9valid[0] = true;
    cj9array[0] = 1; sj9array[0] = 0; j9array[0] = 0;
}
for(int ij9 = 0; ij9 < 2; ++ij9)
{
if( !j9valid[ij9] )
{
    continue;
}
_ij9[0] = ij9; _ij9[1] = -1;
for(int iij9 = ij9+1; iij9 < 2; ++iij9)
{
if( j9valid[iij9] && IKabs(cj9array[ij9]-cj9array[iij9]) < IKFAST_SOLUTION_THRESH && IKabs(sj9array[ij9]-sj9array[iij9]) < IKFAST_SOLUTION_THRESH )
{
    j9valid[iij9]=false; _ij9[1] = iij9; break; 
}
}
j9 = j9array[ij9]; cj9 = cj9array[ij9]; sj9 = sj9array[ij9];
{
IkReal evalcond[4];
IkReal x1090=IKcos(j9);
IkReal x1091=IKsin(j9);
IkReal x1092=(py*x1091);
evalcond[0]=((0.117)*x1090);
evalcond[1]=(py*x1090);
evalcond[2]=((-0.117)+x1092);
evalcond[3]=((-0.027378)+(((0.234)*x1092)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((IKabs(((-3.14159265358979)+(IKfmod(j12, 6.28318530717959)))))+(IKabs(px)));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j9array[2], cj9array[2], sj9array[2];
bool j9valid[2]={false};
_nj9 = 2;
sj9array[0]=((8.54700854700855)*py);
if( sj9array[0] >= -1-IKFAST_SINCOS_THRESH && sj9array[0] <= 1+IKFAST_SINCOS_THRESH )
{
    j9valid[0] = j9valid[1] = true;
    j9array[0] = IKasin(sj9array[0]);
    cj9array[0] = IKcos(j9array[0]);
    sj9array[1] = sj9array[0];
    j9array[1] = j9array[0] > 0 ? (IKPI-j9array[0]) : (-IKPI-j9array[0]);
    cj9array[1] = -cj9array[0];
}
else if( isnan(sj9array[0]) )
{
    // probably any value will work
    j9valid[0] = true;
    cj9array[0] = 1; sj9array[0] = 0; j9array[0] = 0;
}
for(int ij9 = 0; ij9 < 2; ++ij9)
{
if( !j9valid[ij9] )
{
    continue;
}
_ij9[0] = ij9; _ij9[1] = -1;
for(int iij9 = ij9+1; iij9 < 2; ++iij9)
{
if( j9valid[iij9] && IKabs(cj9array[ij9]-cj9array[iij9]) < IKFAST_SOLUTION_THRESH && IKabs(sj9array[ij9]-sj9array[iij9]) < IKFAST_SOLUTION_THRESH )
{
    j9valid[iij9]=false; _ij9[1] = iij9; break; 
}
}
j9 = j9array[ij9]; cj9 = cj9array[ij9]; sj9 = sj9array[ij9];
{
IkReal evalcond[4];
IkReal x1093=IKcos(j9);
IkReal x1094=IKsin(j9);
IkReal x1095=(py*x1094);
evalcond[0]=((0.117)*x1093);
evalcond[1]=(py*x1093);
evalcond[2]=((-0.117)+x1095);
evalcond[3]=((-0.027378)+(((0.234)*x1095)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
if( 1 )
{
bgotonextstatement=false;
continue; // branch miss [j9]

}
} while(0);
if( bgotonextstatement )
{
}
}
}
}
}

} else
{
{
IkReal j9array[1], cj9array[1], sj9array[1];
bool j9valid[1]={false};
_nj9 = 1;
IkReal x1096=(py*sj12);
CheckValue<IkReal> x1097=IKPowWithIntegerCheck(((((234000.0)*px))+(((643000.0)*x1096))),-1);
if(!x1097.valid){
continue;
}
CheckValue<IkReal> x1098=IKPowWithIntegerCheck(((((321500.0)*x1096))+(((117000.0)*px))),-1);
if(!x1098.valid){
continue;
}
if( IKabs(((x1097.value)*(((((2000000.0)*px*py))+(((75231.0)*sj12)))))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((x1098.value)*(((13689.0)+(((-1000000.0)*(py*py))))))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((x1097.value)*(((((2000000.0)*px*py))+(((75231.0)*sj12))))))+IKsqr(((x1098.value)*(((13689.0)+(((-1000000.0)*(py*py)))))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j9array[0]=IKatan2(((x1097.value)*(((((2000000.0)*px*py))+(((75231.0)*sj12))))), ((x1098.value)*(((13689.0)+(((-1000000.0)*(py*py)))))));
sj9array[0]=IKsin(j9array[0]);
cj9array[0]=IKcos(j9array[0]);
if( j9array[0] > IKPI )
{
    j9array[0]-=IK2PI;
}
else if( j9array[0] < -IKPI )
{    j9array[0]+=IK2PI;
}
j9valid[0] = true;
for(int ij9 = 0; ij9 < 1; ++ij9)
{
if( !j9valid[ij9] )
{
    continue;
}
_ij9[0] = ij9; _ij9[1] = -1;
for(int iij9 = ij9+1; iij9 < 1; ++iij9)
{
if( j9valid[iij9] && IKabs(cj9array[ij9]-cj9array[iij9]) < IKFAST_SOLUTION_THRESH && IKabs(sj9array[ij9]-sj9array[iij9]) < IKFAST_SOLUTION_THRESH )
{
    j9valid[iij9]=false; _ij9[1] = iij9; break; 
}
}
j9 = j9array[ij9]; cj9 = cj9array[ij9]; sj9 = sj9array[ij9];
{
IkReal evalcond[5];
IkReal x1099=IKcos(j9);
IkReal x1100=IKsin(j9);
IkReal x1101=((0.3215)*sj12);
IkReal x1102=((1.0)*px);
IkReal x1103=(py*x1100);
IkReal x1104=(px*x1099);
evalcond[0]=((-0.117)+x1104+x1103);
evalcond[1]=((-0.027378)+(((0.234)*x1104))+(((0.234)*x1103)));
evalcond[2]=((((0.117)*x1099))+((x1100*x1101))+(((-1.0)*x1102)));
evalcond[3]=((((-1.0)*py))+(((0.117)*x1100))+(((-1.0)*x1099*x1101)));
evalcond[4]=(x1101+(((-1.0)*x1100*x1102))+((py*x1099)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}

}

} else
{
{
IkReal j9array[1], cj9array[1], sj9array[1];
bool j9valid[1]={false};
_nj9 = 1;
IkReal x1105=(px*sj12);
CheckValue<IkReal> x1106=IKPowWithIntegerCheck(((((-117000.0)*py))+(((321500.0)*x1105))),-1);
if(!x1106.valid){
continue;
}
CheckValue<IkReal> x1107=IKPowWithIntegerCheck(((((643000.0)*x1105))+(((-234000.0)*py))),-1);
if(!x1107.valid){
continue;
}
if( IKabs(((x1106.value)*(((-13689.0)+(((1000000.0)*(px*px))))))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((x1107.value)*(((((-2000000.0)*px*py))+(((75231.0)*sj12)))))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((x1106.value)*(((-13689.0)+(((1000000.0)*(px*px)))))))+IKsqr(((x1107.value)*(((((-2000000.0)*px*py))+(((75231.0)*sj12))))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j9array[0]=IKatan2(((x1106.value)*(((-13689.0)+(((1000000.0)*(px*px)))))), ((x1107.value)*(((((-2000000.0)*px*py))+(((75231.0)*sj12))))));
sj9array[0]=IKsin(j9array[0]);
cj9array[0]=IKcos(j9array[0]);
if( j9array[0] > IKPI )
{
    j9array[0]-=IK2PI;
}
else if( j9array[0] < -IKPI )
{    j9array[0]+=IK2PI;
}
j9valid[0] = true;
for(int ij9 = 0; ij9 < 1; ++ij9)
{
if( !j9valid[ij9] )
{
    continue;
}
_ij9[0] = ij9; _ij9[1] = -1;
for(int iij9 = ij9+1; iij9 < 1; ++iij9)
{
if( j9valid[iij9] && IKabs(cj9array[ij9]-cj9array[iij9]) < IKFAST_SOLUTION_THRESH && IKabs(sj9array[ij9]-sj9array[iij9]) < IKFAST_SOLUTION_THRESH )
{
    j9valid[iij9]=false; _ij9[1] = iij9; break; 
}
}
j9 = j9array[ij9]; cj9 = cj9array[ij9]; sj9 = sj9array[ij9];
{
IkReal evalcond[5];
IkReal x1108=IKcos(j9);
IkReal x1109=IKsin(j9);
IkReal x1110=((0.3215)*sj12);
IkReal x1111=((1.0)*px);
IkReal x1112=(py*x1109);
IkReal x1113=(px*x1108);
evalcond[0]=((-0.117)+x1113+x1112);
evalcond[1]=((-0.027378)+(((0.234)*x1113))+(((0.234)*x1112)));
evalcond[2]=(((x1109*x1110))+(((0.117)*x1108))+(((-1.0)*x1111)));
evalcond[3]=((((-1.0)*py))+(((0.117)*x1109))+(((-1.0)*x1108*x1110)));
evalcond[4]=(x1110+(((-1.0)*x1109*x1111))+((py*x1108)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}

}

} else
{
{
IkReal j9array[1], cj9array[1], sj9array[1];
bool j9valid[1]={false};
_nj9 = 1;
IkReal x1114=((643.0)*sj12);
CheckValue<IkReal> x1115=IKPowWithIntegerCheck(IKsign(((((2000.0)*pp))+(((-2000.0)*(pz*pz))))),-1);
if(!x1115.valid){
continue;
}
CheckValue<IkReal> x1116 = IKatan2WithCheck(IkReal(((((234.0)*py))+((px*x1114)))),IkReal(((((-1.0)*py*x1114))+(((234.0)*px)))),IKFAST_ATAN2_MAGTHRESH);
if(!x1116.valid){
continue;
}
j9array[0]=((-1.5707963267949)+(((1.5707963267949)*(x1115.value)))+(x1116.value));
sj9array[0]=IKsin(j9array[0]);
cj9array[0]=IKcos(j9array[0]);
if( j9array[0] > IKPI )
{
    j9array[0]-=IK2PI;
}
else if( j9array[0] < -IKPI )
{    j9array[0]+=IK2PI;
}
j9valid[0] = true;
for(int ij9 = 0; ij9 < 1; ++ij9)
{
if( !j9valid[ij9] )
{
    continue;
}
_ij9[0] = ij9; _ij9[1] = -1;
for(int iij9 = ij9+1; iij9 < 1; ++iij9)
{
if( j9valid[iij9] && IKabs(cj9array[ij9]-cj9array[iij9]) < IKFAST_SOLUTION_THRESH && IKabs(sj9array[ij9]-sj9array[iij9]) < IKFAST_SOLUTION_THRESH )
{
    j9valid[iij9]=false; _ij9[1] = iij9; break; 
}
}
j9 = j9array[ij9]; cj9 = cj9array[ij9]; sj9 = sj9array[ij9];
{
IkReal evalcond[5];
IkReal x1117=IKcos(j9);
IkReal x1118=IKsin(j9);
IkReal x1119=((0.3215)*sj12);
IkReal x1120=((1.0)*px);
IkReal x1121=(py*x1118);
IkReal x1122=(px*x1117);
evalcond[0]=((-0.117)+x1121+x1122);
evalcond[1]=((-0.027378)+(((0.234)*x1122))+(((0.234)*x1121)));
evalcond[2]=((((0.117)*x1117))+(((-1.0)*x1120))+((x1118*x1119)));
evalcond[3]=((((-1.0)*py))+(((0.117)*x1118))+(((-1.0)*x1117*x1119)));
evalcond[4]=(x1119+((py*x1117))+(((-1.0)*x1118*x1120)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}

}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((IKabs(px))+(IKabs(py)));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j9eval[1];
IkReal x1123=((-1.0)*pz);
sj10=1.0;
cj10=0;
j10=1.5707963267949;
px=0;
py=0;
pp=pz*pz;
npx=(pz*r20);
npy=(pz*r21);
npz=(pz*r22);
rxp0_0=(pz*r10);
rxp0_1=(r00*x1123);
rxp0_2=0;
rxp1_0=(pz*r11);
rxp1_1=(r01*x1123);
rxp1_2=0;
rxp2_0=(pz*r12);
rxp2_1=(r02*x1123);
rxp2_2=0;
j9eval[0]=IKabs(((-1.0)+(((7.55075242895756)*(sj12*sj12)))));
if( IKabs(j9eval[0]) < 0.0000000100000000  )
{
continue; // no branches [j9]

} else
{
IkReal op[2+1], zeror[2];
int numroots;
IkReal x1124=((7.55075242895756)*(sj12*sj12));
op[0]=((-1.0)+x1124);
op[1]=0;
op[2]=((1.0)+(((-1.0)*x1124)));
polyroots2(op,zeror,numroots);
IkReal j9array[2], cj9array[2], sj9array[2], tempj9array[1];
int numsolutions = 0;
for(int ij9 = 0; ij9 < numroots; ++ij9)
{
IkReal htj9 = zeror[ij9];
tempj9array[0]=((2.0)*(atan(htj9)));
for(int kj9 = 0; kj9 < 1; ++kj9)
{
j9array[numsolutions] = tempj9array[kj9];
if( j9array[numsolutions] > IKPI )
{
    j9array[numsolutions]-=IK2PI;
}
else if( j9array[numsolutions] < -IKPI )
{
    j9array[numsolutions]+=IK2PI;
}
sj9array[numsolutions] = IKsin(j9array[numsolutions]);
cj9array[numsolutions] = IKcos(j9array[numsolutions]);
numsolutions++;
}
}
bool j9valid[2]={true,true};
_nj9 = 2;
for(int ij9 = 0; ij9 < numsolutions; ++ij9)
    {
if( !j9valid[ij9] )
{
    continue;
}
    j9 = j9array[ij9]; cj9 = cj9array[ij9]; sj9 = sj9array[ij9];
htj9 = IKtan(j9/2);

_ij9[0] = ij9; _ij9[1] = -1;
for(int iij9 = ij9+1; iij9 < numsolutions; ++iij9)
{
if( j9valid[iij9] && IKabs(cj9array[ij9]-cj9array[iij9]) < IKFAST_SOLUTION_THRESH && IKabs(sj9array[ij9]-sj9array[iij9]) < IKFAST_SOLUTION_THRESH )
{
    j9valid[iij9]=false; _ij9[1] = iij9; break; 
}
}
rotationfunction0(solutions);
    }

}

}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
if( 1 )
{
bgotonextstatement=false;
continue; // branch miss [j9]

}
} while(0);
if( bgotonextstatement )
{
}
}
}
}
}

} else
{
{
IkReal j9array[1], cj9array[1], sj9array[1];
bool j9valid[1]={false};
_nj9 = 1;
IkReal x1125=cj11*cj11;
IkReal x1126=cj12*cj12;
IkReal x1127=(sj11*sj12);
IkReal x1128=(cj11*sj12);
IkReal x1129=((24186.7665)*x1125);
IkReal x1130=((24186.7665)*cj11*sj11);
CheckValue<IkReal> x1131 = IKatan2WithCheck(IkReal(((-3203.226)+(((234000.0)*(px*px)))+(((17604.054)*x1128))+(((-1.0)*x1129))+((x1126*x1129)))),IkReal(((((-234000.0)*px*py))+x1130+(((-1.0)*x1126*x1130))+(((-8802.027)*x1127)))),IKFAST_ATAN2_MAGTHRESH);
if(!x1131.valid){
continue;
}
CheckValue<IkReal> x1132=IKPowWithIntegerCheck(IKsign(((((75231.0)*py*x1128))+(((-75231.0)*px*x1127))+(((-27378.0)*py)))),-1);
if(!x1132.valid){
continue;
}
j9array[0]=((-1.5707963267949)+(x1131.value)+(((1.5707963267949)*(x1132.value))));
sj9array[0]=IKsin(j9array[0]);
cj9array[0]=IKcos(j9array[0]);
if( j9array[0] > IKPI )
{
    j9array[0]-=IK2PI;
}
else if( j9array[0] < -IKPI )
{    j9array[0]+=IK2PI;
}
j9valid[0] = true;
for(int ij9 = 0; ij9 < 1; ++ij9)
{
if( !j9valid[ij9] )
{
    continue;
}
_ij9[0] = ij9; _ij9[1] = -1;
for(int iij9 = ij9+1; iij9 < 1; ++iij9)
{
if( j9valid[iij9] && IKabs(cj9array[ij9]-cj9array[iij9]) < IKFAST_SOLUTION_THRESH && IKabs(sj9array[ij9]-sj9array[iij9]) < IKFAST_SOLUTION_THRESH )
{
    j9valid[iij9]=false; _ij9[1] = iij9; break; 
}
}
j9 = j9array[ij9]; cj9 = cj9array[ij9]; sj9 = sj9array[ij9];
{
IkReal evalcond[5];
IkReal x1133=IKcos(j9);
IkReal x1134=IKsin(j9);
IkReal x1135=((1.0)*py);
IkReal x1136=((0.3215)*sj12);
IkReal x1137=(px*x1134);
IkReal x1138=(cj11*x1134);
IkReal x1139=(px*x1133);
IkReal x1140=(cj11*x1133);
IkReal x1141=(sj11*x1133);
IkReal x1142=(sj11*x1134);
evalcond[0]=((-0.027378)+(((0.234)*py*x1134))+(((0.234)*x1139))+(((0.075231)*cj11*sj12)));
evalcond[1]=((((-1.0)*x1136*x1140))+(((-1.0)*x1136*x1142))+(((0.117)*x1133))+(((-1.0)*px)));
evalcond[2]=((((0.117)*x1134))+(((-1.0)*x1135))+(((-1.0)*x1136*x1138))+((x1136*x1141)));
evalcond[3]=((((-1.0)*x1135*x1140))+(((-1.0)*x1135*x1142))+(((-1.0)*sj11*x1139))+((cj11*x1137))+(((0.117)*sj11)));
evalcond[4]=((((-1.0)*x1135*x1141))+x1136+((py*x1138))+(((-0.117)*cj11))+((cj11*x1139))+((sj11*x1137)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}

}

} else
{
{
IkReal j9array[1], cj9array[1], sj9array[1];
bool j9valid[1]={false};
_nj9 = 1;
IkReal x1143=cj11*cj11;
IkReal x1144=((117000.0)*cj11);
IkReal x1145=((13689.0)*cj11);
IkReal x1146=((37615.5)*cj11*sj11*sj12);
IkReal x1147=((37615.5)*sj12*x1143);
CheckValue<IkReal> x1148 = IKatan2WithCheck(IkReal((((py*x1147))+((px*x1146))+(((-1.0)*py*x1145)))),IkReal(((((-1.0)*px*x1145))+((px*x1147))+(((-1.0)*py*x1146)))),IKFAST_ATAN2_MAGTHRESH);
if(!x1148.valid){
continue;
}
CheckValue<IkReal> x1149=IKPowWithIntegerCheck(IKsign((((x1144*(pz*pz)))+(((-1.0)*pp*x1144)))),-1);
if(!x1149.valid){
continue;
}
j9array[0]=((-1.5707963267949)+(x1148.value)+(((1.5707963267949)*(x1149.value))));
sj9array[0]=IKsin(j9array[0]);
cj9array[0]=IKcos(j9array[0]);
if( j9array[0] > IKPI )
{
    j9array[0]-=IK2PI;
}
else if( j9array[0] < -IKPI )
{    j9array[0]+=IK2PI;
}
j9valid[0] = true;
for(int ij9 = 0; ij9 < 1; ++ij9)
{
if( !j9valid[ij9] )
{
    continue;
}
_ij9[0] = ij9; _ij9[1] = -1;
for(int iij9 = ij9+1; iij9 < 1; ++iij9)
{
if( j9valid[iij9] && IKabs(cj9array[ij9]-cj9array[iij9]) < IKFAST_SOLUTION_THRESH && IKabs(sj9array[ij9]-sj9array[iij9]) < IKFAST_SOLUTION_THRESH )
{
    j9valid[iij9]=false; _ij9[1] = iij9; break; 
}
}
j9 = j9array[ij9]; cj9 = cj9array[ij9]; sj9 = sj9array[ij9];
{
IkReal evalcond[5];
IkReal x1150=IKcos(j9);
IkReal x1151=IKsin(j9);
IkReal x1152=((1.0)*py);
IkReal x1153=((0.3215)*sj12);
IkReal x1154=(px*x1151);
IkReal x1155=(cj11*x1151);
IkReal x1156=(px*x1150);
IkReal x1157=(cj11*x1150);
IkReal x1158=(sj11*x1150);
IkReal x1159=(sj11*x1151);
evalcond[0]=((-0.027378)+(((0.234)*py*x1151))+(((0.234)*x1156))+(((0.075231)*cj11*sj12)));
evalcond[1]=((((0.117)*x1150))+(((-1.0)*px))+(((-1.0)*x1153*x1157))+(((-1.0)*x1153*x1159)));
evalcond[2]=((((-1.0)*x1152))+(((0.117)*x1151))+((x1153*x1158))+(((-1.0)*x1153*x1155)));
evalcond[3]=((((-1.0)*sj11*x1156))+(((-1.0)*x1152*x1159))+(((-1.0)*x1152*x1157))+((cj11*x1154))+(((0.117)*sj11)));
evalcond[4]=(x1153+(((-0.117)*cj11))+(((-1.0)*x1152*x1158))+((cj11*x1156))+((sj11*x1154))+((py*x1155)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}

}

} else
{
{
IkReal j9array[1], cj9array[1], sj9array[1];
bool j9valid[1]={false};
_nj9 = 1;
IkReal x1160=((1286000.0)*sj12);
CheckValue<IkReal> x1161=IKPowWithIntegerCheck(IKsign(((468205.0)+(((-300924.0)*cj11*sj12))+(((-413449.0)*(cj12*cj12))))),-1);
if(!x1161.valid){
continue;
}
CheckValue<IkReal> x1162 = IKatan2WithCheck(IkReal(((((-1.0)*cj11*py*x1160))+(((-1.0)*px*sj11*x1160))+(((468000.0)*py)))),IkReal(((((-1.0)*cj11*px*x1160))+((py*sj11*x1160))+(((468000.0)*px)))),IKFAST_ATAN2_MAGTHRESH);
if(!x1162.valid){
continue;
}
j9array[0]=((-1.5707963267949)+(((1.5707963267949)*(x1161.value)))+(x1162.value));
sj9array[0]=IKsin(j9array[0]);
cj9array[0]=IKcos(j9array[0]);
if( j9array[0] > IKPI )
{
    j9array[0]-=IK2PI;
}
else if( j9array[0] < -IKPI )
{    j9array[0]+=IK2PI;
}
j9valid[0] = true;
for(int ij9 = 0; ij9 < 1; ++ij9)
{
if( !j9valid[ij9] )
{
    continue;
}
_ij9[0] = ij9; _ij9[1] = -1;
for(int iij9 = ij9+1; iij9 < 1; ++iij9)
{
if( j9valid[iij9] && IKabs(cj9array[ij9]-cj9array[iij9]) < IKFAST_SOLUTION_THRESH && IKabs(sj9array[ij9]-sj9array[iij9]) < IKFAST_SOLUTION_THRESH )
{
    j9valid[iij9]=false; _ij9[1] = iij9; break; 
}
}
j9 = j9array[ij9]; cj9 = cj9array[ij9]; sj9 = sj9array[ij9];
{
IkReal evalcond[5];
IkReal x1163=IKcos(j9);
IkReal x1164=IKsin(j9);
IkReal x1165=((1.0)*py);
IkReal x1166=((0.3215)*sj12);
IkReal x1167=(px*x1164);
IkReal x1168=(cj11*x1164);
IkReal x1169=(px*x1163);
IkReal x1170=(cj11*x1163);
IkReal x1171=(sj11*x1163);
IkReal x1172=(sj11*x1164);
evalcond[0]=((-0.027378)+(((0.234)*x1169))+(((0.234)*py*x1164))+(((0.075231)*cj11*sj12)));
evalcond[1]=((((-1.0)*px))+(((0.117)*x1163))+(((-1.0)*x1166*x1172))+(((-1.0)*x1166*x1170)));
evalcond[2]=((((-1.0)*x1166*x1168))+((x1166*x1171))+(((0.117)*x1164))+(((-1.0)*x1165)));
evalcond[3]=((((-1.0)*x1165*x1172))+(((-1.0)*x1165*x1170))+((cj11*x1167))+(((-1.0)*sj11*x1169))+(((0.117)*sj11)));
evalcond[4]=((((-1.0)*x1165*x1171))+x1166+((sj11*x1167))+((cj11*x1169))+(((-0.117)*cj11))+((py*x1168)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}

}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((1.5707963267949)+j10)))), 6.28318530717959)));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j9eval[3];
sj10=-1.0;
cj10=0;
j10=-1.5707963267949;
IkReal x1173=cj12*cj12;
IkReal x1174=(cj11*sj12);
IkReal x1175=((1286000.0)*py);
IkReal x1176=(sj11*sj12);
IkReal x1177=((1286000.0)*px);
j9eval[0]=((1.55589118847284)+x1174+(((-1.37393162393162)*x1173)));
j9eval[1]=IKsign(((468205.0)+(((300924.0)*x1174))+(((-413449.0)*x1173))));
j9eval[2]=((IKabs((((x1174*x1175))+(((-1.0)*x1176*x1177))+(((468000.0)*py)))))+(IKabs((((x1174*x1177))+((x1175*x1176))+(((468000.0)*px))))));
if( IKabs(j9eval[0]) < 0.0000010000000000  || IKabs(j9eval[1]) < 0.0000010000000000  || IKabs(j9eval[2]) < 0.0000010000000000  )
{
{
IkReal j9eval[3];
sj10=-1.0;
cj10=0;
j10=-1.5707963267949;
IkReal x1178=pz*pz;
IkReal x1179=cj11*cj11;
IkReal x1180=(cj11*pp);
IkReal x1181=(cj11*sj11);
IkReal x1182=((234.0)*cj11);
IkReal x1183=((643.0)*py*sj12);
IkReal x1184=(cj11*x1178);
IkReal x1185=((643.0)*px*sj12);
j9eval[0]=(x1180+(((-1.0)*x1184)));
j9eval[1]=IKsign(((((-117000.0)*x1184))+(((117000.0)*x1180))));
j9eval[2]=((IKabs((((x1179*x1185))+((px*x1182))+((x1181*x1183)))))+(IKabs(((((-1.0)*x1181*x1185))+((x1179*x1183))+((py*x1182))))));
if( IKabs(j9eval[0]) < 0.0000010000000000  || IKabs(j9eval[1]) < 0.0000010000000000  || IKabs(j9eval[2]) < 0.0000010000000000  )
{
{
IkReal j9eval[3];
sj10=-1.0;
cj10=0;
j10=-1.5707963267949;
IkReal x1186=cj11*cj11;
IkReal x1187=cj12*cj12;
IkReal x1188=(sj11*sj12);
IkReal x1189=((24186.7665)*x1186);
IkReal x1190=(cj11*py*sj12);
IkReal x1191=((24186.7665)*cj11*sj11);
j9eval[0]=((((-2.74786324786325)*x1190))+(((-1.0)*py))+(((-2.74786324786325)*px*x1188)));
j9eval[1]=((IKabs(((((-234000.0)*px*py))+((x1187*x1191))+(((-1.0)*x1191))+(((-8802.027)*x1188)))))+(IKabs(((-3203.226)+((x1187*x1189))+(((-17604.054)*cj11*sj12))+(((234000.0)*(px*px)))+(((-1.0)*x1189))))));
j9eval[2]=IKsign(((((-75231.0)*x1190))+(((-75231.0)*px*x1188))+(((-27378.0)*py))));
if( IKabs(j9eval[0]) < 0.0000010000000000  || IKabs(j9eval[1]) < 0.0000010000000000  || IKabs(j9eval[2]) < 0.0000010000000000  )
{
{
IkReal evalcond[1];
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((-1.5707963267949)+j11)))), 6.28318530717959)));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j9eval[3];
sj10=-1.0;
cj10=0;
j10=-1.5707963267949;
sj11=1.0;
cj11=0;
j11=1.5707963267949;
IkReal x1192=pz*pz;
IkReal x1193=((643.0)*sj12);
j9eval[0]=(pp+(((-1.0)*x1192)));
j9eval[1]=IKsign(((((-2000.0)*x1192))+(((2000.0)*pp))));
j9eval[2]=((IKabs((((py*x1193))+(((234.0)*px)))))+(IKabs(((((234.0)*py))+(((-1.0)*px*x1193))))));
if( IKabs(j9eval[0]) < 0.0000010000000000  || IKabs(j9eval[1]) < 0.0000010000000000  || IKabs(j9eval[2]) < 0.0000010000000000  )
{
{
IkReal j9eval[1];
sj10=-1.0;
cj10=0;
j10=-1.5707963267949;
sj11=1.0;
cj11=0;
j11=1.5707963267949;
j9eval[0]=((((2.74786324786325)*px*sj12))+py);
if( IKabs(j9eval[0]) < 0.0000010000000000  )
{
{
IkReal j9eval[1];
sj10=-1.0;
cj10=0;
j10=-1.5707963267949;
sj11=1.0;
cj11=0;
j11=1.5707963267949;
j9eval[0]=((((-2.74786324786325)*py*sj12))+px);
if( IKabs(j9eval[0]) < 0.0000010000000000  )
{
{
IkReal evalcond[1];
bool bgotonextstatement = true;
do
{
evalcond[0]=((IKabs(px))+(IKabs(py)));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j9eval[1];
IkReal x1194=((-1.0)*pz);
sj10=-1.0;
cj10=0;
j10=-1.5707963267949;
sj11=1.0;
cj11=0;
j11=1.5707963267949;
px=0;
py=0;
pp=pz*pz;
npx=(pz*r20);
npy=(pz*r21);
npz=(pz*r22);
rxp0_0=(pz*r10);
rxp0_1=(r00*x1194);
rxp0_2=0;
rxp1_0=(pz*r11);
rxp1_1=(r01*x1194);
rxp1_2=0;
rxp2_0=(pz*r12);
rxp2_1=(r02*x1194);
rxp2_2=0;
j9eval[0]=1.0;
if( IKabs(j9eval[0]) < 0.0000000100000000  )
{
continue; // 3 cases reached

} else
{
IkReal op[2+1], zeror[2];
int numroots;
op[0]=-1.0;
op[1]=0;
op[2]=1.0;
polyroots2(op,zeror,numroots);
IkReal j9array[2], cj9array[2], sj9array[2], tempj9array[1];
int numsolutions = 0;
for(int ij9 = 0; ij9 < numroots; ++ij9)
{
IkReal htj9 = zeror[ij9];
tempj9array[0]=((2.0)*(atan(htj9)));
for(int kj9 = 0; kj9 < 1; ++kj9)
{
j9array[numsolutions] = tempj9array[kj9];
if( j9array[numsolutions] > IKPI )
{
    j9array[numsolutions]-=IK2PI;
}
else if( j9array[numsolutions] < -IKPI )
{
    j9array[numsolutions]+=IK2PI;
}
sj9array[numsolutions] = IKsin(j9array[numsolutions]);
cj9array[numsolutions] = IKcos(j9array[numsolutions]);
numsolutions++;
}
}
bool j9valid[2]={true,true};
_nj9 = 2;
for(int ij9 = 0; ij9 < numsolutions; ++ij9)
    {
if( !j9valid[ij9] )
{
    continue;
}
    j9 = j9array[ij9]; cj9 = cj9array[ij9]; sj9 = sj9array[ij9];
htj9 = IKtan(j9/2);

_ij9[0] = ij9; _ij9[1] = -1;
for(int iij9 = ij9+1; iij9 < numsolutions; ++iij9)
{
if( j9valid[iij9] && IKabs(cj9array[ij9]-cj9array[iij9]) < IKFAST_SOLUTION_THRESH && IKabs(sj9array[ij9]-sj9array[iij9]) < IKFAST_SOLUTION_THRESH )
{
    j9valid[iij9]=false; _ij9[1] = iij9; break; 
}
}
rotationfunction0(solutions);
    }

}

}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((IKabs(px))+(IKabs(((-3.14159265358979)+(IKfmod(((3.14159265358979)+j12), 6.28318530717959))))));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j9array[2], cj9array[2], sj9array[2];
bool j9valid[2]={false};
_nj9 = 2;
sj9array[0]=((8.54700854700855)*py);
if( sj9array[0] >= -1-IKFAST_SINCOS_THRESH && sj9array[0] <= 1+IKFAST_SINCOS_THRESH )
{
    j9valid[0] = j9valid[1] = true;
    j9array[0] = IKasin(sj9array[0]);
    cj9array[0] = IKcos(j9array[0]);
    sj9array[1] = sj9array[0];
    j9array[1] = j9array[0] > 0 ? (IKPI-j9array[0]) : (-IKPI-j9array[0]);
    cj9array[1] = -cj9array[0];
}
else if( isnan(sj9array[0]) )
{
    // probably any value will work
    j9valid[0] = true;
    cj9array[0] = 1; sj9array[0] = 0; j9array[0] = 0;
}
for(int ij9 = 0; ij9 < 2; ++ij9)
{
if( !j9valid[ij9] )
{
    continue;
}
_ij9[0] = ij9; _ij9[1] = -1;
for(int iij9 = ij9+1; iij9 < 2; ++iij9)
{
if( j9valid[iij9] && IKabs(cj9array[ij9]-cj9array[iij9]) < IKFAST_SOLUTION_THRESH && IKabs(sj9array[ij9]-sj9array[iij9]) < IKFAST_SOLUTION_THRESH )
{
    j9valid[iij9]=false; _ij9[1] = iij9; break; 
}
}
j9 = j9array[ij9]; cj9 = cj9array[ij9]; sj9 = sj9array[ij9];
{
IkReal evalcond[4];
IkReal x1195=IKcos(j9);
IkReal x1196=IKsin(j9);
IkReal x1197=(py*x1196);
evalcond[0]=((0.117)*x1195);
evalcond[1]=((-1.0)*py*x1195);
evalcond[2]=((-0.117)+x1197);
evalcond[3]=((-0.027378)+(((0.234)*x1197)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((IKabs(((-3.14159265358979)+(IKfmod(j12, 6.28318530717959)))))+(IKabs(px)));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j9array[2], cj9array[2], sj9array[2];
bool j9valid[2]={false};
_nj9 = 2;
sj9array[0]=((8.54700854700855)*py);
if( sj9array[0] >= -1-IKFAST_SINCOS_THRESH && sj9array[0] <= 1+IKFAST_SINCOS_THRESH )
{
    j9valid[0] = j9valid[1] = true;
    j9array[0] = IKasin(sj9array[0]);
    cj9array[0] = IKcos(j9array[0]);
    sj9array[1] = sj9array[0];
    j9array[1] = j9array[0] > 0 ? (IKPI-j9array[0]) : (-IKPI-j9array[0]);
    cj9array[1] = -cj9array[0];
}
else if( isnan(sj9array[0]) )
{
    // probably any value will work
    j9valid[0] = true;
    cj9array[0] = 1; sj9array[0] = 0; j9array[0] = 0;
}
for(int ij9 = 0; ij9 < 2; ++ij9)
{
if( !j9valid[ij9] )
{
    continue;
}
_ij9[0] = ij9; _ij9[1] = -1;
for(int iij9 = ij9+1; iij9 < 2; ++iij9)
{
if( j9valid[iij9] && IKabs(cj9array[ij9]-cj9array[iij9]) < IKFAST_SOLUTION_THRESH && IKabs(sj9array[ij9]-sj9array[iij9]) < IKFAST_SOLUTION_THRESH )
{
    j9valid[iij9]=false; _ij9[1] = iij9; break; 
}
}
j9 = j9array[ij9]; cj9 = cj9array[ij9]; sj9 = sj9array[ij9];
{
IkReal evalcond[4];
IkReal x1198=IKcos(j9);
IkReal x1199=IKsin(j9);
IkReal x1200=(py*x1199);
evalcond[0]=((0.117)*x1198);
evalcond[1]=((-1.0)*py*x1198);
evalcond[2]=((-0.117)+x1200);
evalcond[3]=((-0.027378)+(((0.234)*x1200)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
if( 1 )
{
bgotonextstatement=false;
continue; // branch miss [j9]

}
} while(0);
if( bgotonextstatement )
{
}
}
}
}
}

} else
{
{
IkReal j9array[1], cj9array[1], sj9array[1];
bool j9valid[1]={false};
_nj9 = 1;
IkReal x1201=(py*sj12);
CheckValue<IkReal> x1202=IKPowWithIntegerCheck(((((234000.0)*px))+(((-643000.0)*x1201))),-1);
if(!x1202.valid){
continue;
}
CheckValue<IkReal> x1203=IKPowWithIntegerCheck(((((-321500.0)*x1201))+(((117000.0)*px))),-1);
if(!x1203.valid){
continue;
}
if( IKabs(((x1202.value)*(((((-75231.0)*sj12))+(((2000000.0)*px*py)))))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((x1203.value)*(((13689.0)+(((-1000000.0)*(py*py))))))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((x1202.value)*(((((-75231.0)*sj12))+(((2000000.0)*px*py))))))+IKsqr(((x1203.value)*(((13689.0)+(((-1000000.0)*(py*py)))))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j9array[0]=IKatan2(((x1202.value)*(((((-75231.0)*sj12))+(((2000000.0)*px*py))))), ((x1203.value)*(((13689.0)+(((-1000000.0)*(py*py)))))));
sj9array[0]=IKsin(j9array[0]);
cj9array[0]=IKcos(j9array[0]);
if( j9array[0] > IKPI )
{
    j9array[0]-=IK2PI;
}
else if( j9array[0] < -IKPI )
{    j9array[0]+=IK2PI;
}
j9valid[0] = true;
for(int ij9 = 0; ij9 < 1; ++ij9)
{
if( !j9valid[ij9] )
{
    continue;
}
_ij9[0] = ij9; _ij9[1] = -1;
for(int iij9 = ij9+1; iij9 < 1; ++iij9)
{
if( j9valid[iij9] && IKabs(cj9array[ij9]-cj9array[iij9]) < IKFAST_SOLUTION_THRESH && IKabs(sj9array[ij9]-sj9array[iij9]) < IKFAST_SOLUTION_THRESH )
{
    j9valid[iij9]=false; _ij9[1] = iij9; break; 
}
}
j9 = j9array[ij9]; cj9 = cj9array[ij9]; sj9 = sj9array[ij9];
{
IkReal evalcond[5];
IkReal x1204=IKcos(j9);
IkReal x1205=IKsin(j9);
IkReal x1206=((0.3215)*sj12);
IkReal x1207=((1.0)*py);
IkReal x1208=(py*x1205);
IkReal x1209=(px*x1204);
evalcond[0]=((-0.117)+x1209+x1208);
evalcond[1]=((-0.027378)+(((0.234)*x1209))+(((0.234)*x1208)));
evalcond[2]=((((0.117)*x1204))+(((-1.0)*px))+(((-1.0)*x1205*x1206)));
evalcond[3]=(((x1204*x1206))+(((0.117)*x1205))+(((-1.0)*x1207)));
evalcond[4]=((((-1.0)*x1204*x1207))+x1206+((px*x1205)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}

}

} else
{
{
IkReal j9array[1], cj9array[1], sj9array[1];
bool j9valid[1]={false};
_nj9 = 1;
IkReal x1210=(px*sj12);
CheckValue<IkReal> x1211=IKPowWithIntegerCheck(((((321500.0)*x1210))+(((117000.0)*py))),-1);
if(!x1211.valid){
continue;
}
CheckValue<IkReal> x1212=IKPowWithIntegerCheck(((((643000.0)*x1210))+(((234000.0)*py))),-1);
if(!x1212.valid){
continue;
}
if( IKabs(((x1211.value)*(((13689.0)+(((-1000000.0)*(px*px))))))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((x1212.value)*(((((2000000.0)*px*py))+(((75231.0)*sj12)))))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((x1211.value)*(((13689.0)+(((-1000000.0)*(px*px)))))))+IKsqr(((x1212.value)*(((((2000000.0)*px*py))+(((75231.0)*sj12))))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j9array[0]=IKatan2(((x1211.value)*(((13689.0)+(((-1000000.0)*(px*px)))))), ((x1212.value)*(((((2000000.0)*px*py))+(((75231.0)*sj12))))));
sj9array[0]=IKsin(j9array[0]);
cj9array[0]=IKcos(j9array[0]);
if( j9array[0] > IKPI )
{
    j9array[0]-=IK2PI;
}
else if( j9array[0] < -IKPI )
{    j9array[0]+=IK2PI;
}
j9valid[0] = true;
for(int ij9 = 0; ij9 < 1; ++ij9)
{
if( !j9valid[ij9] )
{
    continue;
}
_ij9[0] = ij9; _ij9[1] = -1;
for(int iij9 = ij9+1; iij9 < 1; ++iij9)
{
if( j9valid[iij9] && IKabs(cj9array[ij9]-cj9array[iij9]) < IKFAST_SOLUTION_THRESH && IKabs(sj9array[ij9]-sj9array[iij9]) < IKFAST_SOLUTION_THRESH )
{
    j9valid[iij9]=false; _ij9[1] = iij9; break; 
}
}
j9 = j9array[ij9]; cj9 = cj9array[ij9]; sj9 = sj9array[ij9];
{
IkReal evalcond[5];
IkReal x1213=IKcos(j9);
IkReal x1214=IKsin(j9);
IkReal x1215=((0.3215)*sj12);
IkReal x1216=((1.0)*py);
IkReal x1217=(py*x1214);
IkReal x1218=(px*x1213);
evalcond[0]=((-0.117)+x1217+x1218);
evalcond[1]=((-0.027378)+(((0.234)*x1218))+(((0.234)*x1217)));
evalcond[2]=((((-1.0)*x1214*x1215))+(((0.117)*x1213))+(((-1.0)*px)));
evalcond[3]=(((x1213*x1215))+(((0.117)*x1214))+(((-1.0)*x1216)));
evalcond[4]=(x1215+((px*x1214))+(((-1.0)*x1213*x1216)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}

}

} else
{
{
IkReal j9array[1], cj9array[1], sj9array[1];
bool j9valid[1]={false};
_nj9 = 1;
IkReal x1219=((643.0)*sj12);
CheckValue<IkReal> x1220=IKPowWithIntegerCheck(IKsign(((((2000.0)*pp))+(((-2000.0)*(pz*pz))))),-1);
if(!x1220.valid){
continue;
}
CheckValue<IkReal> x1221 = IKatan2WithCheck(IkReal(((((-1.0)*px*x1219))+(((234.0)*py)))),IkReal(((((234.0)*px))+((py*x1219)))),IKFAST_ATAN2_MAGTHRESH);
if(!x1221.valid){
continue;
}
j9array[0]=((-1.5707963267949)+(((1.5707963267949)*(x1220.value)))+(x1221.value));
sj9array[0]=IKsin(j9array[0]);
cj9array[0]=IKcos(j9array[0]);
if( j9array[0] > IKPI )
{
    j9array[0]-=IK2PI;
}
else if( j9array[0] < -IKPI )
{    j9array[0]+=IK2PI;
}
j9valid[0] = true;
for(int ij9 = 0; ij9 < 1; ++ij9)
{
if( !j9valid[ij9] )
{
    continue;
}
_ij9[0] = ij9; _ij9[1] = -1;
for(int iij9 = ij9+1; iij9 < 1; ++iij9)
{
if( j9valid[iij9] && IKabs(cj9array[ij9]-cj9array[iij9]) < IKFAST_SOLUTION_THRESH && IKabs(sj9array[ij9]-sj9array[iij9]) < IKFAST_SOLUTION_THRESH )
{
    j9valid[iij9]=false; _ij9[1] = iij9; break; 
}
}
j9 = j9array[ij9]; cj9 = cj9array[ij9]; sj9 = sj9array[ij9];
{
IkReal evalcond[5];
IkReal x1222=IKcos(j9);
IkReal x1223=IKsin(j9);
IkReal x1224=((0.3215)*sj12);
IkReal x1225=((1.0)*py);
IkReal x1226=(py*x1223);
IkReal x1227=(px*x1222);
evalcond[0]=((-0.117)+x1227+x1226);
evalcond[1]=((-0.027378)+(((0.234)*x1227))+(((0.234)*x1226)));
evalcond[2]=((((-1.0)*px))+(((0.117)*x1222))+(((-1.0)*x1223*x1224)));
evalcond[3]=((((-1.0)*x1225))+((x1222*x1224))+(((0.117)*x1223)));
evalcond[4]=(x1224+(((-1.0)*x1222*x1225))+((px*x1223)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}

}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((1.5707963267949)+j11)))), 6.28318530717959)));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j9eval[3];
sj10=-1.0;
cj10=0;
j10=-1.5707963267949;
sj11=-1.0;
cj11=0;
j11=-1.5707963267949;
IkReal x1228=pz*pz;
IkReal x1229=((643.0)*sj12);
j9eval[0]=((((-1.0)*x1228))+pp);
j9eval[1]=IKsign(((((2000.0)*pp))+(((-2000.0)*x1228))));
j9eval[2]=((IKabs(((((234.0)*py))+((px*x1229)))))+(IKabs(((((-1.0)*py*x1229))+(((234.0)*px))))));
if( IKabs(j9eval[0]) < 0.0000010000000000  || IKabs(j9eval[1]) < 0.0000010000000000  || IKabs(j9eval[2]) < 0.0000010000000000  )
{
{
IkReal j9eval[1];
sj10=-1.0;
cj10=0;
j10=-1.5707963267949;
sj11=-1.0;
cj11=0;
j11=-1.5707963267949;
j9eval[0]=((((-1.0)*py))+(((2.74786324786325)*px*sj12)));
if( IKabs(j9eval[0]) < 0.0000010000000000  )
{
{
IkReal j9eval[1];
sj10=-1.0;
cj10=0;
j10=-1.5707963267949;
sj11=-1.0;
cj11=0;
j11=-1.5707963267949;
j9eval[0]=((((2.74786324786325)*py*sj12))+px);
if( IKabs(j9eval[0]) < 0.0000010000000000  )
{
{
IkReal evalcond[1];
bool bgotonextstatement = true;
do
{
evalcond[0]=((IKabs(px))+(IKabs(py)));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j9eval[1];
IkReal x1230=((-1.0)*pz);
sj10=-1.0;
cj10=0;
j10=-1.5707963267949;
sj11=-1.0;
cj11=0;
j11=-1.5707963267949;
px=0;
py=0;
pp=pz*pz;
npx=(pz*r20);
npy=(pz*r21);
npz=(pz*r22);
rxp0_0=(pz*r10);
rxp0_1=(r00*x1230);
rxp0_2=0;
rxp1_0=(pz*r11);
rxp1_1=(r01*x1230);
rxp1_2=0;
rxp2_0=(pz*r12);
rxp2_1=(r02*x1230);
rxp2_2=0;
j9eval[0]=1.0;
if( IKabs(j9eval[0]) < 0.0000000100000000  )
{
continue; // 3 cases reached

} else
{
IkReal op[2+1], zeror[2];
int numroots;
op[0]=-1.0;
op[1]=0;
op[2]=1.0;
polyroots2(op,zeror,numroots);
IkReal j9array[2], cj9array[2], sj9array[2], tempj9array[1];
int numsolutions = 0;
for(int ij9 = 0; ij9 < numroots; ++ij9)
{
IkReal htj9 = zeror[ij9];
tempj9array[0]=((2.0)*(atan(htj9)));
for(int kj9 = 0; kj9 < 1; ++kj9)
{
j9array[numsolutions] = tempj9array[kj9];
if( j9array[numsolutions] > IKPI )
{
    j9array[numsolutions]-=IK2PI;
}
else if( j9array[numsolutions] < -IKPI )
{
    j9array[numsolutions]+=IK2PI;
}
sj9array[numsolutions] = IKsin(j9array[numsolutions]);
cj9array[numsolutions] = IKcos(j9array[numsolutions]);
numsolutions++;
}
}
bool j9valid[2]={true,true};
_nj9 = 2;
for(int ij9 = 0; ij9 < numsolutions; ++ij9)
    {
if( !j9valid[ij9] )
{
    continue;
}
    j9 = j9array[ij9]; cj9 = cj9array[ij9]; sj9 = sj9array[ij9];
htj9 = IKtan(j9/2);

_ij9[0] = ij9; _ij9[1] = -1;
for(int iij9 = ij9+1; iij9 < numsolutions; ++iij9)
{
if( j9valid[iij9] && IKabs(cj9array[ij9]-cj9array[iij9]) < IKFAST_SOLUTION_THRESH && IKabs(sj9array[ij9]-sj9array[iij9]) < IKFAST_SOLUTION_THRESH )
{
    j9valid[iij9]=false; _ij9[1] = iij9; break; 
}
}
rotationfunction0(solutions);
    }

}

}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((IKabs(px))+(IKabs(((-3.14159265358979)+(IKfmod(((3.14159265358979)+j12), 6.28318530717959))))));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j9array[2], cj9array[2], sj9array[2];
bool j9valid[2]={false};
_nj9 = 2;
sj9array[0]=((8.54700854700855)*py);
if( sj9array[0] >= -1-IKFAST_SINCOS_THRESH && sj9array[0] <= 1+IKFAST_SINCOS_THRESH )
{
    j9valid[0] = j9valid[1] = true;
    j9array[0] = IKasin(sj9array[0]);
    cj9array[0] = IKcos(j9array[0]);
    sj9array[1] = sj9array[0];
    j9array[1] = j9array[0] > 0 ? (IKPI-j9array[0]) : (-IKPI-j9array[0]);
    cj9array[1] = -cj9array[0];
}
else if( isnan(sj9array[0]) )
{
    // probably any value will work
    j9valid[0] = true;
    cj9array[0] = 1; sj9array[0] = 0; j9array[0] = 0;
}
for(int ij9 = 0; ij9 < 2; ++ij9)
{
if( !j9valid[ij9] )
{
    continue;
}
_ij9[0] = ij9; _ij9[1] = -1;
for(int iij9 = ij9+1; iij9 < 2; ++iij9)
{
if( j9valid[iij9] && IKabs(cj9array[ij9]-cj9array[iij9]) < IKFAST_SOLUTION_THRESH && IKabs(sj9array[ij9]-sj9array[iij9]) < IKFAST_SOLUTION_THRESH )
{
    j9valid[iij9]=false; _ij9[1] = iij9; break; 
}
}
j9 = j9array[ij9]; cj9 = cj9array[ij9]; sj9 = sj9array[ij9];
{
IkReal evalcond[4];
IkReal x1231=IKcos(j9);
IkReal x1232=IKsin(j9);
IkReal x1233=(py*x1232);
evalcond[0]=((0.117)*x1231);
evalcond[1]=(py*x1231);
evalcond[2]=((-0.027378)+(((0.234)*x1233)));
evalcond[3]=((0.117)+(((-1.0)*x1233)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((IKabs(((-3.14159265358979)+(IKfmod(j12, 6.28318530717959)))))+(IKabs(px)));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j9array[2], cj9array[2], sj9array[2];
bool j9valid[2]={false};
_nj9 = 2;
sj9array[0]=((8.54700854700855)*py);
if( sj9array[0] >= -1-IKFAST_SINCOS_THRESH && sj9array[0] <= 1+IKFAST_SINCOS_THRESH )
{
    j9valid[0] = j9valid[1] = true;
    j9array[0] = IKasin(sj9array[0]);
    cj9array[0] = IKcos(j9array[0]);
    sj9array[1] = sj9array[0];
    j9array[1] = j9array[0] > 0 ? (IKPI-j9array[0]) : (-IKPI-j9array[0]);
    cj9array[1] = -cj9array[0];
}
else if( isnan(sj9array[0]) )
{
    // probably any value will work
    j9valid[0] = true;
    cj9array[0] = 1; sj9array[0] = 0; j9array[0] = 0;
}
for(int ij9 = 0; ij9 < 2; ++ij9)
{
if( !j9valid[ij9] )
{
    continue;
}
_ij9[0] = ij9; _ij9[1] = -1;
for(int iij9 = ij9+1; iij9 < 2; ++iij9)
{
if( j9valid[iij9] && IKabs(cj9array[ij9]-cj9array[iij9]) < IKFAST_SOLUTION_THRESH && IKabs(sj9array[ij9]-sj9array[iij9]) < IKFAST_SOLUTION_THRESH )
{
    j9valid[iij9]=false; _ij9[1] = iij9; break; 
}
}
j9 = j9array[ij9]; cj9 = cj9array[ij9]; sj9 = sj9array[ij9];
{
IkReal evalcond[4];
IkReal x1234=IKcos(j9);
IkReal x1235=IKsin(j9);
IkReal x1236=(py*x1235);
evalcond[0]=((0.117)*x1234);
evalcond[1]=(py*x1234);
evalcond[2]=((-0.027378)+(((0.234)*x1236)));
evalcond[3]=((0.117)+(((-1.0)*x1236)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
if( 1 )
{
bgotonextstatement=false;
continue; // branch miss [j9]

}
} while(0);
if( bgotonextstatement )
{
}
}
}
}
}

} else
{
{
IkReal j9array[1], cj9array[1], sj9array[1];
bool j9valid[1]={false};
_nj9 = 1;
IkReal x1237=(py*sj12);
CheckValue<IkReal> x1238=IKPowWithIntegerCheck(((((643000.0)*x1237))+(((234000.0)*px))),-1);
if(!x1238.valid){
continue;
}
CheckValue<IkReal> x1239=IKPowWithIntegerCheck(((((321500.0)*x1237))+(((117000.0)*px))),-1);
if(!x1239.valid){
continue;
}
if( IKabs(((x1238.value)*(((((2000000.0)*px*py))+(((75231.0)*sj12)))))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((x1239.value)*(((13689.0)+(((-1000000.0)*(py*py))))))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((x1238.value)*(((((2000000.0)*px*py))+(((75231.0)*sj12))))))+IKsqr(((x1239.value)*(((13689.0)+(((-1000000.0)*(py*py)))))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j9array[0]=IKatan2(((x1238.value)*(((((2000000.0)*px*py))+(((75231.0)*sj12))))), ((x1239.value)*(((13689.0)+(((-1000000.0)*(py*py)))))));
sj9array[0]=IKsin(j9array[0]);
cj9array[0]=IKcos(j9array[0]);
if( j9array[0] > IKPI )
{
    j9array[0]-=IK2PI;
}
else if( j9array[0] < -IKPI )
{    j9array[0]+=IK2PI;
}
j9valid[0] = true;
for(int ij9 = 0; ij9 < 1; ++ij9)
{
if( !j9valid[ij9] )
{
    continue;
}
_ij9[0] = ij9; _ij9[1] = -1;
for(int iij9 = ij9+1; iij9 < 1; ++iij9)
{
if( j9valid[iij9] && IKabs(cj9array[ij9]-cj9array[iij9]) < IKFAST_SOLUTION_THRESH && IKabs(sj9array[ij9]-sj9array[iij9]) < IKFAST_SOLUTION_THRESH )
{
    j9valid[iij9]=false; _ij9[1] = iij9; break; 
}
}
j9 = j9array[ij9]; cj9 = cj9array[ij9]; sj9 = sj9array[ij9];
{
IkReal evalcond[5];
IkReal x1240=IKcos(j9);
IkReal x1241=IKsin(j9);
IkReal x1242=((0.3215)*sj12);
IkReal x1243=((1.0)*px);
IkReal x1244=((1.0)*py);
evalcond[0]=((-0.027378)+(((0.234)*px*x1240))+(((0.234)*py*x1241)));
evalcond[1]=((0.117)+(((-1.0)*x1240*x1243))+(((-1.0)*x1241*x1244)));
evalcond[2]=((((0.117)*x1240))+(((-1.0)*x1243))+((x1241*x1242)));
evalcond[3]=((((0.117)*x1241))+(((-1.0)*x1244))+(((-1.0)*x1240*x1242)));
evalcond[4]=(x1242+((py*x1240))+(((-1.0)*x1241*x1243)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}

}

} else
{
{
IkReal j9array[1], cj9array[1], sj9array[1];
bool j9valid[1]={false};
_nj9 = 1;
IkReal x1245=(px*sj12);
CheckValue<IkReal> x1246=IKPowWithIntegerCheck(((((321500.0)*x1245))+(((-117000.0)*py))),-1);
if(!x1246.valid){
continue;
}
CheckValue<IkReal> x1247=IKPowWithIntegerCheck(((((643000.0)*x1245))+(((-234000.0)*py))),-1);
if(!x1247.valid){
continue;
}
if( IKabs(((x1246.value)*(((-13689.0)+(((1000000.0)*(px*px))))))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((x1247.value)*(((((-2000000.0)*px*py))+(((75231.0)*sj12)))))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((x1246.value)*(((-13689.0)+(((1000000.0)*(px*px)))))))+IKsqr(((x1247.value)*(((((-2000000.0)*px*py))+(((75231.0)*sj12))))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j9array[0]=IKatan2(((x1246.value)*(((-13689.0)+(((1000000.0)*(px*px)))))), ((x1247.value)*(((((-2000000.0)*px*py))+(((75231.0)*sj12))))));
sj9array[0]=IKsin(j9array[0]);
cj9array[0]=IKcos(j9array[0]);
if( j9array[0] > IKPI )
{
    j9array[0]-=IK2PI;
}
else if( j9array[0] < -IKPI )
{    j9array[0]+=IK2PI;
}
j9valid[0] = true;
for(int ij9 = 0; ij9 < 1; ++ij9)
{
if( !j9valid[ij9] )
{
    continue;
}
_ij9[0] = ij9; _ij9[1] = -1;
for(int iij9 = ij9+1; iij9 < 1; ++iij9)
{
if( j9valid[iij9] && IKabs(cj9array[ij9]-cj9array[iij9]) < IKFAST_SOLUTION_THRESH && IKabs(sj9array[ij9]-sj9array[iij9]) < IKFAST_SOLUTION_THRESH )
{
    j9valid[iij9]=false; _ij9[1] = iij9; break; 
}
}
j9 = j9array[ij9]; cj9 = cj9array[ij9]; sj9 = sj9array[ij9];
{
IkReal evalcond[5];
IkReal x1248=IKcos(j9);
IkReal x1249=IKsin(j9);
IkReal x1250=((0.3215)*sj12);
IkReal x1251=((1.0)*px);
IkReal x1252=((1.0)*py);
evalcond[0]=((-0.027378)+(((0.234)*px*x1248))+(((0.234)*py*x1249)));
evalcond[1]=((0.117)+(((-1.0)*x1249*x1252))+(((-1.0)*x1248*x1251)));
evalcond[2]=((((-1.0)*x1251))+(((0.117)*x1248))+((x1249*x1250)));
evalcond[3]=((((-1.0)*x1252))+(((0.117)*x1249))+(((-1.0)*x1248*x1250)));
evalcond[4]=((((-1.0)*x1249*x1251))+x1250+((py*x1248)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}

}

} else
{
{
IkReal j9array[1], cj9array[1], sj9array[1];
bool j9valid[1]={false};
_nj9 = 1;
IkReal x1253=((643.0)*sj12);
CheckValue<IkReal> x1254=IKPowWithIntegerCheck(IKsign(((((2000.0)*pp))+(((-2000.0)*(pz*pz))))),-1);
if(!x1254.valid){
continue;
}
CheckValue<IkReal> x1255 = IKatan2WithCheck(IkReal(((((234.0)*py))+((px*x1253)))),IkReal(((((234.0)*px))+(((-1.0)*py*x1253)))),IKFAST_ATAN2_MAGTHRESH);
if(!x1255.valid){
continue;
}
j9array[0]=((-1.5707963267949)+(((1.5707963267949)*(x1254.value)))+(x1255.value));
sj9array[0]=IKsin(j9array[0]);
cj9array[0]=IKcos(j9array[0]);
if( j9array[0] > IKPI )
{
    j9array[0]-=IK2PI;
}
else if( j9array[0] < -IKPI )
{    j9array[0]+=IK2PI;
}
j9valid[0] = true;
for(int ij9 = 0; ij9 < 1; ++ij9)
{
if( !j9valid[ij9] )
{
    continue;
}
_ij9[0] = ij9; _ij9[1] = -1;
for(int iij9 = ij9+1; iij9 < 1; ++iij9)
{
if( j9valid[iij9] && IKabs(cj9array[ij9]-cj9array[iij9]) < IKFAST_SOLUTION_THRESH && IKabs(sj9array[ij9]-sj9array[iij9]) < IKFAST_SOLUTION_THRESH )
{
    j9valid[iij9]=false; _ij9[1] = iij9; break; 
}
}
j9 = j9array[ij9]; cj9 = cj9array[ij9]; sj9 = sj9array[ij9];
{
IkReal evalcond[5];
IkReal x1256=IKcos(j9);
IkReal x1257=IKsin(j9);
IkReal x1258=((0.3215)*sj12);
IkReal x1259=((1.0)*px);
IkReal x1260=((1.0)*py);
evalcond[0]=((-0.027378)+(((0.234)*py*x1257))+(((0.234)*px*x1256)));
evalcond[1]=((0.117)+(((-1.0)*x1256*x1259))+(((-1.0)*x1257*x1260)));
evalcond[2]=((((-1.0)*x1259))+(((0.117)*x1256))+((x1257*x1258)));
evalcond[3]=((((-1.0)*x1256*x1258))+(((0.117)*x1257))+(((-1.0)*x1260)));
evalcond[4]=(x1258+(((-1.0)*x1257*x1259))+((py*x1256)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}

}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((IKabs(px))+(IKabs(py)));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j9eval[1];
IkReal x1261=((-1.0)*pz);
sj10=-1.0;
cj10=0;
j10=-1.5707963267949;
px=0;
py=0;
pp=pz*pz;
npx=(pz*r20);
npy=(pz*r21);
npz=(pz*r22);
rxp0_0=(pz*r10);
rxp0_1=(r00*x1261);
rxp0_2=0;
rxp1_0=(pz*r11);
rxp1_1=(r01*x1261);
rxp1_2=0;
rxp2_0=(pz*r12);
rxp2_1=(r02*x1261);
rxp2_2=0;
j9eval[0]=IKabs(((-1.0)+(((7.55075242895756)*(sj12*sj12)))));
if( IKabs(j9eval[0]) < 0.0000000100000000  )
{
continue; // no branches [j9]

} else
{
IkReal op[2+1], zeror[2];
int numroots;
IkReal x1262=((7.55075242895756)*(sj12*sj12));
op[0]=((-1.0)+x1262);
op[1]=0;
op[2]=((1.0)+(((-1.0)*x1262)));
polyroots2(op,zeror,numroots);
IkReal j9array[2], cj9array[2], sj9array[2], tempj9array[1];
int numsolutions = 0;
for(int ij9 = 0; ij9 < numroots; ++ij9)
{
IkReal htj9 = zeror[ij9];
tempj9array[0]=((2.0)*(atan(htj9)));
for(int kj9 = 0; kj9 < 1; ++kj9)
{
j9array[numsolutions] = tempj9array[kj9];
if( j9array[numsolutions] > IKPI )
{
    j9array[numsolutions]-=IK2PI;
}
else if( j9array[numsolutions] < -IKPI )
{
    j9array[numsolutions]+=IK2PI;
}
sj9array[numsolutions] = IKsin(j9array[numsolutions]);
cj9array[numsolutions] = IKcos(j9array[numsolutions]);
numsolutions++;
}
}
bool j9valid[2]={true,true};
_nj9 = 2;
for(int ij9 = 0; ij9 < numsolutions; ++ij9)
    {
if( !j9valid[ij9] )
{
    continue;
}
    j9 = j9array[ij9]; cj9 = cj9array[ij9]; sj9 = sj9array[ij9];
htj9 = IKtan(j9/2);

_ij9[0] = ij9; _ij9[1] = -1;
for(int iij9 = ij9+1; iij9 < numsolutions; ++iij9)
{
if( j9valid[iij9] && IKabs(cj9array[ij9]-cj9array[iij9]) < IKFAST_SOLUTION_THRESH && IKabs(sj9array[ij9]-sj9array[iij9]) < IKFAST_SOLUTION_THRESH )
{
    j9valid[iij9]=false; _ij9[1] = iij9; break; 
}
}
rotationfunction0(solutions);
    }

}

}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
if( 1 )
{
bgotonextstatement=false;
continue; // branch miss [j9]

}
} while(0);
if( bgotonextstatement )
{
}
}
}
}
}

} else
{
{
IkReal j9array[1], cj9array[1], sj9array[1];
bool j9valid[1]={false};
_nj9 = 1;
IkReal x1263=cj11*cj11;
IkReal x1264=cj12*cj12;
IkReal x1265=(sj11*sj12);
IkReal x1266=(cj11*sj12);
IkReal x1267=((24186.7665)*x1263);
IkReal x1268=((24186.7665)*cj11*sj11);
CheckValue<IkReal> x1269=IKPowWithIntegerCheck(IKsign(((((-75231.0)*py*x1266))+(((-75231.0)*px*x1265))+(((-27378.0)*py)))),-1);
if(!x1269.valid){
continue;
}
CheckValue<IkReal> x1270 = IKatan2WithCheck(IkReal(((-3203.226)+((x1264*x1267))+(((-17604.054)*x1266))+(((234000.0)*(px*px)))+(((-1.0)*x1267)))),IkReal(((((-234000.0)*px*py))+((x1264*x1268))+(((-8802.027)*x1265))+(((-1.0)*x1268)))),IKFAST_ATAN2_MAGTHRESH);
if(!x1270.valid){
continue;
}
j9array[0]=((-1.5707963267949)+(((1.5707963267949)*(x1269.value)))+(x1270.value));
sj9array[0]=IKsin(j9array[0]);
cj9array[0]=IKcos(j9array[0]);
if( j9array[0] > IKPI )
{
    j9array[0]-=IK2PI;
}
else if( j9array[0] < -IKPI )
{    j9array[0]+=IK2PI;
}
j9valid[0] = true;
for(int ij9 = 0; ij9 < 1; ++ij9)
{
if( !j9valid[ij9] )
{
    continue;
}
_ij9[0] = ij9; _ij9[1] = -1;
for(int iij9 = ij9+1; iij9 < 1; ++iij9)
{
if( j9valid[iij9] && IKabs(cj9array[ij9]-cj9array[iij9]) < IKFAST_SOLUTION_THRESH && IKabs(sj9array[ij9]-sj9array[iij9]) < IKFAST_SOLUTION_THRESH )
{
    j9valid[iij9]=false; _ij9[1] = iij9; break; 
}
}
j9 = j9array[ij9]; cj9 = cj9array[ij9]; sj9 = sj9array[ij9];
{
IkReal evalcond[5];
IkReal x1271=IKcos(j9);
IkReal x1272=IKsin(j9);
IkReal x1273=((1.0)*py);
IkReal x1274=((0.3215)*sj12);
IkReal x1275=(px*x1272);
IkReal x1276=(px*x1271);
IkReal x1277=(cj11*x1271);
IkReal x1278=(cj11*x1272);
IkReal x1279=(sj11*x1271);
IkReal x1280=(py*x1272);
evalcond[0]=((-0.027378)+(((-0.075231)*cj11*sj12))+(((0.234)*x1276))+(((0.234)*x1280)));
evalcond[1]=(((x1274*x1277))+(((-1.0)*px))+(((0.117)*x1271))+(((-1.0)*sj11*x1272*x1274)));
evalcond[2]=((((-1.0)*x1273))+((x1274*x1279))+((x1274*x1278))+(((0.117)*x1272)));
evalcond[3]=((((-0.117)*sj11))+((sj11*x1276))+(((-1.0)*x1273*x1277))+((cj11*x1275))+((sj11*x1280)));
evalcond[4]=(((sj11*x1275))+x1274+(((0.117)*cj11))+(((-1.0)*x1273*x1279))+(((-1.0)*x1273*x1278))+(((-1.0)*cj11*x1276)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}

}

} else
{
{
IkReal j9array[1], cj9array[1], sj9array[1];
bool j9valid[1]={false};
_nj9 = 1;
IkReal x1281=cj11*cj11;
IkReal x1282=((117000.0)*cj11);
IkReal x1283=((13689.0)*cj11);
IkReal x1284=((37615.5)*cj11*sj11*sj12);
IkReal x1285=((37615.5)*sj12*x1281);
CheckValue<IkReal> x1286 = IKatan2WithCheck(IkReal(((((-1.0)*px*x1284))+((py*x1285))+((py*x1283)))),IkReal((((px*x1285))+((px*x1283))+((py*x1284)))),IKFAST_ATAN2_MAGTHRESH);
if(!x1286.valid){
continue;
}
CheckValue<IkReal> x1287=IKPowWithIntegerCheck(IKsign((((pp*x1282))+(((-1.0)*x1282*(pz*pz))))),-1);
if(!x1287.valid){
continue;
}
j9array[0]=((-1.5707963267949)+(x1286.value)+(((1.5707963267949)*(x1287.value))));
sj9array[0]=IKsin(j9array[0]);
cj9array[0]=IKcos(j9array[0]);
if( j9array[0] > IKPI )
{
    j9array[0]-=IK2PI;
}
else if( j9array[0] < -IKPI )
{    j9array[0]+=IK2PI;
}
j9valid[0] = true;
for(int ij9 = 0; ij9 < 1; ++ij9)
{
if( !j9valid[ij9] )
{
    continue;
}
_ij9[0] = ij9; _ij9[1] = -1;
for(int iij9 = ij9+1; iij9 < 1; ++iij9)
{
if( j9valid[iij9] && IKabs(cj9array[ij9]-cj9array[iij9]) < IKFAST_SOLUTION_THRESH && IKabs(sj9array[ij9]-sj9array[iij9]) < IKFAST_SOLUTION_THRESH )
{
    j9valid[iij9]=false; _ij9[1] = iij9; break; 
}
}
j9 = j9array[ij9]; cj9 = cj9array[ij9]; sj9 = sj9array[ij9];
{
IkReal evalcond[5];
IkReal x1288=IKcos(j9);
IkReal x1289=IKsin(j9);
IkReal x1290=((1.0)*py);
IkReal x1291=((0.3215)*sj12);
IkReal x1292=(px*x1289);
IkReal x1293=(px*x1288);
IkReal x1294=(cj11*x1288);
IkReal x1295=(cj11*x1289);
IkReal x1296=(sj11*x1288);
IkReal x1297=(py*x1289);
evalcond[0]=((-0.027378)+(((-0.075231)*cj11*sj12))+(((0.234)*x1293))+(((0.234)*x1297)));
evalcond[1]=((((-1.0)*sj11*x1289*x1291))+(((0.117)*x1288))+((x1291*x1294))+(((-1.0)*px)));
evalcond[2]=((((-1.0)*x1290))+(((0.117)*x1289))+((x1291*x1296))+((x1291*x1295)));
evalcond[3]=((((-0.117)*sj11))+((sj11*x1297))+((sj11*x1293))+(((-1.0)*x1290*x1294))+((cj11*x1292)));
evalcond[4]=(x1291+((sj11*x1292))+(((0.117)*cj11))+(((-1.0)*cj11*x1293))+(((-1.0)*x1290*x1296))+(((-1.0)*x1290*x1295)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}

}

} else
{
{
IkReal j9array[1], cj9array[1], sj9array[1];
bool j9valid[1]={false};
_nj9 = 1;
IkReal x1298=((1286000.0)*sj12);
CheckValue<IkReal> x1299=IKPowWithIntegerCheck(IKsign(((468205.0)+(((300924.0)*cj11*sj12))+(((-413449.0)*(cj12*cj12))))),-1);
if(!x1299.valid){
continue;
}
CheckValue<IkReal> x1300 = IKatan2WithCheck(IkReal((((cj11*py*x1298))+(((-1.0)*px*sj11*x1298))+(((468000.0)*py)))),IkReal((((cj11*px*x1298))+((py*sj11*x1298))+(((468000.0)*px)))),IKFAST_ATAN2_MAGTHRESH);
if(!x1300.valid){
continue;
}
j9array[0]=((-1.5707963267949)+(((1.5707963267949)*(x1299.value)))+(x1300.value));
sj9array[0]=IKsin(j9array[0]);
cj9array[0]=IKcos(j9array[0]);
if( j9array[0] > IKPI )
{
    j9array[0]-=IK2PI;
}
else if( j9array[0] < -IKPI )
{    j9array[0]+=IK2PI;
}
j9valid[0] = true;
for(int ij9 = 0; ij9 < 1; ++ij9)
{
if( !j9valid[ij9] )
{
    continue;
}
_ij9[0] = ij9; _ij9[1] = -1;
for(int iij9 = ij9+1; iij9 < 1; ++iij9)
{
if( j9valid[iij9] && IKabs(cj9array[ij9]-cj9array[iij9]) < IKFAST_SOLUTION_THRESH && IKabs(sj9array[ij9]-sj9array[iij9]) < IKFAST_SOLUTION_THRESH )
{
    j9valid[iij9]=false; _ij9[1] = iij9; break; 
}
}
j9 = j9array[ij9]; cj9 = cj9array[ij9]; sj9 = sj9array[ij9];
{
IkReal evalcond[5];
IkReal x1301=IKcos(j9);
IkReal x1302=IKsin(j9);
IkReal x1303=((1.0)*py);
IkReal x1304=((0.3215)*sj12);
IkReal x1305=(px*x1302);
IkReal x1306=(px*x1301);
IkReal x1307=(cj11*x1301);
IkReal x1308=(cj11*x1302);
IkReal x1309=(sj11*x1301);
IkReal x1310=(py*x1302);
evalcond[0]=((-0.027378)+(((-0.075231)*cj11*sj12))+(((0.234)*x1306))+(((0.234)*x1310)));
evalcond[1]=((((0.117)*x1301))+(((-1.0)*sj11*x1302*x1304))+(((-1.0)*px))+((x1304*x1307)));
evalcond[2]=((((-1.0)*x1303))+(((0.117)*x1302))+((x1304*x1309))+((x1304*x1308)));
evalcond[3]=((((-0.117)*sj11))+(((-1.0)*x1303*x1307))+((cj11*x1305))+((sj11*x1310))+((sj11*x1306)));
evalcond[4]=(x1304+(((0.117)*cj11))+(((-1.0)*x1303*x1309))+(((-1.0)*x1303*x1308))+(((-1.0)*cj11*x1306))+((sj11*x1305)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}

}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((IKabs(px))+(IKabs(py)));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j9eval[1];
IkReal x1311=((-1.0)*pz);
px=0;
py=0;
pp=pz*pz;
npx=(pz*r20);
npy=(pz*r21);
npz=(pz*r22);
rxp0_0=(pz*r10);
rxp0_1=(r00*x1311);
rxp0_2=0;
rxp1_0=(pz*r11);
rxp1_1=(r01*x1311);
rxp1_2=0;
rxp2_0=(pz*r12);
rxp2_1=(r02*x1311);
rxp2_2=0;
j9eval[0]=IKabs(((-1.0)+(((-2.74786324786325)*cj10*cj12))+(((-3.00854700854701)*cj10))+(((2.74786324786325)*cj11*sj10*sj12))));
if( IKabs(j9eval[0]) < 0.0000000100000000  )
{
continue; // no branches [j9]

} else
{
IkReal op[2+1], zeror[2];
int numroots;
IkReal x1312=((3.00854700854701)*cj10);
IkReal x1313=((2.74786324786325)*cj10*cj12);
IkReal x1314=((2.74786324786325)*cj11*sj10*sj12);
IkReal x1315=(x1313+x1312);
op[0]=((-1.0)+x1314+(((-1.0)*x1315)));
op[1]=0;
op[2]=((1.0)+x1315+(((-1.0)*x1314)));
polyroots2(op,zeror,numroots);
IkReal j9array[2], cj9array[2], sj9array[2], tempj9array[1];
int numsolutions = 0;
for(int ij9 = 0; ij9 < numroots; ++ij9)
{
IkReal htj9 = zeror[ij9];
tempj9array[0]=((2.0)*(atan(htj9)));
for(int kj9 = 0; kj9 < 1; ++kj9)
{
j9array[numsolutions] = tempj9array[kj9];
if( j9array[numsolutions] > IKPI )
{
    j9array[numsolutions]-=IK2PI;
}
else if( j9array[numsolutions] < -IKPI )
{
    j9array[numsolutions]+=IK2PI;
}
sj9array[numsolutions] = IKsin(j9array[numsolutions]);
cj9array[numsolutions] = IKcos(j9array[numsolutions]);
numsolutions++;
}
}
bool j9valid[2]={true,true};
_nj9 = 2;
for(int ij9 = 0; ij9 < numsolutions; ++ij9)
    {
if( !j9valid[ij9] )
{
    continue;
}
    j9 = j9array[ij9]; cj9 = cj9array[ij9]; sj9 = sj9array[ij9];
htj9 = IKtan(j9/2);

_ij9[0] = ij9; _ij9[1] = -1;
for(int iij9 = ij9+1; iij9 < numsolutions; ++iij9)
{
if( j9valid[iij9] && IKabs(cj9array[ij9]-cj9array[iij9]) < IKFAST_SOLUTION_THRESH && IKabs(sj9array[ij9]-sj9array[iij9]) < IKFAST_SOLUTION_THRESH )
{
    j9valid[iij9]=false; _ij9[1] = iij9; break; 
}
}
rotationfunction0(solutions);
    }

}

}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
if( 1 )
{
bgotonextstatement=false;
continue; // branch miss [j9]

}
} while(0);
if( bgotonextstatement )
{
}
}
}
}
}

} else
{
{
IkReal j9array[1], cj9array[1], sj9array[1];
bool j9valid[1]={false};
_nj9 = 1;
IkReal x1316=cj10*cj10;
IkReal x1317=(j5*sj10);
IkReal x1318=((704.0)*cj10);
IkReal x1319=(sj11*sj12);
IkReal x1320=((643.0)*px);
IkReal x1321=(cj10*cj12);
IkReal x1322=(pz*sj10);
IkReal x1323=((2000.0)*cj10);
IkReal x1324=((38.58)*sj10);
IkReal x1325=((206.7245)*cj12);
IkReal x1326=(cj11*sj12);
IkReal x1327=(cj10*sj10);
IkReal x1328=((643.0)*pz);
IkReal x1329=((643.0)*j5);
IkReal x1330=(cj12*x1316);
CheckValue<IkReal> x1331=IKPowWithIntegerCheck(IKsign(((((-1.0)*x1320*x1326*x1327))+(((234.0)*cj10*px))+(((704.0)*px*x1316))+(((-643.0)*cj10*py*x1319))+((x1320*x1330)))),-1);
if(!x1331.valid){
continue;
}
CheckValue<IkReal> x1332 = IKatan2WithCheck(IkReal(((((-1.0)*x1319*x1325))+(((-75.231)*cj10*x1319))+(((-226.336)*x1319))+((px*py*x1323))+(((-643.0)*x1319*x1322))+(((643.0)*x1317*x1319))+((x1319*x1324)))),IkReal(((82.368)+(((643.0)*x1321*x1322))+(((75.231)*cj12))+(((-75.231)*x1326*x1327))+(((-1.0)*x1317*x1318))+(((-643.0)*x1317*x1321))+(((-1.0)*sj10*x1325*x1326))+(((38.58)*x1326))+(((-38.58)*x1316*x1326))+(((-42.24)*x1327))+(((-1.0)*x1326*x1328))+(((275.186)*cj10))+(((-1.0)*x1321*x1324))+((x1326*x1329))+(((-234.0)*x1317))+(((452.672)*x1321))+(((-1.0)*x1323*(py*py)))+(((234.0)*x1322))+(((-226.336)*sj10*x1326))+(((82.368)*x1316))+((x1316*x1326*x1328))+(((75.231)*x1330))+((x1321*x1325))+((x1318*x1322))+(((-1.0)*x1316*x1326*x1329))+(((-14.04)*sj10)))),IKFAST_ATAN2_MAGTHRESH);
if(!x1332.valid){
continue;
}
j9array[0]=((-1.5707963267949)+(((1.5707963267949)*(x1331.value)))+(x1332.value));
sj9array[0]=IKsin(j9array[0]);
cj9array[0]=IKcos(j9array[0]);
if( j9array[0] > IKPI )
{
    j9array[0]-=IK2PI;
}
else if( j9array[0] < -IKPI )
{    j9array[0]+=IK2PI;
}
j9valid[0] = true;
for(int ij9 = 0; ij9 < 1; ++ij9)
{
if( !j9valid[ij9] )
{
    continue;
}
_ij9[0] = ij9; _ij9[1] = -1;
for(int iij9 = ij9+1; iij9 < 1; ++iij9)
{
if( j9valid[iij9] && IKabs(cj9array[ij9]-cj9array[iij9]) < IKFAST_SOLUTION_THRESH && IKabs(sj9array[ij9]-sj9array[iij9]) < IKFAST_SOLUTION_THRESH )
{
    j9valid[iij9]=false; _ij9[1] = iij9; break; 
}
}
j9 = j9array[ij9]; cj9 = cj9array[ij9]; sj9 = sj9array[ij9];
{
IkReal evalcond[6];
IkReal x1333=IKcos(j9);
IkReal x1334=IKsin(j9);
IkReal x1335=((1.0)*py);
IkReal x1336=((1.0)*cj10);
IkReal x1337=(cj11*sj10);
IkReal x1338=((0.704)*sj10);
IkReal x1339=(cj10*cj12);
IkReal x1340=(sj10*sj11);
IkReal x1341=(sj11*sj12);
IkReal x1342=(cj10*sj11);
IkReal x1343=(cj10*cj11);
IkReal x1344=(px*x1334);
IkReal x1345=((0.3215)*x1334);
IkReal x1346=(px*x1333);
IkReal x1347=((0.3215)*x1333);
IkReal x1348=(cj10*x1334);
IkReal x1349=(py*x1334);
evalcond[0]=((0.352)+(((-1.0)*x1336*x1346))+(((-0.06)*sj10))+(((0.117)*cj10))+(((-1.0)*j5*sj10))+((pz*sj10))+(((-1.0)*x1335*x1348))+(((0.3215)*cj12)));
evalcond[1]=((((0.352)*cj10*x1333))+(((-1.0)*x1341*x1345))+((x1339*x1347))+(((-1.0)*px))+(((0.117)*x1333))+(((-1.0)*sj12*x1337*x1347)));
evalcond[2]=(((x1339*x1345))+((x1341*x1347))+(((0.117)*x1334))+(((0.352)*x1348))+(((-1.0)*x1335))+(((-1.0)*sj12*x1337*x1345)));
evalcond[3]=((((0.06)*x1342))+((cj11*x1344))+((j5*x1342))+(((0.117)*x1340))+(((-1.0)*cj11*x1333*x1335))+(((-1.0)*x1340*x1346))+(((-1.0)*pz*sj11*x1336))+(((-1.0)*x1334*x1335*x1340)));
evalcond[4]=((((-1.0)*cj11*j5*x1336))+((sj11*x1344))+(((0.3215)*sj12))+(((-0.117)*x1337))+((x1337*x1349))+((x1337*x1346))+(((-1.0)*sj11*x1333*x1335))+(((-0.06)*x1343))+((pz*x1343)));
evalcond[5]=((-0.03783075)+(((0.12)*pz))+(((0.234)*x1349))+(((0.234)*x1346))+(((-1.0)*(j5*j5)))+(((-1.0)*pz*x1338))+(((0.704)*cj10*x1346))+(((0.04224)*sj10))+(((-1.0)*pp))+(((-0.082368)*cj10))+(((0.704)*py*x1348))+((j5*x1338))+(((-0.12)*j5))+(((2.0)*j5*pz)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}

}

} else
{
{
IkReal j9array[1], cj9array[1], sj9array[1];
bool j9valid[1]={false};
_nj9 = 1;
IkReal x1350=cj10*cj10;
IkReal x1351=(j5*sj10);
IkReal x1352=((704.0)*cj10);
IkReal x1353=(sj11*sj12);
IkReal x1354=(cj10*py);
IkReal x1355=(cj10*cj12);
IkReal x1356=(pz*sj10);
IkReal x1357=((38.58)*sj10);
IkReal x1358=((206.7245)*cj12);
IkReal x1359=(cj11*sj12);
IkReal x1360=(cj10*sj10);
IkReal x1361=((643.0)*pz);
IkReal x1362=((643.0)*j5);
IkReal x1363=(cj12*x1350);
CheckValue<IkReal> x1364=IKPowWithIntegerCheck(IKsign(((((234.0)*x1354))+(((-643.0)*sj10*x1354*x1359))+(((704.0)*py*x1350))+(((643.0)*py*x1363))+(((643.0)*cj10*px*x1353)))),-1);
if(!x1364.valid){
continue;
}
CheckValue<IkReal> x1365 = IKatan2WithCheck(IkReal(((82.368)+(((234.0)*x1356))+(((75.231)*cj12))+(((75.231)*x1363))+(((-226.336)*sj10*x1359))+((x1355*x1358))+(((-42.24)*x1360))+(((452.672)*x1355))+(((-234.0)*x1351))+(((-1.0)*x1350*x1359*x1362))+((x1359*x1362))+(((-643.0)*x1351*x1355))+(((-1.0)*x1355*x1357))+(((-1.0)*sj10*x1358*x1359))+(((-1.0)*x1359*x1361))+(((-38.58)*x1350*x1359))+(((275.186)*cj10))+(((643.0)*x1355*x1356))+(((38.58)*x1359))+((x1350*x1359*x1361))+(((-75.231)*x1359*x1360))+(((-2000.0)*cj10*(px*px)))+(((-1.0)*x1351*x1352))+((x1352*x1356))+(((82.368)*x1350))+(((-14.04)*sj10)))),IkReal(((((-643.0)*x1351*x1353))+(((2000.0)*px*x1354))+(((643.0)*x1353*x1356))+(((226.336)*x1353))+((x1353*x1358))+(((75.231)*cj10*x1353))+(((-1.0)*x1353*x1357)))),IKFAST_ATAN2_MAGTHRESH);
if(!x1365.valid){
continue;
}
j9array[0]=((-1.5707963267949)+(((1.5707963267949)*(x1364.value)))+(x1365.value));
sj9array[0]=IKsin(j9array[0]);
cj9array[0]=IKcos(j9array[0]);
if( j9array[0] > IKPI )
{
    j9array[0]-=IK2PI;
}
else if( j9array[0] < -IKPI )
{    j9array[0]+=IK2PI;
}
j9valid[0] = true;
for(int ij9 = 0; ij9 < 1; ++ij9)
{
if( !j9valid[ij9] )
{
    continue;
}
_ij9[0] = ij9; _ij9[1] = -1;
for(int iij9 = ij9+1; iij9 < 1; ++iij9)
{
if( j9valid[iij9] && IKabs(cj9array[ij9]-cj9array[iij9]) < IKFAST_SOLUTION_THRESH && IKabs(sj9array[ij9]-sj9array[iij9]) < IKFAST_SOLUTION_THRESH )
{
    j9valid[iij9]=false; _ij9[1] = iij9; break; 
}
}
j9 = j9array[ij9]; cj9 = cj9array[ij9]; sj9 = sj9array[ij9];
{
IkReal evalcond[6];
IkReal x1366=IKcos(j9);
IkReal x1367=IKsin(j9);
IkReal x1368=((1.0)*py);
IkReal x1369=((1.0)*cj10);
IkReal x1370=(cj11*sj10);
IkReal x1371=((0.704)*sj10);
IkReal x1372=(cj10*cj12);
IkReal x1373=(sj10*sj11);
IkReal x1374=(sj11*sj12);
IkReal x1375=(cj10*sj11);
IkReal x1376=(cj10*cj11);
IkReal x1377=(px*x1367);
IkReal x1378=((0.3215)*x1367);
IkReal x1379=(px*x1366);
IkReal x1380=((0.3215)*x1366);
IkReal x1381=(cj10*x1367);
IkReal x1382=(py*x1367);
evalcond[0]=((0.352)+(((-0.06)*sj10))+(((0.117)*cj10))+(((-1.0)*j5*sj10))+((pz*sj10))+(((0.3215)*cj12))+(((-1.0)*x1368*x1381))+(((-1.0)*x1369*x1379)));
evalcond[1]=((((0.117)*x1366))+(((0.352)*cj10*x1366))+(((-1.0)*x1374*x1378))+(((-1.0)*px))+((x1372*x1380))+(((-1.0)*sj12*x1370*x1380)));
evalcond[2]=(((x1372*x1378))+(((0.117)*x1367))+(((0.352)*x1381))+(((-1.0)*sj12*x1370*x1378))+((x1374*x1380))+(((-1.0)*x1368)));
evalcond[3]=((((-1.0)*cj11*x1366*x1368))+(((-1.0)*x1373*x1379))+(((0.06)*x1375))+(((-1.0)*pz*sj11*x1369))+((j5*x1375))+(((0.117)*x1373))+(((-1.0)*x1367*x1368*x1373))+((cj11*x1377)));
evalcond[4]=(((x1370*x1382))+((pz*x1376))+(((0.3215)*sj12))+(((-0.06)*x1376))+((x1370*x1379))+(((-0.117)*x1370))+(((-1.0)*cj11*j5*x1369))+(((-1.0)*sj11*x1366*x1368))+((sj11*x1377)));
evalcond[5]=((-0.03783075)+(((0.12)*pz))+(((-1.0)*(j5*j5)))+(((0.234)*x1379))+(((0.04224)*sj10))+((j5*x1371))+(((-1.0)*pp))+(((-0.082368)*cj10))+(((0.704)*cj10*x1379))+(((0.704)*py*x1381))+(((-1.0)*pz*x1371))+(((-0.12)*j5))+(((0.234)*x1382))+(((2.0)*j5*pz)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}

}

} else
{
{
IkReal j9array[1], cj9array[1], sj9array[1];
bool j9valid[1]={false};
_nj9 = 1;
IkReal x1383=cj10*cj10;
IkReal x1384=cj12*cj12;
IkReal x1385=cj11*cj11;
IkReal x1386=((1286000.0)*py);
IkReal x1387=(cj10*cj12);
IkReal x1388=((1286000.0)*px);
IkReal x1389=((1408000.0)*cj10);
IkReal x1390=(sj11*sj12);
IkReal x1391=(cj11*sj10*sj12);
IkReal x1392=((413449.0)*x1383);
CheckValue<IkReal> x1393 = IKatan2WithCheck(IkReal((((py*x1389))+((x1386*x1387))+(((-1.0)*x1388*x1390))+(((468000.0)*py))+(((-1.0)*x1386*x1391)))),IkReal((((x1387*x1388))+((x1386*x1390))+(((-1.0)*x1388*x1391))+(((468000.0)*px))+((px*x1389)))),IKFAST_ATAN2_MAGTHRESH);
if(!x1393.valid){
continue;
}
CheckValue<IkReal> x1394=IKPowWithIntegerCheck(IKsign(((468205.0)+(((-1.0)*x1385*x1392))+(((-413449.0)*x1384))+((x1384*x1385*x1392))+(((495616.0)*x1383))+(((-826898.0)*x1387*x1391))+(((300924.0)*x1387))+(((-300924.0)*x1391))+(((905344.0)*cj12*x1383))+((x1384*x1392))+(((329472.0)*cj10))+(((-905344.0)*cj10*x1391)))),-1);
if(!x1394.valid){
continue;
}
j9array[0]=((-1.5707963267949)+(x1393.value)+(((1.5707963267949)*(x1394.value))));
sj9array[0]=IKsin(j9array[0]);
cj9array[0]=IKcos(j9array[0]);
if( j9array[0] > IKPI )
{
    j9array[0]-=IK2PI;
}
else if( j9array[0] < -IKPI )
{    j9array[0]+=IK2PI;
}
j9valid[0] = true;
for(int ij9 = 0; ij9 < 1; ++ij9)
{
if( !j9valid[ij9] )
{
    continue;
}
_ij9[0] = ij9; _ij9[1] = -1;
for(int iij9 = ij9+1; iij9 < 1; ++iij9)
{
if( j9valid[iij9] && IKabs(cj9array[ij9]-cj9array[iij9]) < IKFAST_SOLUTION_THRESH && IKabs(sj9array[ij9]-sj9array[iij9]) < IKFAST_SOLUTION_THRESH )
{
    j9valid[iij9]=false; _ij9[1] = iij9; break; 
}
}
j9 = j9array[ij9]; cj9 = cj9array[ij9]; sj9 = sj9array[ij9];
{
IkReal evalcond[6];
IkReal x1395=IKcos(j9);
IkReal x1396=IKsin(j9);
IkReal x1397=((1.0)*py);
IkReal x1398=((1.0)*cj10);
IkReal x1399=(cj11*sj10);
IkReal x1400=((0.704)*sj10);
IkReal x1401=(cj10*cj12);
IkReal x1402=(sj10*sj11);
IkReal x1403=(sj11*sj12);
IkReal x1404=(cj10*sj11);
IkReal x1405=(cj10*cj11);
IkReal x1406=(px*x1396);
IkReal x1407=((0.3215)*x1396);
IkReal x1408=(px*x1395);
IkReal x1409=((0.3215)*x1395);
IkReal x1410=(cj10*x1396);
IkReal x1411=(py*x1396);
evalcond[0]=((0.352)+(((-0.06)*sj10))+(((-1.0)*x1398*x1408))+(((0.117)*cj10))+(((-1.0)*j5*sj10))+((pz*sj10))+(((0.3215)*cj12))+(((-1.0)*x1397*x1410)));
evalcond[1]=((((0.117)*x1395))+(((-1.0)*px))+(((-1.0)*sj12*x1399*x1409))+(((0.352)*cj10*x1395))+(((-1.0)*x1403*x1407))+((x1401*x1409)));
evalcond[2]=((((0.117)*x1396))+(((0.352)*x1410))+(((-1.0)*sj12*x1399*x1407))+((x1403*x1409))+((x1401*x1407))+(((-1.0)*x1397)));
evalcond[3]=((((-1.0)*cj11*x1395*x1397))+((j5*x1404))+(((0.117)*x1402))+(((-1.0)*x1402*x1408))+(((0.06)*x1404))+(((-1.0)*pz*sj11*x1398))+((cj11*x1406))+(((-1.0)*x1396*x1397*x1402)));
evalcond[4]=((((-0.06)*x1405))+(((-0.117)*x1399))+((sj11*x1406))+((x1399*x1411))+(((0.3215)*sj12))+((pz*x1405))+((x1399*x1408))+(((-1.0)*cj11*j5*x1398))+(((-1.0)*sj11*x1395*x1397)));
evalcond[5]=((-0.03783075)+(((0.12)*pz))+(((-1.0)*(j5*j5)))+((j5*x1400))+(((0.234)*x1408))+(((0.234)*x1411))+(((0.04224)*sj10))+(((-1.0)*pp))+(((-0.082368)*cj10))+(((0.704)*cj10*x1408))+(((0.704)*py*x1410))+(((-1.0)*pz*x1400))+(((-0.12)*j5))+(((2.0)*j5*pz)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}

}
}
}
    }

}

}
}
return solutions.GetNumSolutions()>0;
}
inline void rotationfunction0(IkSolutionListBase<IkReal>& solutions) {
for(int rotationiter = 0; rotationiter < 1; ++rotationiter) {
IkReal x252=((1.0)*sj10);
IkReal x253=((1.0)*sj12);
IkReal x254=(sj11*sj9);
IkReal x255=(cj10*cj12);
IkReal x256=(cj9*sj11);
IkReal x257=(cj10*sj11);
IkReal x258=((1.0)*cj11);
IkReal x259=((((-1.0)*x255*x258))+((sj10*sj12)));
IkReal x260=(((sj10*x254))+((cj11*cj9)));
IkReal x261=(((sj10*x256))+(((-1.0)*sj9*x258)));
IkReal x262=(x255+(((-1.0)*cj11*sj12*x252)));
IkReal x263=(cj9*x262);
IkReal x264=((((-1.0)*cj10*x253))+(((-1.0)*cj11*cj12*x252)));
IkReal x265=((((-1.0)*cj10*cj11*x253))+(((-1.0)*cj12*x252)));
IkReal x266=(cj9*x264);
IkReal x267=(((sj12*x256))+((sj9*x262)));
IkReal x268=((((-1.0)*sj12*x254))+x263);
IkReal x269=(((cj12*x256))+((sj9*x264)));
IkReal x270=(x266+(((-1.0)*cj12*x254)));
new_r00=(((r20*x259))+((r00*((x266+(((-1.0)*cj12*x254))))))+((r10*x269)));
new_r01=(((r21*x259))+((r01*x270))+((r11*x269)));
new_r02=(((r02*x270))+((r12*x269))+((r22*x259)));
new_r10=(((r20*x257))+((r00*x261))+((r10*x260)));
new_r11=(((r21*x257))+((r11*x260))+((r01*x261)));
new_r12=(((r02*x261))+((r12*x260))+((r22*x257)));
new_r20=(((r00*x268))+((r10*x267))+((r20*x265)));
new_r21=(((r21*x265))+((r11*x267))+((r01*((x263+(((-1.0)*x253*x254)))))));
new_r22=(((r22*x265))+((r02*x268))+((r12*x267)));
{
IkReal j14array[2], cj14array[2], sj14array[2];
bool j14valid[2]={false};
_nj14 = 2;
cj14array[0]=new_r22;
if( cj14array[0] >= -1-IKFAST_SINCOS_THRESH && cj14array[0] <= 1+IKFAST_SINCOS_THRESH )
{
    j14valid[0] = j14valid[1] = true;
    j14array[0] = IKacos(cj14array[0]);
    sj14array[0] = IKsin(j14array[0]);
    cj14array[1] = cj14array[0];
    j14array[1] = -j14array[0];
    sj14array[1] = -sj14array[0];
}
else if( isnan(cj14array[0]) )
{
    // probably any value will work
    j14valid[0] = true;
    cj14array[0] = 1; sj14array[0] = 0; j14array[0] = 0;
}
for(int ij14 = 0; ij14 < 2; ++ij14)
{
if( !j14valid[ij14] )
{
    continue;
}
_ij14[0] = ij14; _ij14[1] = -1;
for(int iij14 = ij14+1; iij14 < 2; ++iij14)
{
if( j14valid[iij14] && IKabs(cj14array[ij14]-cj14array[iij14]) < IKFAST_SOLUTION_THRESH && IKabs(sj14array[ij14]-sj14array[iij14]) < IKFAST_SOLUTION_THRESH )
{
    j14valid[iij14]=false; _ij14[1] = iij14; break; 
}
}
j14 = j14array[ij14]; cj14 = cj14array[ij14]; sj14 = sj14array[ij14];

{
IkReal j13eval[3];
j13eval[0]=sj14;
j13eval[1]=IKsign(sj14);
j13eval[2]=((IKabs(new_r12))+(IKabs(new_r02)));
if( IKabs(j13eval[0]) < 0.0000010000000000  || IKabs(j13eval[1]) < 0.0000010000000000  || IKabs(j13eval[2]) < 0.0000010000000000  )
{
{
IkReal j15eval[3];
j15eval[0]=sj14;
j15eval[1]=IKsign(sj14);
j15eval[2]=((IKabs(new_r20))+(IKabs(new_r21)));
if( IKabs(j15eval[0]) < 0.0000010000000000  || IKabs(j15eval[1]) < 0.0000010000000000  || IKabs(j15eval[2]) < 0.0000010000000000  )
{
{
IkReal j13eval[2];
j13eval[0]=new_r12;
j13eval[1]=sj14;
if( IKabs(j13eval[0]) < 0.0000010000000000  || IKabs(j13eval[1]) < 0.0000010000000000  )
{
{
IkReal evalcond[5];
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(j14))), 6.28318530717959)));
evalcond[1]=new_r20;
evalcond[2]=new_r02;
evalcond[3]=new_r12;
evalcond[4]=new_r21;
if( IKabs(evalcond[0]) < 0.0000050000000000  && IKabs(evalcond[1]) < 0.0000050000000000  && IKabs(evalcond[2]) < 0.0000050000000000  && IKabs(evalcond[3]) < 0.0000050000000000  && IKabs(evalcond[4]) < 0.0000050000000000  )
{
bgotonextstatement=false;
IkReal j15mul = 1;
j15=0;
j13mul=-1.0;
if( IKabs(((-1.0)*new_r01)) < IKFAST_ATAN2_MAGTHRESH && IKabs(new_r00) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((-1.0)*new_r01))+IKsqr(new_r00)-1) <= IKFAST_SINCOS_THRESH )
    continue;
j13=IKatan2(((-1.0)*new_r01), new_r00);
{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(8);
vinfos[0].jointtype = 17;
vinfos[0].foffset = j5;
vinfos[0].indices[0] = _ij5[0];
vinfos[0].indices[1] = _ij5[1];
vinfos[0].maxsolutions = _nj5;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j9;
vinfos[1].indices[0] = _ij9[0];
vinfos[1].indices[1] = _ij9[1];
vinfos[1].maxsolutions = _nj9;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j10;
vinfos[2].indices[0] = _ij10[0];
vinfos[2].indices[1] = _ij10[1];
vinfos[2].maxsolutions = _nj10;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j11;
vinfos[3].indices[0] = _ij11[0];
vinfos[3].indices[1] = _ij11[1];
vinfos[3].maxsolutions = _nj11;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j12;
vinfos[4].indices[0] = _ij12[0];
vinfos[4].indices[1] = _ij12[1];
vinfos[4].maxsolutions = _nj12;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j13;
vinfos[5].fmul = j13mul;
vinfos[5].freeind = 0;
vinfos[5].maxsolutions = 0;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j14;
vinfos[6].indices[0] = _ij14[0];
vinfos[6].indices[1] = _ij14[1];
vinfos[6].maxsolutions = _nj14;
vinfos[7].jointtype = 1;
vinfos[7].foffset = j15;
vinfos[7].fmul = j15mul;
vinfos[7].freeind = 0;
vinfos[7].maxsolutions = 0;
std::vector<int> vfree(1);
vfree[0] = 7;
solutions.AddSolution(vinfos,vfree);
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((-3.14159265358979)+j14)))), 6.28318530717959)));
evalcond[1]=new_r20;
evalcond[2]=new_r02;
evalcond[3]=new_r12;
evalcond[4]=new_r21;
if( IKabs(evalcond[0]) < 0.0000050000000000  && IKabs(evalcond[1]) < 0.0000050000000000  && IKabs(evalcond[2]) < 0.0000050000000000  && IKabs(evalcond[3]) < 0.0000050000000000  && IKabs(evalcond[4]) < 0.0000050000000000  )
{
bgotonextstatement=false;
IkReal j15mul = 1;
j15=0;
j13mul=1.0;
if( IKabs(((-1.0)*new_r01)) < IKFAST_ATAN2_MAGTHRESH && IKabs(((-1.0)*new_r00)) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((-1.0)*new_r01))+IKsqr(((-1.0)*new_r00))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j13=IKatan2(((-1.0)*new_r01), ((-1.0)*new_r00));
{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(8);
vinfos[0].jointtype = 17;
vinfos[0].foffset = j5;
vinfos[0].indices[0] = _ij5[0];
vinfos[0].indices[1] = _ij5[1];
vinfos[0].maxsolutions = _nj5;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j9;
vinfos[1].indices[0] = _ij9[0];
vinfos[1].indices[1] = _ij9[1];
vinfos[1].maxsolutions = _nj9;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j10;
vinfos[2].indices[0] = _ij10[0];
vinfos[2].indices[1] = _ij10[1];
vinfos[2].maxsolutions = _nj10;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j11;
vinfos[3].indices[0] = _ij11[0];
vinfos[3].indices[1] = _ij11[1];
vinfos[3].maxsolutions = _nj11;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j12;
vinfos[4].indices[0] = _ij12[0];
vinfos[4].indices[1] = _ij12[1];
vinfos[4].maxsolutions = _nj12;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j13;
vinfos[5].fmul = j13mul;
vinfos[5].freeind = 0;
vinfos[5].maxsolutions = 0;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j14;
vinfos[6].indices[0] = _ij14[0];
vinfos[6].indices[1] = _ij14[1];
vinfos[6].maxsolutions = _nj14;
vinfos[7].jointtype = 1;
vinfos[7].foffset = j15;
vinfos[7].fmul = j15mul;
vinfos[7].freeind = 0;
vinfos[7].maxsolutions = 0;
std::vector<int> vfree(1);
vfree[0] = 7;
solutions.AddSolution(vinfos,vfree);
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((IKabs(new_r12))+(IKabs(new_r02)));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j13eval[1];
new_r02=0;
new_r12=0;
new_r20=0;
new_r21=0;
IkReal x271=new_r22*new_r22;
IkReal x272=((16.0)*new_r10);
IkReal x273=((16.0)*new_r01);
IkReal x274=((16.0)*new_r22);
IkReal x275=((8.0)*new_r11);
IkReal x276=((8.0)*new_r00);
IkReal x277=(x271*x272);
IkReal x278=(x271*x273);
j13eval[0]=((IKabs(((((32.0)*new_r11))+(((-1.0)*new_r00*x274))+(((-16.0)*new_r11*x271)))))+(IKabs((x278+(((-1.0)*x273)))))+(IKabs((((x271*x275))+(((-1.0)*new_r22*x276)))))+(IKabs((x273+(((-1.0)*x278)))))+(IKabs((x272+(((-1.0)*x277)))))+(IKabs((x277+(((-1.0)*x272)))))+(IKabs(((((-32.0)*new_r00*x271))+(((16.0)*new_r00))+((new_r11*x274)))))+(IKabs((((new_r22*x275))+(((-1.0)*x276))))));
if( IKabs(j13eval[0]) < 0.0000000100000000  )
{
continue; // no branches [j13, j15]

} else
{
IkReal op[4+1], zeror[4];
int numroots;
IkReal j13evalpoly[1];
IkReal x279=new_r22*new_r22;
IkReal x280=((16.0)*new_r10);
IkReal x281=(new_r11*new_r22);
IkReal x282=(x279*x280);
IkReal x283=((((8.0)*x281))+(((-8.0)*new_r00)));
op[0]=x283;
op[1]=(x280+(((-1.0)*x282)));
op[2]=((((16.0)*x281))+(((-32.0)*new_r00*x279))+(((16.0)*new_r00)));
op[3]=(x282+(((-1.0)*x280)));
op[4]=x283;
polyroots4(op,zeror,numroots);
IkReal j13array[4], cj13array[4], sj13array[4], tempj13array[1];
int numsolutions = 0;
for(int ij13 = 0; ij13 < numroots; ++ij13)
{
IkReal htj13 = zeror[ij13];
tempj13array[0]=((2.0)*(atan(htj13)));
for(int kj13 = 0; kj13 < 1; ++kj13)
{
j13array[numsolutions] = tempj13array[kj13];
if( j13array[numsolutions] > IKPI )
{
    j13array[numsolutions]-=IK2PI;
}
else if( j13array[numsolutions] < -IKPI )
{
    j13array[numsolutions]+=IK2PI;
}
sj13array[numsolutions] = IKsin(j13array[numsolutions]);
cj13array[numsolutions] = IKcos(j13array[numsolutions]);
numsolutions++;
}
}
bool j13valid[4]={true,true,true,true};
_nj13 = 4;
for(int ij13 = 0; ij13 < numsolutions; ++ij13)
    {
if( !j13valid[ij13] )
{
    continue;
}
    j13 = j13array[ij13]; cj13 = cj13array[ij13]; sj13 = sj13array[ij13];
htj13 = IKtan(j13/2);

IkReal x284=((16.0)*new_r01);
IkReal x285=new_r22*new_r22;
IkReal x286=(new_r00*new_r22);
IkReal x287=((8.0)*x286);
IkReal x288=(new_r11*x285);
IkReal x289=(x284*x285);
IkReal x290=((8.0)*x288);
j13evalpoly[0]=((((htj13*htj13*htj13)*((x289+(((-1.0)*x284))))))+x290+((htj13*((x284+(((-1.0)*x289))))))+(((-1.0)*x287))+(((htj13*htj13*htj13*htj13)*((x290+(((-1.0)*x287))))))+(((htj13*htj13)*(((((32.0)*new_r11))+(((-16.0)*x286))+(((-16.0)*x288)))))));
if( IKabs(j13evalpoly[0]) > 0.0000001000000000  )
{
    continue;
}
_ij13[0] = ij13; _ij13[1] = -1;
for(int iij13 = ij13+1; iij13 < numsolutions; ++iij13)
{
if( j13valid[iij13] && IKabs(cj13array[ij13]-cj13array[iij13]) < IKFAST_SOLUTION_THRESH && IKabs(sj13array[ij13]-sj13array[iij13]) < IKFAST_SOLUTION_THRESH )
{
    j13valid[iij13]=false; _ij13[1] = iij13; break; 
}
}
{
IkReal j15eval[3];
new_r02=0;
new_r12=0;
new_r20=0;
new_r21=0;
IkReal x291=cj13*cj13;
IkReal x292=(cj13*new_r22);
IkReal x293=((-1.0)+(((-1.0)*x291*(new_r22*new_r22)))+x291);
j15eval[0]=x293;
j15eval[1]=((IKabs((((new_r01*x292))+((new_r00*sj13)))))+(IKabs(((((-1.0)*new_r00*x292))+((new_r01*sj13))))));
j15eval[2]=IKsign(x293);
if( IKabs(j15eval[0]) < 0.0000010000000000  || IKabs(j15eval[1]) < 0.0000010000000000  || IKabs(j15eval[2]) < 0.0000010000000000  )
{
{
IkReal j15eval[1];
new_r02=0;
new_r12=0;
new_r20=0;
new_r21=0;
j15eval[0]=new_r22;
if( IKabs(j15eval[0]) < 0.0000010000000000  )
{
{
IkReal j15eval[2];
new_r02=0;
new_r12=0;
new_r20=0;
new_r21=0;
IkReal x294=new_r22*new_r22;
j15eval[0]=(((cj13*x294))+(((-1.0)*cj13)));
j15eval[1]=(((sj13*x294))+(((-1.0)*sj13)));
if( IKabs(j15eval[0]) < 0.0000010000000000  || IKabs(j15eval[1]) < 0.0000010000000000  )
{
{
IkReal evalcond[1];
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((-1.5707963267949)+j13)))), 6.28318530717959)));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j15array[1], cj15array[1], sj15array[1];
bool j15valid[1]={false};
_nj15 = 1;
if( IKabs(((-1.0)*new_r00)) < IKFAST_ATAN2_MAGTHRESH && IKabs(((-1.0)*new_r01)) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((-1.0)*new_r00))+IKsqr(((-1.0)*new_r01))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j15array[0]=IKatan2(((-1.0)*new_r00), ((-1.0)*new_r01));
sj15array[0]=IKsin(j15array[0]);
cj15array[0]=IKcos(j15array[0]);
if( j15array[0] > IKPI )
{
    j15array[0]-=IK2PI;
}
else if( j15array[0] < -IKPI )
{    j15array[0]+=IK2PI;
}
j15valid[0] = true;
for(int ij15 = 0; ij15 < 1; ++ij15)
{
if( !j15valid[ij15] )
{
    continue;
}
_ij15[0] = ij15; _ij15[1] = -1;
for(int iij15 = ij15+1; iij15 < 1; ++iij15)
{
if( j15valid[iij15] && IKabs(cj15array[ij15]-cj15array[iij15]) < IKFAST_SOLUTION_THRESH && IKabs(sj15array[ij15]-sj15array[iij15]) < IKFAST_SOLUTION_THRESH )
{
    j15valid[iij15]=false; _ij15[1] = iij15; break; 
}
}
j15 = j15array[ij15]; cj15 = cj15array[ij15]; sj15 = sj15array[ij15];
{
IkReal evalcond[4];
IkReal x295=IKsin(j15);
IkReal x296=IKcos(j15);
evalcond[0]=x295;
evalcond[1]=((-1.0)*x296);
evalcond[2]=((((-1.0)*x295))+(((-1.0)*new_r00)));
evalcond[3]=((((-1.0)*x296))+(((-1.0)*new_r01)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(8);
vinfos[0].jointtype = 17;
vinfos[0].foffset = j5;
vinfos[0].indices[0] = _ij5[0];
vinfos[0].indices[1] = _ij5[1];
vinfos[0].maxsolutions = _nj5;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j9;
vinfos[1].indices[0] = _ij9[0];
vinfos[1].indices[1] = _ij9[1];
vinfos[1].maxsolutions = _nj9;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j10;
vinfos[2].indices[0] = _ij10[0];
vinfos[2].indices[1] = _ij10[1];
vinfos[2].maxsolutions = _nj10;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j11;
vinfos[3].indices[0] = _ij11[0];
vinfos[3].indices[1] = _ij11[1];
vinfos[3].maxsolutions = _nj11;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j12;
vinfos[4].indices[0] = _ij12[0];
vinfos[4].indices[1] = _ij12[1];
vinfos[4].maxsolutions = _nj12;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j13;
vinfos[5].indices[0] = _ij13[0];
vinfos[5].indices[1] = _ij13[1];
vinfos[5].maxsolutions = _nj13;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j14;
vinfos[6].indices[0] = _ij14[0];
vinfos[6].indices[1] = _ij14[1];
vinfos[6].maxsolutions = _nj14;
vinfos[7].jointtype = 1;
vinfos[7].foffset = j15;
vinfos[7].indices[0] = _ij15[0];
vinfos[7].indices[1] = _ij15[1];
vinfos[7].maxsolutions = _nj15;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((1.5707963267949)+j13)))), 6.28318530717959)));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j15array[1], cj15array[1], sj15array[1];
bool j15valid[1]={false};
_nj15 = 1;
if( IKabs(new_r00) < IKFAST_ATAN2_MAGTHRESH && IKabs(new_r01) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(new_r00)+IKsqr(new_r01)-1) <= IKFAST_SINCOS_THRESH )
    continue;
j15array[0]=IKatan2(new_r00, new_r01);
sj15array[0]=IKsin(j15array[0]);
cj15array[0]=IKcos(j15array[0]);
if( j15array[0] > IKPI )
{
    j15array[0]-=IK2PI;
}
else if( j15array[0] < -IKPI )
{    j15array[0]+=IK2PI;
}
j15valid[0] = true;
for(int ij15 = 0; ij15 < 1; ++ij15)
{
if( !j15valid[ij15] )
{
    continue;
}
_ij15[0] = ij15; _ij15[1] = -1;
for(int iij15 = ij15+1; iij15 < 1; ++iij15)
{
if( j15valid[iij15] && IKabs(cj15array[ij15]-cj15array[iij15]) < IKFAST_SOLUTION_THRESH && IKabs(sj15array[ij15]-sj15array[iij15]) < IKFAST_SOLUTION_THRESH )
{
    j15valid[iij15]=false; _ij15[1] = iij15; break; 
}
}
j15 = j15array[ij15]; cj15 = cj15array[ij15]; sj15 = sj15array[ij15];
{
IkReal evalcond[4];
IkReal x297=IKsin(j15);
IkReal x298=IKcos(j15);
evalcond[0]=x297;
evalcond[1]=((-1.0)*x298);
evalcond[2]=((((-1.0)*x297))+new_r00);
evalcond[3]=((((-1.0)*x298))+new_r01);
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(8);
vinfos[0].jointtype = 17;
vinfos[0].foffset = j5;
vinfos[0].indices[0] = _ij5[0];
vinfos[0].indices[1] = _ij5[1];
vinfos[0].maxsolutions = _nj5;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j9;
vinfos[1].indices[0] = _ij9[0];
vinfos[1].indices[1] = _ij9[1];
vinfos[1].maxsolutions = _nj9;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j10;
vinfos[2].indices[0] = _ij10[0];
vinfos[2].indices[1] = _ij10[1];
vinfos[2].maxsolutions = _nj10;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j11;
vinfos[3].indices[0] = _ij11[0];
vinfos[3].indices[1] = _ij11[1];
vinfos[3].maxsolutions = _nj11;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j12;
vinfos[4].indices[0] = _ij12[0];
vinfos[4].indices[1] = _ij12[1];
vinfos[4].maxsolutions = _nj12;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j13;
vinfos[5].indices[0] = _ij13[0];
vinfos[5].indices[1] = _ij13[1];
vinfos[5].maxsolutions = _nj13;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j14;
vinfos[6].indices[0] = _ij14[0];
vinfos[6].indices[1] = _ij14[1];
vinfos[6].maxsolutions = _nj14;
vinfos[7].jointtype = 1;
vinfos[7].foffset = j15;
vinfos[7].indices[0] = _ij15[0];
vinfos[7].indices[1] = _ij15[1];
vinfos[7].maxsolutions = _nj15;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(j13))), 6.28318530717959)));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j15array[1], cj15array[1], sj15array[1];
bool j15valid[1]={false};
_nj15 = 1;
if( IKabs(new_r10) < IKFAST_ATAN2_MAGTHRESH && IKabs(new_r11) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(new_r10)+IKsqr(new_r11)-1) <= IKFAST_SINCOS_THRESH )
    continue;
j15array[0]=IKatan2(new_r10, new_r11);
sj15array[0]=IKsin(j15array[0]);
cj15array[0]=IKcos(j15array[0]);
if( j15array[0] > IKPI )
{
    j15array[0]-=IK2PI;
}
else if( j15array[0] < -IKPI )
{    j15array[0]+=IK2PI;
}
j15valid[0] = true;
for(int ij15 = 0; ij15 < 1; ++ij15)
{
if( !j15valid[ij15] )
{
    continue;
}
_ij15[0] = ij15; _ij15[1] = -1;
for(int iij15 = ij15+1; iij15 < 1; ++iij15)
{
if( j15valid[iij15] && IKabs(cj15array[ij15]-cj15array[iij15]) < IKFAST_SOLUTION_THRESH && IKabs(sj15array[ij15]-sj15array[iij15]) < IKFAST_SOLUTION_THRESH )
{
    j15valid[iij15]=false; _ij15[1] = iij15; break; 
}
}
j15 = j15array[ij15]; cj15 = cj15array[ij15]; sj15 = sj15array[ij15];
{
IkReal evalcond[4];
IkReal x299=IKsin(j15);
IkReal x300=IKcos(j15);
evalcond[0]=x299;
evalcond[1]=((-1.0)*x300);
evalcond[2]=((((-1.0)*x299))+new_r10);
evalcond[3]=((((-1.0)*x300))+new_r11);
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(8);
vinfos[0].jointtype = 17;
vinfos[0].foffset = j5;
vinfos[0].indices[0] = _ij5[0];
vinfos[0].indices[1] = _ij5[1];
vinfos[0].maxsolutions = _nj5;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j9;
vinfos[1].indices[0] = _ij9[0];
vinfos[1].indices[1] = _ij9[1];
vinfos[1].maxsolutions = _nj9;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j10;
vinfos[2].indices[0] = _ij10[0];
vinfos[2].indices[1] = _ij10[1];
vinfos[2].maxsolutions = _nj10;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j11;
vinfos[3].indices[0] = _ij11[0];
vinfos[3].indices[1] = _ij11[1];
vinfos[3].maxsolutions = _nj11;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j12;
vinfos[4].indices[0] = _ij12[0];
vinfos[4].indices[1] = _ij12[1];
vinfos[4].maxsolutions = _nj12;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j13;
vinfos[5].indices[0] = _ij13[0];
vinfos[5].indices[1] = _ij13[1];
vinfos[5].maxsolutions = _nj13;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j14;
vinfos[6].indices[0] = _ij14[0];
vinfos[6].indices[1] = _ij14[1];
vinfos[6].maxsolutions = _nj14;
vinfos[7].jointtype = 1;
vinfos[7].foffset = j15;
vinfos[7].indices[0] = _ij15[0];
vinfos[7].indices[1] = _ij15[1];
vinfos[7].maxsolutions = _nj15;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((-3.14159265358979)+j13)))), 6.28318530717959)));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j15array[1], cj15array[1], sj15array[1];
bool j15valid[1]={false};
_nj15 = 1;
if( IKabs(((-1.0)*new_r10)) < IKFAST_ATAN2_MAGTHRESH && IKabs(((-1.0)*new_r11)) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((-1.0)*new_r10))+IKsqr(((-1.0)*new_r11))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j15array[0]=IKatan2(((-1.0)*new_r10), ((-1.0)*new_r11));
sj15array[0]=IKsin(j15array[0]);
cj15array[0]=IKcos(j15array[0]);
if( j15array[0] > IKPI )
{
    j15array[0]-=IK2PI;
}
else if( j15array[0] < -IKPI )
{    j15array[0]+=IK2PI;
}
j15valid[0] = true;
for(int ij15 = 0; ij15 < 1; ++ij15)
{
if( !j15valid[ij15] )
{
    continue;
}
_ij15[0] = ij15; _ij15[1] = -1;
for(int iij15 = ij15+1; iij15 < 1; ++iij15)
{
if( j15valid[iij15] && IKabs(cj15array[ij15]-cj15array[iij15]) < IKFAST_SOLUTION_THRESH && IKabs(sj15array[ij15]-sj15array[iij15]) < IKFAST_SOLUTION_THRESH )
{
    j15valid[iij15]=false; _ij15[1] = iij15; break; 
}
}
j15 = j15array[ij15]; cj15 = cj15array[ij15]; sj15 = sj15array[ij15];
{
IkReal evalcond[4];
IkReal x301=IKsin(j15);
IkReal x302=IKcos(j15);
evalcond[0]=x301;
evalcond[1]=((-1.0)*x302);
evalcond[2]=((((-1.0)*x301))+(((-1.0)*new_r10)));
evalcond[3]=((((-1.0)*x302))+(((-1.0)*new_r11)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(8);
vinfos[0].jointtype = 17;
vinfos[0].foffset = j5;
vinfos[0].indices[0] = _ij5[0];
vinfos[0].indices[1] = _ij5[1];
vinfos[0].maxsolutions = _nj5;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j9;
vinfos[1].indices[0] = _ij9[0];
vinfos[1].indices[1] = _ij9[1];
vinfos[1].maxsolutions = _nj9;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j10;
vinfos[2].indices[0] = _ij10[0];
vinfos[2].indices[1] = _ij10[1];
vinfos[2].maxsolutions = _nj10;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j11;
vinfos[3].indices[0] = _ij11[0];
vinfos[3].indices[1] = _ij11[1];
vinfos[3].maxsolutions = _nj11;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j12;
vinfos[4].indices[0] = _ij12[0];
vinfos[4].indices[1] = _ij12[1];
vinfos[4].maxsolutions = _nj12;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j13;
vinfos[5].indices[0] = _ij13[0];
vinfos[5].indices[1] = _ij13[1];
vinfos[5].maxsolutions = _nj13;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j14;
vinfos[6].indices[0] = _ij14[0];
vinfos[6].indices[1] = _ij14[1];
vinfos[6].maxsolutions = _nj14;
vinfos[7].jointtype = 1;
vinfos[7].foffset = j15;
vinfos[7].indices[0] = _ij15[0];
vinfos[7].indices[1] = _ij15[1];
vinfos[7].maxsolutions = _nj15;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
CheckValue<IkReal> x303=IKPowWithIntegerCheck(((1.0)+(((-1.0)*(new_r22*new_r22)))),-1);
if(!x303.valid){
continue;
}
if((x303.value) < -0.00001)
continue;
IkReal gconst24=((-1.0)*(IKsqrt(x303.value)));
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs((cj13+(((-1.0)*gconst24)))))+(IKabs(((-1.0)+(IKsign(sj13)))))), 6.28318530717959)));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j15eval[1];
new_r02=0;
new_r12=0;
new_r20=0;
new_r21=0;
if((((1.0)+(((-1.0)*(gconst24*gconst24))))) < -0.00001)
continue;
sj13=IKsqrt(((1.0)+(((-1.0)*(gconst24*gconst24)))));
cj13=gconst24;
if( (gconst24) < -1-IKFAST_SINCOS_THRESH || (gconst24) > 1+IKFAST_SINCOS_THRESH )
    continue;
j13=IKacos(gconst24);
CheckValue<IkReal> x304=IKPowWithIntegerCheck(((1.0)+(((-1.0)*(new_r22*new_r22)))),-1);
if(!x304.valid){
continue;
}
if((x304.value) < -0.00001)
continue;
IkReal gconst24=((-1.0)*(IKsqrt(x304.value)));
j15eval[0]=((IKabs(new_r11))+(IKabs(new_r10)));
if( IKabs(j15eval[0]) < 0.0000010000000000  )
{
{
IkReal j15array[1], cj15array[1], sj15array[1];
bool j15valid[1]={false};
_nj15 = 1;
if((((1.0)+(((-1.0)*(gconst24*gconst24))))) < -0.00001)
continue;
CheckValue<IkReal> x305=IKPowWithIntegerCheck(gconst24,-1);
if(!x305.valid){
continue;
}
if( IKabs(((((-1.0)*new_r00*(IKsqrt(((1.0)+(((-1.0)*(gconst24*gconst24))))))))+((gconst24*new_r10)))) < IKFAST_ATAN2_MAGTHRESH && IKabs((new_r11*(x305.value))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((((-1.0)*new_r00*(IKsqrt(((1.0)+(((-1.0)*(gconst24*gconst24))))))))+((gconst24*new_r10))))+IKsqr((new_r11*(x305.value)))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j15array[0]=IKatan2(((((-1.0)*new_r00*(IKsqrt(((1.0)+(((-1.0)*(gconst24*gconst24))))))))+((gconst24*new_r10))), (new_r11*(x305.value)));
sj15array[0]=IKsin(j15array[0]);
cj15array[0]=IKcos(j15array[0]);
if( j15array[0] > IKPI )
{
    j15array[0]-=IK2PI;
}
else if( j15array[0] < -IKPI )
{    j15array[0]+=IK2PI;
}
j15valid[0] = true;
for(int ij15 = 0; ij15 < 1; ++ij15)
{
if( !j15valid[ij15] )
{
    continue;
}
_ij15[0] = ij15; _ij15[1] = -1;
for(int iij15 = ij15+1; iij15 < 1; ++iij15)
{
if( j15valid[iij15] && IKabs(cj15array[ij15]-cj15array[iij15]) < IKFAST_SOLUTION_THRESH && IKabs(sj15array[ij15]-sj15array[iij15]) < IKFAST_SOLUTION_THRESH )
{
    j15valid[iij15]=false; _ij15[1] = iij15; break; 
}
}
j15 = j15array[ij15]; cj15 = cj15array[ij15]; sj15 = sj15array[ij15];
{
IkReal evalcond[8];
IkReal x306=IKcos(j15);
IkReal x307=IKsin(j15);
IkReal x308=((1.0)*x306);
IkReal x309=((1.0)*x307);
if((((1.0)+(((-1.0)*(gconst24*gconst24))))) < -0.00001)
continue;
IkReal x310=IKsqrt(((1.0)+(((-1.0)*(gconst24*gconst24)))));
IkReal x311=((1.0)*x310);
evalcond[0]=x307;
evalcond[1]=((-1.0)*x306);
evalcond[2]=((((-1.0)*gconst24*x308))+new_r11);
evalcond[3]=((((-1.0)*gconst24*x309))+new_r10);
evalcond[4]=(((x306*x310))+new_r01);
evalcond[5]=(((x307*x310))+new_r00);
evalcond[6]=((((-1.0)*new_r00*x311))+((gconst24*new_r10))+(((-1.0)*x309)));
evalcond[7]=(((gconst24*new_r11))+(((-1.0)*new_r01*x311))+(((-1.0)*x308)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(8);
vinfos[0].jointtype = 17;
vinfos[0].foffset = j5;
vinfos[0].indices[0] = _ij5[0];
vinfos[0].indices[1] = _ij5[1];
vinfos[0].maxsolutions = _nj5;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j9;
vinfos[1].indices[0] = _ij9[0];
vinfos[1].indices[1] = _ij9[1];
vinfos[1].maxsolutions = _nj9;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j10;
vinfos[2].indices[0] = _ij10[0];
vinfos[2].indices[1] = _ij10[1];
vinfos[2].maxsolutions = _nj10;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j11;
vinfos[3].indices[0] = _ij11[0];
vinfos[3].indices[1] = _ij11[1];
vinfos[3].maxsolutions = _nj11;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j12;
vinfos[4].indices[0] = _ij12[0];
vinfos[4].indices[1] = _ij12[1];
vinfos[4].maxsolutions = _nj12;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j13;
vinfos[5].indices[0] = _ij13[0];
vinfos[5].indices[1] = _ij13[1];
vinfos[5].maxsolutions = _nj13;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j14;
vinfos[6].indices[0] = _ij14[0];
vinfos[6].indices[1] = _ij14[1];
vinfos[6].maxsolutions = _nj14;
vinfos[7].jointtype = 1;
vinfos[7].foffset = j15;
vinfos[7].indices[0] = _ij15[0];
vinfos[7].indices[1] = _ij15[1];
vinfos[7].maxsolutions = _nj15;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

} else
{
{
IkReal j15array[1], cj15array[1], sj15array[1];
bool j15valid[1]={false};
_nj15 = 1;
CheckValue<IkReal> x312=IKPowWithIntegerCheck(IKsign(gconst24),-1);
if(!x312.valid){
continue;
}
CheckValue<IkReal> x313 = IKatan2WithCheck(IkReal(new_r10),IkReal(new_r11),IKFAST_ATAN2_MAGTHRESH);
if(!x313.valid){
continue;
}
j15array[0]=((-1.5707963267949)+(((1.5707963267949)*(x312.value)))+(x313.value));
sj15array[0]=IKsin(j15array[0]);
cj15array[0]=IKcos(j15array[0]);
if( j15array[0] > IKPI )
{
    j15array[0]-=IK2PI;
}
else if( j15array[0] < -IKPI )
{    j15array[0]+=IK2PI;
}
j15valid[0] = true;
for(int ij15 = 0; ij15 < 1; ++ij15)
{
if( !j15valid[ij15] )
{
    continue;
}
_ij15[0] = ij15; _ij15[1] = -1;
for(int iij15 = ij15+1; iij15 < 1; ++iij15)
{
if( j15valid[iij15] && IKabs(cj15array[ij15]-cj15array[iij15]) < IKFAST_SOLUTION_THRESH && IKabs(sj15array[ij15]-sj15array[iij15]) < IKFAST_SOLUTION_THRESH )
{
    j15valid[iij15]=false; _ij15[1] = iij15; break; 
}
}
j15 = j15array[ij15]; cj15 = cj15array[ij15]; sj15 = sj15array[ij15];
{
IkReal evalcond[8];
IkReal x314=IKcos(j15);
IkReal x315=IKsin(j15);
IkReal x316=((1.0)*x314);
IkReal x317=((1.0)*x315);
if((((1.0)+(((-1.0)*(gconst24*gconst24))))) < -0.00001)
continue;
IkReal x318=IKsqrt(((1.0)+(((-1.0)*(gconst24*gconst24)))));
IkReal x319=((1.0)*x318);
evalcond[0]=x315;
evalcond[1]=((-1.0)*x314);
evalcond[2]=(new_r11+(((-1.0)*gconst24*x316)));
evalcond[3]=(new_r10+(((-1.0)*gconst24*x317)));
evalcond[4]=(new_r01+((x314*x318)));
evalcond[5]=(((x315*x318))+new_r00);
evalcond[6]=((((-1.0)*new_r00*x319))+(((-1.0)*x317))+((gconst24*new_r10)));
evalcond[7]=((((-1.0)*x316))+((gconst24*new_r11))+(((-1.0)*new_r01*x319)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(8);
vinfos[0].jointtype = 17;
vinfos[0].foffset = j5;
vinfos[0].indices[0] = _ij5[0];
vinfos[0].indices[1] = _ij5[1];
vinfos[0].maxsolutions = _nj5;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j9;
vinfos[1].indices[0] = _ij9[0];
vinfos[1].indices[1] = _ij9[1];
vinfos[1].maxsolutions = _nj9;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j10;
vinfos[2].indices[0] = _ij10[0];
vinfos[2].indices[1] = _ij10[1];
vinfos[2].maxsolutions = _nj10;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j11;
vinfos[3].indices[0] = _ij11[0];
vinfos[3].indices[1] = _ij11[1];
vinfos[3].maxsolutions = _nj11;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j12;
vinfos[4].indices[0] = _ij12[0];
vinfos[4].indices[1] = _ij12[1];
vinfos[4].maxsolutions = _nj12;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j13;
vinfos[5].indices[0] = _ij13[0];
vinfos[5].indices[1] = _ij13[1];
vinfos[5].maxsolutions = _nj13;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j14;
vinfos[6].indices[0] = _ij14[0];
vinfos[6].indices[1] = _ij14[1];
vinfos[6].maxsolutions = _nj14;
vinfos[7].jointtype = 1;
vinfos[7].foffset = j15;
vinfos[7].indices[0] = _ij15[0];
vinfos[7].indices[1] = _ij15[1];
vinfos[7].maxsolutions = _nj15;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
CheckValue<IkReal> x320=IKPowWithIntegerCheck(((1.0)+(((-1.0)*(new_r22*new_r22)))),-1);
if(!x320.valid){
continue;
}
if((x320.value) < -0.00001)
continue;
IkReal gconst24=((-1.0)*(IKsqrt(x320.value)));
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((1.0)+(IKsign(sj13)))))+(IKabs((cj13+(((-1.0)*gconst24)))))), 6.28318530717959)));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j15eval[1];
new_r02=0;
new_r12=0;
new_r20=0;
new_r21=0;
if((((1.0)+(((-1.0)*(gconst24*gconst24))))) < -0.00001)
continue;
sj13=((-1.0)*(IKsqrt(((1.0)+(((-1.0)*(gconst24*gconst24)))))));
cj13=gconst24;
if( (gconst24) < -1-IKFAST_SINCOS_THRESH || (gconst24) > 1+IKFAST_SINCOS_THRESH )
    continue;
j13=((-1.0)*(IKacos(gconst24)));
CheckValue<IkReal> x321=IKPowWithIntegerCheck(((1.0)+(((-1.0)*(new_r22*new_r22)))),-1);
if(!x321.valid){
continue;
}
if((x321.value) < -0.00001)
continue;
IkReal gconst24=((-1.0)*(IKsqrt(x321.value)));
j15eval[0]=((IKabs(new_r11))+(IKabs(new_r10)));
if( IKabs(j15eval[0]) < 0.0000010000000000  )
{
{
IkReal j15array[1], cj15array[1], sj15array[1];
bool j15valid[1]={false};
_nj15 = 1;
if((((1.0)+(((-1.0)*(gconst24*gconst24))))) < -0.00001)
continue;
CheckValue<IkReal> x322=IKPowWithIntegerCheck(gconst24,-1);
if(!x322.valid){
continue;
}
if( IKabs((((new_r00*(IKsqrt(((1.0)+(((-1.0)*(gconst24*gconst24))))))))+((gconst24*new_r10)))) < IKFAST_ATAN2_MAGTHRESH && IKabs((new_r11*(x322.value))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr((((new_r00*(IKsqrt(((1.0)+(((-1.0)*(gconst24*gconst24))))))))+((gconst24*new_r10))))+IKsqr((new_r11*(x322.value)))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j15array[0]=IKatan2((((new_r00*(IKsqrt(((1.0)+(((-1.0)*(gconst24*gconst24))))))))+((gconst24*new_r10))), (new_r11*(x322.value)));
sj15array[0]=IKsin(j15array[0]);
cj15array[0]=IKcos(j15array[0]);
if( j15array[0] > IKPI )
{
    j15array[0]-=IK2PI;
}
else if( j15array[0] < -IKPI )
{    j15array[0]+=IK2PI;
}
j15valid[0] = true;
for(int ij15 = 0; ij15 < 1; ++ij15)
{
if( !j15valid[ij15] )
{
    continue;
}
_ij15[0] = ij15; _ij15[1] = -1;
for(int iij15 = ij15+1; iij15 < 1; ++iij15)
{
if( j15valid[iij15] && IKabs(cj15array[ij15]-cj15array[iij15]) < IKFAST_SOLUTION_THRESH && IKabs(sj15array[ij15]-sj15array[iij15]) < IKFAST_SOLUTION_THRESH )
{
    j15valid[iij15]=false; _ij15[1] = iij15; break; 
}
}
j15 = j15array[ij15]; cj15 = cj15array[ij15]; sj15 = sj15array[ij15];
{
IkReal evalcond[8];
IkReal x323=IKcos(j15);
IkReal x324=IKsin(j15);
IkReal x325=((1.0)*x323);
IkReal x326=((1.0)*x324);
if((((1.0)+(((-1.0)*(gconst24*gconst24))))) < -0.00001)
continue;
IkReal x327=IKsqrt(((1.0)+(((-1.0)*(gconst24*gconst24)))));
evalcond[0]=x324;
evalcond[1]=((-1.0)*x323);
evalcond[2]=((((-1.0)*gconst24*x325))+new_r11);
evalcond[3]=((((-1.0)*gconst24*x326))+new_r10);
evalcond[4]=((((-1.0)*x325*x327))+new_r01);
evalcond[5]=((((-1.0)*x326*x327))+new_r00);
evalcond[6]=(((new_r00*x327))+(((-1.0)*x326))+((gconst24*new_r10)));
evalcond[7]=(((new_r01*x327))+(((-1.0)*x325))+((gconst24*new_r11)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(8);
vinfos[0].jointtype = 17;
vinfos[0].foffset = j5;
vinfos[0].indices[0] = _ij5[0];
vinfos[0].indices[1] = _ij5[1];
vinfos[0].maxsolutions = _nj5;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j9;
vinfos[1].indices[0] = _ij9[0];
vinfos[1].indices[1] = _ij9[1];
vinfos[1].maxsolutions = _nj9;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j10;
vinfos[2].indices[0] = _ij10[0];
vinfos[2].indices[1] = _ij10[1];
vinfos[2].maxsolutions = _nj10;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j11;
vinfos[3].indices[0] = _ij11[0];
vinfos[3].indices[1] = _ij11[1];
vinfos[3].maxsolutions = _nj11;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j12;
vinfos[4].indices[0] = _ij12[0];
vinfos[4].indices[1] = _ij12[1];
vinfos[4].maxsolutions = _nj12;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j13;
vinfos[5].indices[0] = _ij13[0];
vinfos[5].indices[1] = _ij13[1];
vinfos[5].maxsolutions = _nj13;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j14;
vinfos[6].indices[0] = _ij14[0];
vinfos[6].indices[1] = _ij14[1];
vinfos[6].maxsolutions = _nj14;
vinfos[7].jointtype = 1;
vinfos[7].foffset = j15;
vinfos[7].indices[0] = _ij15[0];
vinfos[7].indices[1] = _ij15[1];
vinfos[7].maxsolutions = _nj15;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

} else
{
{
IkReal j15array[1], cj15array[1], sj15array[1];
bool j15valid[1]={false};
_nj15 = 1;
CheckValue<IkReal> x328=IKPowWithIntegerCheck(IKsign(gconst24),-1);
if(!x328.valid){
continue;
}
CheckValue<IkReal> x329 = IKatan2WithCheck(IkReal(new_r10),IkReal(new_r11),IKFAST_ATAN2_MAGTHRESH);
if(!x329.valid){
continue;
}
j15array[0]=((-1.5707963267949)+(((1.5707963267949)*(x328.value)))+(x329.value));
sj15array[0]=IKsin(j15array[0]);
cj15array[0]=IKcos(j15array[0]);
if( j15array[0] > IKPI )
{
    j15array[0]-=IK2PI;
}
else if( j15array[0] < -IKPI )
{    j15array[0]+=IK2PI;
}
j15valid[0] = true;
for(int ij15 = 0; ij15 < 1; ++ij15)
{
if( !j15valid[ij15] )
{
    continue;
}
_ij15[0] = ij15; _ij15[1] = -1;
for(int iij15 = ij15+1; iij15 < 1; ++iij15)
{
if( j15valid[iij15] && IKabs(cj15array[ij15]-cj15array[iij15]) < IKFAST_SOLUTION_THRESH && IKabs(sj15array[ij15]-sj15array[iij15]) < IKFAST_SOLUTION_THRESH )
{
    j15valid[iij15]=false; _ij15[1] = iij15; break; 
}
}
j15 = j15array[ij15]; cj15 = cj15array[ij15]; sj15 = sj15array[ij15];
{
IkReal evalcond[8];
IkReal x330=IKcos(j15);
IkReal x331=IKsin(j15);
IkReal x332=((1.0)*x330);
IkReal x333=((1.0)*x331);
if((((1.0)+(((-1.0)*(gconst24*gconst24))))) < -0.00001)
continue;
IkReal x334=IKsqrt(((1.0)+(((-1.0)*(gconst24*gconst24)))));
evalcond[0]=x331;
evalcond[1]=((-1.0)*x330);
evalcond[2]=((((-1.0)*gconst24*x332))+new_r11);
evalcond[3]=((((-1.0)*gconst24*x333))+new_r10);
evalcond[4]=((((-1.0)*x332*x334))+new_r01);
evalcond[5]=((((-1.0)*x333*x334))+new_r00);
evalcond[6]=(((new_r00*x334))+((gconst24*new_r10))+(((-1.0)*x333)));
evalcond[7]=(((new_r01*x334))+((gconst24*new_r11))+(((-1.0)*x332)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(8);
vinfos[0].jointtype = 17;
vinfos[0].foffset = j5;
vinfos[0].indices[0] = _ij5[0];
vinfos[0].indices[1] = _ij5[1];
vinfos[0].maxsolutions = _nj5;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j9;
vinfos[1].indices[0] = _ij9[0];
vinfos[1].indices[1] = _ij9[1];
vinfos[1].maxsolutions = _nj9;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j10;
vinfos[2].indices[0] = _ij10[0];
vinfos[2].indices[1] = _ij10[1];
vinfos[2].maxsolutions = _nj10;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j11;
vinfos[3].indices[0] = _ij11[0];
vinfos[3].indices[1] = _ij11[1];
vinfos[3].maxsolutions = _nj11;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j12;
vinfos[4].indices[0] = _ij12[0];
vinfos[4].indices[1] = _ij12[1];
vinfos[4].maxsolutions = _nj12;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j13;
vinfos[5].indices[0] = _ij13[0];
vinfos[5].indices[1] = _ij13[1];
vinfos[5].maxsolutions = _nj13;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j14;
vinfos[6].indices[0] = _ij14[0];
vinfos[6].indices[1] = _ij14[1];
vinfos[6].maxsolutions = _nj14;
vinfos[7].jointtype = 1;
vinfos[7].foffset = j15;
vinfos[7].indices[0] = _ij15[0];
vinfos[7].indices[1] = _ij15[1];
vinfos[7].maxsolutions = _nj15;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
CheckValue<IkReal> x335=IKPowWithIntegerCheck(((1.0)+(((-1.0)*(new_r22*new_r22)))),-1);
if(!x335.valid){
continue;
}
if((x335.value) < -0.00001)
continue;
IkReal gconst25=IKsqrt(x335.value);
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs((cj13+(((-1.0)*gconst25)))))+(IKabs(((-1.0)+(IKsign(sj13)))))), 6.28318530717959)));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j15eval[1];
new_r02=0;
new_r12=0;
new_r20=0;
new_r21=0;
if((((1.0)+(((-1.0)*(gconst25*gconst25))))) < -0.00001)
continue;
sj13=IKsqrt(((1.0)+(((-1.0)*(gconst25*gconst25)))));
cj13=gconst25;
if( (gconst25) < -1-IKFAST_SINCOS_THRESH || (gconst25) > 1+IKFAST_SINCOS_THRESH )
    continue;
j13=IKacos(gconst25);
CheckValue<IkReal> x336=IKPowWithIntegerCheck(((1.0)+(((-1.0)*(new_r22*new_r22)))),-1);
if(!x336.valid){
continue;
}
if((x336.value) < -0.00001)
continue;
IkReal gconst25=IKsqrt(x336.value);
j15eval[0]=((IKabs(new_r11))+(IKabs(new_r10)));
if( IKabs(j15eval[0]) < 0.0000010000000000  )
{
{
IkReal j15array[1], cj15array[1], sj15array[1];
bool j15valid[1]={false};
_nj15 = 1;
if((((1.0)+(((-1.0)*(gconst25*gconst25))))) < -0.00001)
continue;
CheckValue<IkReal> x337=IKPowWithIntegerCheck(gconst25,-1);
if(!x337.valid){
continue;
}
if( IKabs((((gconst25*new_r10))+(((-1.0)*new_r00*(IKsqrt(((1.0)+(((-1.0)*(gconst25*gconst25)))))))))) < IKFAST_ATAN2_MAGTHRESH && IKabs((new_r11*(x337.value))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr((((gconst25*new_r10))+(((-1.0)*new_r00*(IKsqrt(((1.0)+(((-1.0)*(gconst25*gconst25))))))))))+IKsqr((new_r11*(x337.value)))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j15array[0]=IKatan2((((gconst25*new_r10))+(((-1.0)*new_r00*(IKsqrt(((1.0)+(((-1.0)*(gconst25*gconst25))))))))), (new_r11*(x337.value)));
sj15array[0]=IKsin(j15array[0]);
cj15array[0]=IKcos(j15array[0]);
if( j15array[0] > IKPI )
{
    j15array[0]-=IK2PI;
}
else if( j15array[0] < -IKPI )
{    j15array[0]+=IK2PI;
}
j15valid[0] = true;
for(int ij15 = 0; ij15 < 1; ++ij15)
{
if( !j15valid[ij15] )
{
    continue;
}
_ij15[0] = ij15; _ij15[1] = -1;
for(int iij15 = ij15+1; iij15 < 1; ++iij15)
{
if( j15valid[iij15] && IKabs(cj15array[ij15]-cj15array[iij15]) < IKFAST_SOLUTION_THRESH && IKabs(sj15array[ij15]-sj15array[iij15]) < IKFAST_SOLUTION_THRESH )
{
    j15valid[iij15]=false; _ij15[1] = iij15; break; 
}
}
j15 = j15array[ij15]; cj15 = cj15array[ij15]; sj15 = sj15array[ij15];
{
IkReal evalcond[8];
IkReal x338=IKcos(j15);
IkReal x339=IKsin(j15);
IkReal x340=((1.0)*gconst25);
if((((1.0)+(((-1.0)*gconst25*x340)))) < -0.00001)
continue;
IkReal x341=IKsqrt(((1.0)+(((-1.0)*gconst25*x340))));
IkReal x342=((1.0)*x341);
evalcond[0]=x339;
evalcond[1]=((-1.0)*x338);
evalcond[2]=(new_r11+(((-1.0)*x338*x340)));
evalcond[3]=(new_r10+(((-1.0)*x339*x340)));
evalcond[4]=(((x338*x341))+new_r01);
evalcond[5]=(new_r00+((x339*x341)));
evalcond[6]=(((gconst25*new_r10))+(((-1.0)*x339))+(((-1.0)*new_r00*x342)));
evalcond[7]=(((gconst25*new_r11))+(((-1.0)*x338))+(((-1.0)*new_r01*x342)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(8);
vinfos[0].jointtype = 17;
vinfos[0].foffset = j5;
vinfos[0].indices[0] = _ij5[0];
vinfos[0].indices[1] = _ij5[1];
vinfos[0].maxsolutions = _nj5;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j9;
vinfos[1].indices[0] = _ij9[0];
vinfos[1].indices[1] = _ij9[1];
vinfos[1].maxsolutions = _nj9;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j10;
vinfos[2].indices[0] = _ij10[0];
vinfos[2].indices[1] = _ij10[1];
vinfos[2].maxsolutions = _nj10;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j11;
vinfos[3].indices[0] = _ij11[0];
vinfos[3].indices[1] = _ij11[1];
vinfos[3].maxsolutions = _nj11;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j12;
vinfos[4].indices[0] = _ij12[0];
vinfos[4].indices[1] = _ij12[1];
vinfos[4].maxsolutions = _nj12;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j13;
vinfos[5].indices[0] = _ij13[0];
vinfos[5].indices[1] = _ij13[1];
vinfos[5].maxsolutions = _nj13;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j14;
vinfos[6].indices[0] = _ij14[0];
vinfos[6].indices[1] = _ij14[1];
vinfos[6].maxsolutions = _nj14;
vinfos[7].jointtype = 1;
vinfos[7].foffset = j15;
vinfos[7].indices[0] = _ij15[0];
vinfos[7].indices[1] = _ij15[1];
vinfos[7].maxsolutions = _nj15;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

} else
{
{
IkReal j15array[1], cj15array[1], sj15array[1];
bool j15valid[1]={false};
_nj15 = 1;
CheckValue<IkReal> x343=IKPowWithIntegerCheck(IKsign(gconst25),-1);
if(!x343.valid){
continue;
}
CheckValue<IkReal> x344 = IKatan2WithCheck(IkReal(new_r10),IkReal(new_r11),IKFAST_ATAN2_MAGTHRESH);
if(!x344.valid){
continue;
}
j15array[0]=((-1.5707963267949)+(((1.5707963267949)*(x343.value)))+(x344.value));
sj15array[0]=IKsin(j15array[0]);
cj15array[0]=IKcos(j15array[0]);
if( j15array[0] > IKPI )
{
    j15array[0]-=IK2PI;
}
else if( j15array[0] < -IKPI )
{    j15array[0]+=IK2PI;
}
j15valid[0] = true;
for(int ij15 = 0; ij15 < 1; ++ij15)
{
if( !j15valid[ij15] )
{
    continue;
}
_ij15[0] = ij15; _ij15[1] = -1;
for(int iij15 = ij15+1; iij15 < 1; ++iij15)
{
if( j15valid[iij15] && IKabs(cj15array[ij15]-cj15array[iij15]) < IKFAST_SOLUTION_THRESH && IKabs(sj15array[ij15]-sj15array[iij15]) < IKFAST_SOLUTION_THRESH )
{
    j15valid[iij15]=false; _ij15[1] = iij15; break; 
}
}
j15 = j15array[ij15]; cj15 = cj15array[ij15]; sj15 = sj15array[ij15];
{
IkReal evalcond[8];
IkReal x345=IKcos(j15);
IkReal x346=IKsin(j15);
IkReal x347=((1.0)*gconst25);
if((((1.0)+(((-1.0)*gconst25*x347)))) < -0.00001)
continue;
IkReal x348=IKsqrt(((1.0)+(((-1.0)*gconst25*x347))));
IkReal x349=((1.0)*x348);
evalcond[0]=x346;
evalcond[1]=((-1.0)*x345);
evalcond[2]=((((-1.0)*x345*x347))+new_r11);
evalcond[3]=((((-1.0)*x346*x347))+new_r10);
evalcond[4]=(((x345*x348))+new_r01);
evalcond[5]=(((x346*x348))+new_r00);
evalcond[6]=(((gconst25*new_r10))+(((-1.0)*new_r00*x349))+(((-1.0)*x346)));
evalcond[7]=(((gconst25*new_r11))+(((-1.0)*new_r01*x349))+(((-1.0)*x345)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(8);
vinfos[0].jointtype = 17;
vinfos[0].foffset = j5;
vinfos[0].indices[0] = _ij5[0];
vinfos[0].indices[1] = _ij5[1];
vinfos[0].maxsolutions = _nj5;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j9;
vinfos[1].indices[0] = _ij9[0];
vinfos[1].indices[1] = _ij9[1];
vinfos[1].maxsolutions = _nj9;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j10;
vinfos[2].indices[0] = _ij10[0];
vinfos[2].indices[1] = _ij10[1];
vinfos[2].maxsolutions = _nj10;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j11;
vinfos[3].indices[0] = _ij11[0];
vinfos[3].indices[1] = _ij11[1];
vinfos[3].maxsolutions = _nj11;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j12;
vinfos[4].indices[0] = _ij12[0];
vinfos[4].indices[1] = _ij12[1];
vinfos[4].maxsolutions = _nj12;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j13;
vinfos[5].indices[0] = _ij13[0];
vinfos[5].indices[1] = _ij13[1];
vinfos[5].maxsolutions = _nj13;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j14;
vinfos[6].indices[0] = _ij14[0];
vinfos[6].indices[1] = _ij14[1];
vinfos[6].maxsolutions = _nj14;
vinfos[7].jointtype = 1;
vinfos[7].foffset = j15;
vinfos[7].indices[0] = _ij15[0];
vinfos[7].indices[1] = _ij15[1];
vinfos[7].maxsolutions = _nj15;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
CheckValue<IkReal> x350=IKPowWithIntegerCheck(((1.0)+(((-1.0)*(new_r22*new_r22)))),-1);
if(!x350.valid){
continue;
}
if((x350.value) < -0.00001)
continue;
IkReal gconst25=IKsqrt(x350.value);
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((1.0)+(IKsign(sj13)))))+(IKabs((cj13+(((-1.0)*gconst25)))))), 6.28318530717959)));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j15eval[1];
new_r02=0;
new_r12=0;
new_r20=0;
new_r21=0;
if((((1.0)+(((-1.0)*(gconst25*gconst25))))) < -0.00001)
continue;
sj13=((-1.0)*(IKsqrt(((1.0)+(((-1.0)*(gconst25*gconst25)))))));
cj13=gconst25;
if( (gconst25) < -1-IKFAST_SINCOS_THRESH || (gconst25) > 1+IKFAST_SINCOS_THRESH )
    continue;
j13=((-1.0)*(IKacos(gconst25)));
CheckValue<IkReal> x351=IKPowWithIntegerCheck(((1.0)+(((-1.0)*(new_r22*new_r22)))),-1);
if(!x351.valid){
continue;
}
if((x351.value) < -0.00001)
continue;
IkReal gconst25=IKsqrt(x351.value);
j15eval[0]=((IKabs(new_r11))+(IKabs(new_r10)));
if( IKabs(j15eval[0]) < 0.0000010000000000  )
{
{
IkReal j15array[1], cj15array[1], sj15array[1];
bool j15valid[1]={false};
_nj15 = 1;
if((((1.0)+(((-1.0)*(gconst25*gconst25))))) < -0.00001)
continue;
CheckValue<IkReal> x352=IKPowWithIntegerCheck(gconst25,-1);
if(!x352.valid){
continue;
}
if( IKabs((((gconst25*new_r10))+((new_r00*(IKsqrt(((1.0)+(((-1.0)*(gconst25*gconst25)))))))))) < IKFAST_ATAN2_MAGTHRESH && IKabs((new_r11*(x352.value))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr((((gconst25*new_r10))+((new_r00*(IKsqrt(((1.0)+(((-1.0)*(gconst25*gconst25))))))))))+IKsqr((new_r11*(x352.value)))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j15array[0]=IKatan2((((gconst25*new_r10))+((new_r00*(IKsqrt(((1.0)+(((-1.0)*(gconst25*gconst25))))))))), (new_r11*(x352.value)));
sj15array[0]=IKsin(j15array[0]);
cj15array[0]=IKcos(j15array[0]);
if( j15array[0] > IKPI )
{
    j15array[0]-=IK2PI;
}
else if( j15array[0] < -IKPI )
{    j15array[0]+=IK2PI;
}
j15valid[0] = true;
for(int ij15 = 0; ij15 < 1; ++ij15)
{
if( !j15valid[ij15] )
{
    continue;
}
_ij15[0] = ij15; _ij15[1] = -1;
for(int iij15 = ij15+1; iij15 < 1; ++iij15)
{
if( j15valid[iij15] && IKabs(cj15array[ij15]-cj15array[iij15]) < IKFAST_SOLUTION_THRESH && IKabs(sj15array[ij15]-sj15array[iij15]) < IKFAST_SOLUTION_THRESH )
{
    j15valid[iij15]=false; _ij15[1] = iij15; break; 
}
}
j15 = j15array[ij15]; cj15 = cj15array[ij15]; sj15 = sj15array[ij15];
{
IkReal evalcond[8];
IkReal x353=IKcos(j15);
IkReal x354=IKsin(j15);
IkReal x355=((1.0)*gconst25);
IkReal x356=((1.0)*x353);
IkReal x357=((1.0)*x354);
if((((1.0)+(((-1.0)*gconst25*x355)))) < -0.00001)
continue;
IkReal x358=IKsqrt(((1.0)+(((-1.0)*gconst25*x355))));
evalcond[0]=x354;
evalcond[1]=((-1.0)*x353);
evalcond[2]=((((-1.0)*x353*x355))+new_r11);
evalcond[3]=(new_r10+(((-1.0)*x354*x355)));
evalcond[4]=((((-1.0)*x356*x358))+new_r01);
evalcond[5]=((((-1.0)*x357*x358))+new_r00);
evalcond[6]=(((gconst25*new_r10))+(((-1.0)*x357))+((new_r00*x358)));
evalcond[7]=(((new_r01*x358))+((gconst25*new_r11))+(((-1.0)*x356)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(8);
vinfos[0].jointtype = 17;
vinfos[0].foffset = j5;
vinfos[0].indices[0] = _ij5[0];
vinfos[0].indices[1] = _ij5[1];
vinfos[0].maxsolutions = _nj5;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j9;
vinfos[1].indices[0] = _ij9[0];
vinfos[1].indices[1] = _ij9[1];
vinfos[1].maxsolutions = _nj9;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j10;
vinfos[2].indices[0] = _ij10[0];
vinfos[2].indices[1] = _ij10[1];
vinfos[2].maxsolutions = _nj10;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j11;
vinfos[3].indices[0] = _ij11[0];
vinfos[3].indices[1] = _ij11[1];
vinfos[3].maxsolutions = _nj11;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j12;
vinfos[4].indices[0] = _ij12[0];
vinfos[4].indices[1] = _ij12[1];
vinfos[4].maxsolutions = _nj12;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j13;
vinfos[5].indices[0] = _ij13[0];
vinfos[5].indices[1] = _ij13[1];
vinfos[5].maxsolutions = _nj13;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j14;
vinfos[6].indices[0] = _ij14[0];
vinfos[6].indices[1] = _ij14[1];
vinfos[6].maxsolutions = _nj14;
vinfos[7].jointtype = 1;
vinfos[7].foffset = j15;
vinfos[7].indices[0] = _ij15[0];
vinfos[7].indices[1] = _ij15[1];
vinfos[7].maxsolutions = _nj15;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

} else
{
{
IkReal j15array[1], cj15array[1], sj15array[1];
bool j15valid[1]={false};
_nj15 = 1;
CheckValue<IkReal> x359=IKPowWithIntegerCheck(IKsign(gconst25),-1);
if(!x359.valid){
continue;
}
CheckValue<IkReal> x360 = IKatan2WithCheck(IkReal(new_r10),IkReal(new_r11),IKFAST_ATAN2_MAGTHRESH);
if(!x360.valid){
continue;
}
j15array[0]=((-1.5707963267949)+(((1.5707963267949)*(x359.value)))+(x360.value));
sj15array[0]=IKsin(j15array[0]);
cj15array[0]=IKcos(j15array[0]);
if( j15array[0] > IKPI )
{
    j15array[0]-=IK2PI;
}
else if( j15array[0] < -IKPI )
{    j15array[0]+=IK2PI;
}
j15valid[0] = true;
for(int ij15 = 0; ij15 < 1; ++ij15)
{
if( !j15valid[ij15] )
{
    continue;
}
_ij15[0] = ij15; _ij15[1] = -1;
for(int iij15 = ij15+1; iij15 < 1; ++iij15)
{
if( j15valid[iij15] && IKabs(cj15array[ij15]-cj15array[iij15]) < IKFAST_SOLUTION_THRESH && IKabs(sj15array[ij15]-sj15array[iij15]) < IKFAST_SOLUTION_THRESH )
{
    j15valid[iij15]=false; _ij15[1] = iij15; break; 
}
}
j15 = j15array[ij15]; cj15 = cj15array[ij15]; sj15 = sj15array[ij15];
{
IkReal evalcond[8];
IkReal x361=IKcos(j15);
IkReal x362=IKsin(j15);
IkReal x363=((1.0)*gconst25);
IkReal x364=((1.0)*x361);
IkReal x365=((1.0)*x362);
if((((1.0)+(((-1.0)*gconst25*x363)))) < -0.00001)
continue;
IkReal x366=IKsqrt(((1.0)+(((-1.0)*gconst25*x363))));
evalcond[0]=x362;
evalcond[1]=((-1.0)*x361);
evalcond[2]=((((-1.0)*x361*x363))+new_r11);
evalcond[3]=((((-1.0)*x362*x363))+new_r10);
evalcond[4]=((((-1.0)*x364*x366))+new_r01);
evalcond[5]=(new_r00+(((-1.0)*x365*x366)));
evalcond[6]=(((gconst25*new_r10))+(((-1.0)*x365))+((new_r00*x366)));
evalcond[7]=(((gconst25*new_r11))+(((-1.0)*x364))+((new_r01*x366)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(8);
vinfos[0].jointtype = 17;
vinfos[0].foffset = j5;
vinfos[0].indices[0] = _ij5[0];
vinfos[0].indices[1] = _ij5[1];
vinfos[0].maxsolutions = _nj5;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j9;
vinfos[1].indices[0] = _ij9[0];
vinfos[1].indices[1] = _ij9[1];
vinfos[1].maxsolutions = _nj9;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j10;
vinfos[2].indices[0] = _ij10[0];
vinfos[2].indices[1] = _ij10[1];
vinfos[2].maxsolutions = _nj10;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j11;
vinfos[3].indices[0] = _ij11[0];
vinfos[3].indices[1] = _ij11[1];
vinfos[3].maxsolutions = _nj11;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j12;
vinfos[4].indices[0] = _ij12[0];
vinfos[4].indices[1] = _ij12[1];
vinfos[4].maxsolutions = _nj12;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j13;
vinfos[5].indices[0] = _ij13[0];
vinfos[5].indices[1] = _ij13[1];
vinfos[5].maxsolutions = _nj13;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j14;
vinfos[6].indices[0] = _ij14[0];
vinfos[6].indices[1] = _ij14[1];
vinfos[6].maxsolutions = _nj14;
vinfos[7].jointtype = 1;
vinfos[7].foffset = j15;
vinfos[7].indices[0] = _ij15[0];
vinfos[7].indices[1] = _ij15[1];
vinfos[7].maxsolutions = _nj15;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
if( 1 )
{
bgotonextstatement=false;
continue; // branch miss [j15]

}
} while(0);
if( bgotonextstatement )
{
}
}
}
}
}
}
}
}
}
}

} else
{
{
IkReal j15array[1], cj15array[1], sj15array[1];
bool j15valid[1]={false};
_nj15 = 1;
IkReal x367=new_r22*new_r22;
CheckValue<IkReal> x368=IKPowWithIntegerCheck((((cj13*x367))+(((-1.0)*cj13))),-1);
if(!x368.valid){
continue;
}
CheckValue<IkReal> x369=IKPowWithIntegerCheck((((sj13*x367))+(((-1.0)*sj13))),-1);
if(!x369.valid){
continue;
}
if( IKabs(((x368.value)*(((((-1.0)*new_r01*new_r22))+(((-1.0)*new_r10)))))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((x369.value)*((((new_r10*new_r22))+new_r01)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((x368.value)*(((((-1.0)*new_r01*new_r22))+(((-1.0)*new_r10))))))+IKsqr(((x369.value)*((((new_r10*new_r22))+new_r01))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j15array[0]=IKatan2(((x368.value)*(((((-1.0)*new_r01*new_r22))+(((-1.0)*new_r10))))), ((x369.value)*((((new_r10*new_r22))+new_r01))));
sj15array[0]=IKsin(j15array[0]);
cj15array[0]=IKcos(j15array[0]);
if( j15array[0] > IKPI )
{
    j15array[0]-=IK2PI;
}
else if( j15array[0] < -IKPI )
{    j15array[0]+=IK2PI;
}
j15valid[0] = true;
for(int ij15 = 0; ij15 < 1; ++ij15)
{
if( !j15valid[ij15] )
{
    continue;
}
_ij15[0] = ij15; _ij15[1] = -1;
for(int iij15 = ij15+1; iij15 < 1; ++iij15)
{
if( j15valid[iij15] && IKabs(cj15array[ij15]-cj15array[iij15]) < IKFAST_SOLUTION_THRESH && IKabs(sj15array[ij15]-sj15array[iij15]) < IKFAST_SOLUTION_THRESH )
{
    j15valid[iij15]=false; _ij15[1] = iij15; break; 
}
}
j15 = j15array[ij15]; cj15 = cj15array[ij15]; sj15 = sj15array[ij15];
{
IkReal evalcond[10];
IkReal x370=IKsin(j15);
IkReal x371=IKcos(j15);
IkReal x372=(cj13*new_r22);
IkReal x373=((1.0)*sj13);
IkReal x374=(new_r22*sj13);
IkReal x375=((1.0)*x371);
IkReal x376=((1.0)*x370);
IkReal x377=(new_r22*x370);
evalcond[0]=(((cj13*new_r01))+x377+((new_r11*sj13)));
evalcond[1]=(((new_r01*x372))+x370+((new_r11*x374)));
evalcond[2]=((((-1.0)*new_r00*x373))+((cj13*new_r10))+(((-1.0)*x376)));
evalcond[3]=(((cj13*new_r11))+(((-1.0)*x375))+(((-1.0)*new_r01*x373)));
evalcond[4]=(((x370*x372))+((sj13*x371))+new_r01);
evalcond[5]=(((cj13*new_r00))+(((-1.0)*new_r22*x375))+((new_r10*sj13)));
evalcond[6]=((((-1.0)*x372*x375))+((sj13*x370))+new_r00);
evalcond[7]=(((x370*x374))+(((-1.0)*cj13*x375))+new_r11);
evalcond[8]=((((-1.0)*x375))+((new_r00*x372))+((new_r10*x374)));
evalcond[9]=((((-1.0)*cj13*x376))+(((-1.0)*new_r22*x371*x373))+new_r10);
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[8]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[9]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(8);
vinfos[0].jointtype = 17;
vinfos[0].foffset = j5;
vinfos[0].indices[0] = _ij5[0];
vinfos[0].indices[1] = _ij5[1];
vinfos[0].maxsolutions = _nj5;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j9;
vinfos[1].indices[0] = _ij9[0];
vinfos[1].indices[1] = _ij9[1];
vinfos[1].maxsolutions = _nj9;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j10;
vinfos[2].indices[0] = _ij10[0];
vinfos[2].indices[1] = _ij10[1];
vinfos[2].maxsolutions = _nj10;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j11;
vinfos[3].indices[0] = _ij11[0];
vinfos[3].indices[1] = _ij11[1];
vinfos[3].maxsolutions = _nj11;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j12;
vinfos[4].indices[0] = _ij12[0];
vinfos[4].indices[1] = _ij12[1];
vinfos[4].maxsolutions = _nj12;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j13;
vinfos[5].indices[0] = _ij13[0];
vinfos[5].indices[1] = _ij13[1];
vinfos[5].maxsolutions = _nj13;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j14;
vinfos[6].indices[0] = _ij14[0];
vinfos[6].indices[1] = _ij14[1];
vinfos[6].maxsolutions = _nj14;
vinfos[7].jointtype = 1;
vinfos[7].foffset = j15;
vinfos[7].indices[0] = _ij15[0];
vinfos[7].indices[1] = _ij15[1];
vinfos[7].maxsolutions = _nj15;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

} else
{
{
IkReal j15array[1], cj15array[1], sj15array[1];
bool j15valid[1]={false};
_nj15 = 1;
IkReal x378=((1.0)*new_r01);
CheckValue<IkReal> x379=IKPowWithIntegerCheck(new_r22,-1);
if(!x379.valid){
continue;
}
if( IKabs(((x379.value)*(((((-1.0)*cj13*x378))+(((-1.0)*new_r11*sj13)))))) < IKFAST_ATAN2_MAGTHRESH && IKabs((((cj13*new_r11))+(((-1.0)*sj13*x378)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((x379.value)*(((((-1.0)*cj13*x378))+(((-1.0)*new_r11*sj13))))))+IKsqr((((cj13*new_r11))+(((-1.0)*sj13*x378))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j15array[0]=IKatan2(((x379.value)*(((((-1.0)*cj13*x378))+(((-1.0)*new_r11*sj13))))), (((cj13*new_r11))+(((-1.0)*sj13*x378))));
sj15array[0]=IKsin(j15array[0]);
cj15array[0]=IKcos(j15array[0]);
if( j15array[0] > IKPI )
{
    j15array[0]-=IK2PI;
}
else if( j15array[0] < -IKPI )
{    j15array[0]+=IK2PI;
}
j15valid[0] = true;
for(int ij15 = 0; ij15 < 1; ++ij15)
{
if( !j15valid[ij15] )
{
    continue;
}
_ij15[0] = ij15; _ij15[1] = -1;
for(int iij15 = ij15+1; iij15 < 1; ++iij15)
{
if( j15valid[iij15] && IKabs(cj15array[ij15]-cj15array[iij15]) < IKFAST_SOLUTION_THRESH && IKabs(sj15array[ij15]-sj15array[iij15]) < IKFAST_SOLUTION_THRESH )
{
    j15valid[iij15]=false; _ij15[1] = iij15; break; 
}
}
j15 = j15array[ij15]; cj15 = cj15array[ij15]; sj15 = sj15array[ij15];
{
IkReal evalcond[10];
IkReal x380=IKsin(j15);
IkReal x381=IKcos(j15);
IkReal x382=(cj13*new_r22);
IkReal x383=((1.0)*sj13);
IkReal x384=(new_r22*sj13);
IkReal x385=((1.0)*x381);
IkReal x386=((1.0)*x380);
IkReal x387=(new_r22*x380);
evalcond[0]=(((cj13*new_r01))+x387+((new_r11*sj13)));
evalcond[1]=(((new_r01*x382))+x380+((new_r11*x384)));
evalcond[2]=(((cj13*new_r10))+(((-1.0)*new_r00*x383))+(((-1.0)*x386)));
evalcond[3]=(((cj13*new_r11))+(((-1.0)*new_r01*x383))+(((-1.0)*x385)));
evalcond[4]=(new_r01+((sj13*x381))+((x380*x382)));
evalcond[5]=(((cj13*new_r00))+((new_r10*sj13))+(((-1.0)*new_r22*x385)));
evalcond[6]=(new_r00+((sj13*x380))+(((-1.0)*x382*x385)));
evalcond[7]=((((-1.0)*cj13*x385))+new_r11+((x380*x384)));
evalcond[8]=(((new_r00*x382))+((new_r10*x384))+(((-1.0)*x385)));
evalcond[9]=((((-1.0)*new_r22*x381*x383))+(((-1.0)*cj13*x386))+new_r10);
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[8]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[9]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(8);
vinfos[0].jointtype = 17;
vinfos[0].foffset = j5;
vinfos[0].indices[0] = _ij5[0];
vinfos[0].indices[1] = _ij5[1];
vinfos[0].maxsolutions = _nj5;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j9;
vinfos[1].indices[0] = _ij9[0];
vinfos[1].indices[1] = _ij9[1];
vinfos[1].maxsolutions = _nj9;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j10;
vinfos[2].indices[0] = _ij10[0];
vinfos[2].indices[1] = _ij10[1];
vinfos[2].maxsolutions = _nj10;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j11;
vinfos[3].indices[0] = _ij11[0];
vinfos[3].indices[1] = _ij11[1];
vinfos[3].maxsolutions = _nj11;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j12;
vinfos[4].indices[0] = _ij12[0];
vinfos[4].indices[1] = _ij12[1];
vinfos[4].maxsolutions = _nj12;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j13;
vinfos[5].indices[0] = _ij13[0];
vinfos[5].indices[1] = _ij13[1];
vinfos[5].maxsolutions = _nj13;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j14;
vinfos[6].indices[0] = _ij14[0];
vinfos[6].indices[1] = _ij14[1];
vinfos[6].maxsolutions = _nj14;
vinfos[7].jointtype = 1;
vinfos[7].foffset = j15;
vinfos[7].indices[0] = _ij15[0];
vinfos[7].indices[1] = _ij15[1];
vinfos[7].maxsolutions = _nj15;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

} else
{
{
IkReal j15array[1], cj15array[1], sj15array[1];
bool j15valid[1]={false};
_nj15 = 1;
IkReal x388=cj13*cj13;
IkReal x389=(cj13*new_r22);
CheckValue<IkReal> x390 = IKatan2WithCheck(IkReal((((new_r01*x389))+((new_r00*sj13)))),IkReal(((((-1.0)*new_r00*x389))+((new_r01*sj13)))),IKFAST_ATAN2_MAGTHRESH);
if(!x390.valid){
continue;
}
CheckValue<IkReal> x391=IKPowWithIntegerCheck(IKsign(((-1.0)+(((-1.0)*x388*(new_r22*new_r22)))+x388)),-1);
if(!x391.valid){
continue;
}
j15array[0]=((-1.5707963267949)+(x390.value)+(((1.5707963267949)*(x391.value))));
sj15array[0]=IKsin(j15array[0]);
cj15array[0]=IKcos(j15array[0]);
if( j15array[0] > IKPI )
{
    j15array[0]-=IK2PI;
}
else if( j15array[0] < -IKPI )
{    j15array[0]+=IK2PI;
}
j15valid[0] = true;
for(int ij15 = 0; ij15 < 1; ++ij15)
{
if( !j15valid[ij15] )
{
    continue;
}
_ij15[0] = ij15; _ij15[1] = -1;
for(int iij15 = ij15+1; iij15 < 1; ++iij15)
{
if( j15valid[iij15] && IKabs(cj15array[ij15]-cj15array[iij15]) < IKFAST_SOLUTION_THRESH && IKabs(sj15array[ij15]-sj15array[iij15]) < IKFAST_SOLUTION_THRESH )
{
    j15valid[iij15]=false; _ij15[1] = iij15; break; 
}
}
j15 = j15array[ij15]; cj15 = cj15array[ij15]; sj15 = sj15array[ij15];
{
IkReal evalcond[10];
IkReal x392=IKsin(j15);
IkReal x393=IKcos(j15);
IkReal x394=(cj13*new_r22);
IkReal x395=((1.0)*sj13);
IkReal x396=(new_r22*sj13);
IkReal x397=((1.0)*x393);
IkReal x398=((1.0)*x392);
IkReal x399=(new_r22*x392);
evalcond[0]=(((cj13*new_r01))+x399+((new_r11*sj13)));
evalcond[1]=(((new_r11*x396))+x392+((new_r01*x394)));
evalcond[2]=((((-1.0)*x398))+((cj13*new_r10))+(((-1.0)*new_r00*x395)));
evalcond[3]=((((-1.0)*new_r01*x395))+(((-1.0)*x397))+((cj13*new_r11)));
evalcond[4]=(((sj13*x393))+new_r01+((x392*x394)));
evalcond[5]=(((cj13*new_r00))+(((-1.0)*new_r22*x397))+((new_r10*sj13)));
evalcond[6]=((((-1.0)*x394*x397))+((sj13*x392))+new_r00);
evalcond[7]=((((-1.0)*cj13*x397))+new_r11+((x392*x396)));
evalcond[8]=((((-1.0)*x397))+((new_r00*x394))+((new_r10*x396)));
evalcond[9]=((((-1.0)*cj13*x398))+(((-1.0)*new_r22*x393*x395))+new_r10);
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[8]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[9]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(8);
vinfos[0].jointtype = 17;
vinfos[0].foffset = j5;
vinfos[0].indices[0] = _ij5[0];
vinfos[0].indices[1] = _ij5[1];
vinfos[0].maxsolutions = _nj5;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j9;
vinfos[1].indices[0] = _ij9[0];
vinfos[1].indices[1] = _ij9[1];
vinfos[1].maxsolutions = _nj9;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j10;
vinfos[2].indices[0] = _ij10[0];
vinfos[2].indices[1] = _ij10[1];
vinfos[2].maxsolutions = _nj10;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j11;
vinfos[3].indices[0] = _ij11[0];
vinfos[3].indices[1] = _ij11[1];
vinfos[3].maxsolutions = _nj11;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j12;
vinfos[4].indices[0] = _ij12[0];
vinfos[4].indices[1] = _ij12[1];
vinfos[4].maxsolutions = _nj12;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j13;
vinfos[5].indices[0] = _ij13[0];
vinfos[5].indices[1] = _ij13[1];
vinfos[5].maxsolutions = _nj13;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j14;
vinfos[6].indices[0] = _ij14[0];
vinfos[6].indices[1] = _ij14[1];
vinfos[6].maxsolutions = _nj14;
vinfos[7].jointtype = 1;
vinfos[7].foffset = j15;
vinfos[7].indices[0] = _ij15[0];
vinfos[7].indices[1] = _ij15[1];
vinfos[7].maxsolutions = _nj15;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}
    }

}

}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
if( 1 )
{
bgotonextstatement=false;
continue; // branch miss [j13, j15]

}
} while(0);
if( bgotonextstatement )
{
}
}
}
}
}

} else
{
{
IkReal j13array[1], cj13array[1], sj13array[1];
bool j13valid[1]={false};
_nj13 = 1;
CheckValue<IkReal> x401=IKPowWithIntegerCheck(sj14,-1);
if(!x401.valid){
continue;
}
IkReal x400=x401.value;
CheckValue<IkReal> x402=IKPowWithIntegerCheck(new_r12,-1);
if(!x402.valid){
continue;
}
if( IKabs((x400*(x402.value)*(((1.0)+(((-1.0)*(new_r02*new_r02)))+(((-1.0)*(cj14*cj14))))))) < IKFAST_ATAN2_MAGTHRESH && IKabs((new_r02*x400)) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr((x400*(x402.value)*(((1.0)+(((-1.0)*(new_r02*new_r02)))+(((-1.0)*(cj14*cj14)))))))+IKsqr((new_r02*x400))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j13array[0]=IKatan2((x400*(x402.value)*(((1.0)+(((-1.0)*(new_r02*new_r02)))+(((-1.0)*(cj14*cj14)))))), (new_r02*x400));
sj13array[0]=IKsin(j13array[0]);
cj13array[0]=IKcos(j13array[0]);
if( j13array[0] > IKPI )
{
    j13array[0]-=IK2PI;
}
else if( j13array[0] < -IKPI )
{    j13array[0]+=IK2PI;
}
j13valid[0] = true;
for(int ij13 = 0; ij13 < 1; ++ij13)
{
if( !j13valid[ij13] )
{
    continue;
}
_ij13[0] = ij13; _ij13[1] = -1;
for(int iij13 = ij13+1; iij13 < 1; ++iij13)
{
if( j13valid[iij13] && IKabs(cj13array[ij13]-cj13array[iij13]) < IKFAST_SOLUTION_THRESH && IKabs(sj13array[ij13]-sj13array[iij13]) < IKFAST_SOLUTION_THRESH )
{
    j13valid[iij13]=false; _ij13[1] = iij13; break; 
}
}
j13 = j13array[ij13]; cj13 = cj13array[ij13]; sj13 = sj13array[ij13];
{
IkReal evalcond[8];
IkReal x403=IKcos(j13);
IkReal x404=IKsin(j13);
IkReal x405=((1.0)*sj14);
IkReal x406=(new_r12*x404);
IkReal x407=(new_r02*x403);
IkReal x408=(sj14*x403);
IkReal x409=(sj14*x404);
evalcond[0]=((((-1.0)*x403*x405))+new_r02);
evalcond[1]=((((-1.0)*x404*x405))+new_r12);
evalcond[2]=((((-1.0)*new_r02*x404))+((new_r12*x403)));
evalcond[3]=(x407+x406+(((-1.0)*x405)));
evalcond[4]=(((cj14*new_r20))+((new_r10*x409))+((new_r00*x408)));
evalcond[5]=(((cj14*new_r21))+((new_r11*x409))+((new_r01*x408)));
evalcond[6]=((-1.0)+((cj14*new_r22))+((sj14*x406))+((sj14*x407)));
evalcond[7]=(((cj14*x406))+((cj14*x407))+(((-1.0)*new_r22*x405)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
IkReal j15eval[3];
j15eval[0]=sj14;
j15eval[1]=IKsign(sj14);
j15eval[2]=((IKabs(new_r20))+(IKabs(new_r21)));
if( IKabs(j15eval[0]) < 0.0000010000000000  || IKabs(j15eval[1]) < 0.0000010000000000  || IKabs(j15eval[2]) < 0.0000010000000000  )
{
{
IkReal j15eval[2];
j15eval[0]=sj14;
j15eval[1]=sj13;
if( IKabs(j15eval[0]) < 0.0000010000000000  || IKabs(j15eval[1]) < 0.0000010000000000  )
{
{
IkReal j15eval[3];
j15eval[0]=cj14;
j15eval[1]=sj13;
j15eval[2]=sj14;
if( IKabs(j15eval[0]) < 0.0000010000000000  || IKabs(j15eval[1]) < 0.0000010000000000  || IKabs(j15eval[2]) < 0.0000010000000000  )
{
{
IkReal evalcond[5];
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((-1.5707963267949)+j14)))), 6.28318530717959)));
evalcond[1]=new_r22;
if( IKabs(evalcond[0]) < 0.0000050000000000  && IKabs(evalcond[1]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j15array[1], cj15array[1], sj15array[1];
bool j15valid[1]={false};
_nj15 = 1;
if( IKabs(new_r21) < IKFAST_ATAN2_MAGTHRESH && IKabs(((-1.0)*new_r20)) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(new_r21)+IKsqr(((-1.0)*new_r20))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j15array[0]=IKatan2(new_r21, ((-1.0)*new_r20));
sj15array[0]=IKsin(j15array[0]);
cj15array[0]=IKcos(j15array[0]);
if( j15array[0] > IKPI )
{
    j15array[0]-=IK2PI;
}
else if( j15array[0] < -IKPI )
{    j15array[0]+=IK2PI;
}
j15valid[0] = true;
for(int ij15 = 0; ij15 < 1; ++ij15)
{
if( !j15valid[ij15] )
{
    continue;
}
_ij15[0] = ij15; _ij15[1] = -1;
for(int iij15 = ij15+1; iij15 < 1; ++iij15)
{
if( j15valid[iij15] && IKabs(cj15array[ij15]-cj15array[iij15]) < IKFAST_SOLUTION_THRESH && IKabs(sj15array[ij15]-sj15array[iij15]) < IKFAST_SOLUTION_THRESH )
{
    j15valid[iij15]=false; _ij15[1] = iij15; break; 
}
}
j15 = j15array[ij15]; cj15 = cj15array[ij15]; sj15 = sj15array[ij15];
{
IkReal evalcond[8];
IkReal x410=IKcos(j15);
IkReal x411=IKsin(j15);
IkReal x412=((1.0)*cj13);
IkReal x413=((1.0)*sj13);
IkReal x414=((1.0)*x411);
evalcond[0]=(x410+new_r20);
evalcond[1]=(new_r21+(((-1.0)*x414)));
evalcond[2]=(((sj13*x410))+new_r01);
evalcond[3]=(((sj13*x411))+new_r00);
evalcond[4]=((((-1.0)*x410*x412))+new_r11);
evalcond[5]=((((-1.0)*x411*x412))+new_r10);
evalcond[6]=(((cj13*new_r10))+(((-1.0)*new_r00*x413))+(((-1.0)*x414)));
evalcond[7]=(((cj13*new_r11))+(((-1.0)*new_r01*x413))+(((-1.0)*x410)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(8);
vinfos[0].jointtype = 17;
vinfos[0].foffset = j5;
vinfos[0].indices[0] = _ij5[0];
vinfos[0].indices[1] = _ij5[1];
vinfos[0].maxsolutions = _nj5;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j9;
vinfos[1].indices[0] = _ij9[0];
vinfos[1].indices[1] = _ij9[1];
vinfos[1].maxsolutions = _nj9;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j10;
vinfos[2].indices[0] = _ij10[0];
vinfos[2].indices[1] = _ij10[1];
vinfos[2].maxsolutions = _nj10;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j11;
vinfos[3].indices[0] = _ij11[0];
vinfos[3].indices[1] = _ij11[1];
vinfos[3].maxsolutions = _nj11;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j12;
vinfos[4].indices[0] = _ij12[0];
vinfos[4].indices[1] = _ij12[1];
vinfos[4].maxsolutions = _nj12;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j13;
vinfos[5].indices[0] = _ij13[0];
vinfos[5].indices[1] = _ij13[1];
vinfos[5].maxsolutions = _nj13;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j14;
vinfos[6].indices[0] = _ij14[0];
vinfos[6].indices[1] = _ij14[1];
vinfos[6].maxsolutions = _nj14;
vinfos[7].jointtype = 1;
vinfos[7].foffset = j15;
vinfos[7].indices[0] = _ij15[0];
vinfos[7].indices[1] = _ij15[1];
vinfos[7].maxsolutions = _nj15;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((1.5707963267949)+j14)))), 6.28318530717959)));
evalcond[1]=new_r22;
if( IKabs(evalcond[0]) < 0.0000050000000000  && IKabs(evalcond[1]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j15array[1], cj15array[1], sj15array[1];
bool j15valid[1]={false};
_nj15 = 1;
if( IKabs(((-1.0)*new_r21)) < IKFAST_ATAN2_MAGTHRESH && IKabs(new_r20) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((-1.0)*new_r21))+IKsqr(new_r20)-1) <= IKFAST_SINCOS_THRESH )
    continue;
j15array[0]=IKatan2(((-1.0)*new_r21), new_r20);
sj15array[0]=IKsin(j15array[0]);
cj15array[0]=IKcos(j15array[0]);
if( j15array[0] > IKPI )
{
    j15array[0]-=IK2PI;
}
else if( j15array[0] < -IKPI )
{    j15array[0]+=IK2PI;
}
j15valid[0] = true;
for(int ij15 = 0; ij15 < 1; ++ij15)
{
if( !j15valid[ij15] )
{
    continue;
}
_ij15[0] = ij15; _ij15[1] = -1;
for(int iij15 = ij15+1; iij15 < 1; ++iij15)
{
if( j15valid[iij15] && IKabs(cj15array[ij15]-cj15array[iij15]) < IKFAST_SOLUTION_THRESH && IKabs(sj15array[ij15]-sj15array[iij15]) < IKFAST_SOLUTION_THRESH )
{
    j15valid[iij15]=false; _ij15[1] = iij15; break; 
}
}
j15 = j15array[ij15]; cj15 = cj15array[ij15]; sj15 = sj15array[ij15];
{
IkReal evalcond[8];
IkReal x415=IKcos(j15);
IkReal x416=IKsin(j15);
IkReal x417=((1.0)*cj13);
IkReal x418=((1.0)*sj13);
IkReal x419=((1.0)*x415);
evalcond[0]=(x416+new_r21);
evalcond[1]=(new_r20+(((-1.0)*x419)));
evalcond[2]=(((sj13*x415))+new_r01);
evalcond[3]=(((sj13*x416))+new_r00);
evalcond[4]=((((-1.0)*x415*x417))+new_r11);
evalcond[5]=((((-1.0)*x416*x417))+new_r10);
evalcond[6]=(((cj13*new_r10))+(((-1.0)*new_r00*x418))+(((-1.0)*x416)));
evalcond[7]=(((cj13*new_r11))+(((-1.0)*x419))+(((-1.0)*new_r01*x418)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(8);
vinfos[0].jointtype = 17;
vinfos[0].foffset = j5;
vinfos[0].indices[0] = _ij5[0];
vinfos[0].indices[1] = _ij5[1];
vinfos[0].maxsolutions = _nj5;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j9;
vinfos[1].indices[0] = _ij9[0];
vinfos[1].indices[1] = _ij9[1];
vinfos[1].maxsolutions = _nj9;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j10;
vinfos[2].indices[0] = _ij10[0];
vinfos[2].indices[1] = _ij10[1];
vinfos[2].maxsolutions = _nj10;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j11;
vinfos[3].indices[0] = _ij11[0];
vinfos[3].indices[1] = _ij11[1];
vinfos[3].maxsolutions = _nj11;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j12;
vinfos[4].indices[0] = _ij12[0];
vinfos[4].indices[1] = _ij12[1];
vinfos[4].maxsolutions = _nj12;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j13;
vinfos[5].indices[0] = _ij13[0];
vinfos[5].indices[1] = _ij13[1];
vinfos[5].maxsolutions = _nj13;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j14;
vinfos[6].indices[0] = _ij14[0];
vinfos[6].indices[1] = _ij14[1];
vinfos[6].maxsolutions = _nj14;
vinfos[7].jointtype = 1;
vinfos[7].foffset = j15;
vinfos[7].indices[0] = _ij15[0];
vinfos[7].indices[1] = _ij15[1];
vinfos[7].maxsolutions = _nj15;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(j13))), 6.28318530717959)));
evalcond[1]=new_r12;
if( IKabs(evalcond[0]) < 0.0000050000000000  && IKabs(evalcond[1]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j15array[1], cj15array[1], sj15array[1];
bool j15valid[1]={false};
_nj15 = 1;
if( IKabs(new_r10) < IKFAST_ATAN2_MAGTHRESH && IKabs(new_r11) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(new_r10)+IKsqr(new_r11)-1) <= IKFAST_SINCOS_THRESH )
    continue;
j15array[0]=IKatan2(new_r10, new_r11);
sj15array[0]=IKsin(j15array[0]);
cj15array[0]=IKcos(j15array[0]);
if( j15array[0] > IKPI )
{
    j15array[0]-=IK2PI;
}
else if( j15array[0] < -IKPI )
{    j15array[0]+=IK2PI;
}
j15valid[0] = true;
for(int ij15 = 0; ij15 < 1; ++ij15)
{
if( !j15valid[ij15] )
{
    continue;
}
_ij15[0] = ij15; _ij15[1] = -1;
for(int iij15 = ij15+1; iij15 < 1; ++iij15)
{
if( j15valid[iij15] && IKabs(cj15array[ij15]-cj15array[iij15]) < IKFAST_SOLUTION_THRESH && IKabs(sj15array[ij15]-sj15array[iij15]) < IKFAST_SOLUTION_THRESH )
{
    j15valid[iij15]=false; _ij15[1] = iij15; break; 
}
}
j15 = j15array[ij15]; cj15 = cj15array[ij15]; sj15 = sj15array[ij15];
{
IkReal evalcond[8];
IkReal x420=IKcos(j15);
IkReal x421=IKsin(j15);
IkReal x422=((1.0)*sj14);
IkReal x423=((1.0)*x420);
evalcond[0]=(((sj14*x420))+new_r20);
evalcond[1]=((((-1.0)*x421))+new_r10);
evalcond[2]=((((-1.0)*x423))+new_r11);
evalcond[3]=(new_r01+((cj14*x421)));
evalcond[4]=((((-1.0)*x421*x422))+new_r21);
evalcond[5]=((((-1.0)*cj14*x423))+new_r00);
evalcond[6]=(((cj14*new_r01))+x421+(((-1.0)*new_r21*x422)));
evalcond[7]=(((cj14*new_r00))+(((-1.0)*x423))+(((-1.0)*new_r20*x422)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(8);
vinfos[0].jointtype = 17;
vinfos[0].foffset = j5;
vinfos[0].indices[0] = _ij5[0];
vinfos[0].indices[1] = _ij5[1];
vinfos[0].maxsolutions = _nj5;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j9;
vinfos[1].indices[0] = _ij9[0];
vinfos[1].indices[1] = _ij9[1];
vinfos[1].maxsolutions = _nj9;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j10;
vinfos[2].indices[0] = _ij10[0];
vinfos[2].indices[1] = _ij10[1];
vinfos[2].maxsolutions = _nj10;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j11;
vinfos[3].indices[0] = _ij11[0];
vinfos[3].indices[1] = _ij11[1];
vinfos[3].maxsolutions = _nj11;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j12;
vinfos[4].indices[0] = _ij12[0];
vinfos[4].indices[1] = _ij12[1];
vinfos[4].maxsolutions = _nj12;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j13;
vinfos[5].indices[0] = _ij13[0];
vinfos[5].indices[1] = _ij13[1];
vinfos[5].maxsolutions = _nj13;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j14;
vinfos[6].indices[0] = _ij14[0];
vinfos[6].indices[1] = _ij14[1];
vinfos[6].maxsolutions = _nj14;
vinfos[7].jointtype = 1;
vinfos[7].foffset = j15;
vinfos[7].indices[0] = _ij15[0];
vinfos[7].indices[1] = _ij15[1];
vinfos[7].maxsolutions = _nj15;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((-3.14159265358979)+j13)))), 6.28318530717959)));
evalcond[1]=new_r12;
if( IKabs(evalcond[0]) < 0.0000050000000000  && IKabs(evalcond[1]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j15eval[3];
sj13=0;
cj13=-1.0;
j13=3.14159265358979;
j15eval[0]=sj14;
j15eval[1]=IKsign(sj14);
j15eval[2]=((IKabs(new_r20))+(IKabs(new_r21)));
if( IKabs(j15eval[0]) < 0.0000010000000000  || IKabs(j15eval[1]) < 0.0000010000000000  || IKabs(j15eval[2]) < 0.0000010000000000  )
{
{
IkReal j15eval[1];
sj13=0;
cj13=-1.0;
j13=3.14159265358979;
j15eval[0]=sj14;
if( IKabs(j15eval[0]) < 0.0000010000000000  )
{
{
IkReal j15eval[2];
sj13=0;
cj13=-1.0;
j13=3.14159265358979;
j15eval[0]=cj14;
j15eval[1]=sj14;
if( IKabs(j15eval[0]) < 0.0000010000000000  || IKabs(j15eval[1]) < 0.0000010000000000  )
{
{
IkReal evalcond[4];
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((-1.5707963267949)+j14)))), 6.28318530717959)));
evalcond[1]=new_r22;
evalcond[2]=new_r01;
evalcond[3]=new_r00;
if( IKabs(evalcond[0]) < 0.0000050000000000  && IKabs(evalcond[1]) < 0.0000050000000000  && IKabs(evalcond[2]) < 0.0000050000000000  && IKabs(evalcond[3]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j15array[1], cj15array[1], sj15array[1];
bool j15valid[1]={false};
_nj15 = 1;
if( IKabs(new_r21) < IKFAST_ATAN2_MAGTHRESH && IKabs(((-1.0)*new_r20)) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(new_r21)+IKsqr(((-1.0)*new_r20))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j15array[0]=IKatan2(new_r21, ((-1.0)*new_r20));
sj15array[0]=IKsin(j15array[0]);
cj15array[0]=IKcos(j15array[0]);
if( j15array[0] > IKPI )
{
    j15array[0]-=IK2PI;
}
else if( j15array[0] < -IKPI )
{    j15array[0]+=IK2PI;
}
j15valid[0] = true;
for(int ij15 = 0; ij15 < 1; ++ij15)
{
if( !j15valid[ij15] )
{
    continue;
}
_ij15[0] = ij15; _ij15[1] = -1;
for(int iij15 = ij15+1; iij15 < 1; ++iij15)
{
if( j15valid[iij15] && IKabs(cj15array[ij15]-cj15array[iij15]) < IKFAST_SOLUTION_THRESH && IKabs(sj15array[ij15]-sj15array[iij15]) < IKFAST_SOLUTION_THRESH )
{
    j15valid[iij15]=false; _ij15[1] = iij15; break; 
}
}
j15 = j15array[ij15]; cj15 = cj15array[ij15]; sj15 = sj15array[ij15];
{
IkReal evalcond[4];
IkReal x424=IKcos(j15);
IkReal x425=((1.0)*(IKsin(j15)));
evalcond[0]=(x424+new_r20);
evalcond[1]=((((-1.0)*x425))+new_r21);
evalcond[2]=((((-1.0)*x425))+(((-1.0)*new_r10)));
evalcond[3]=((((-1.0)*x424))+(((-1.0)*new_r11)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(8);
vinfos[0].jointtype = 17;
vinfos[0].foffset = j5;
vinfos[0].indices[0] = _ij5[0];
vinfos[0].indices[1] = _ij5[1];
vinfos[0].maxsolutions = _nj5;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j9;
vinfos[1].indices[0] = _ij9[0];
vinfos[1].indices[1] = _ij9[1];
vinfos[1].maxsolutions = _nj9;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j10;
vinfos[2].indices[0] = _ij10[0];
vinfos[2].indices[1] = _ij10[1];
vinfos[2].maxsolutions = _nj10;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j11;
vinfos[3].indices[0] = _ij11[0];
vinfos[3].indices[1] = _ij11[1];
vinfos[3].maxsolutions = _nj11;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j12;
vinfos[4].indices[0] = _ij12[0];
vinfos[4].indices[1] = _ij12[1];
vinfos[4].maxsolutions = _nj12;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j13;
vinfos[5].indices[0] = _ij13[0];
vinfos[5].indices[1] = _ij13[1];
vinfos[5].maxsolutions = _nj13;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j14;
vinfos[6].indices[0] = _ij14[0];
vinfos[6].indices[1] = _ij14[1];
vinfos[6].maxsolutions = _nj14;
vinfos[7].jointtype = 1;
vinfos[7].foffset = j15;
vinfos[7].indices[0] = _ij15[0];
vinfos[7].indices[1] = _ij15[1];
vinfos[7].maxsolutions = _nj15;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((1.5707963267949)+j14)))), 6.28318530717959)));
evalcond[1]=new_r22;
evalcond[2]=new_r01;
evalcond[3]=new_r00;
if( IKabs(evalcond[0]) < 0.0000050000000000  && IKabs(evalcond[1]) < 0.0000050000000000  && IKabs(evalcond[2]) < 0.0000050000000000  && IKabs(evalcond[3]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j15array[1], cj15array[1], sj15array[1];
bool j15valid[1]={false};
_nj15 = 1;
if( IKabs(((-1.0)*new_r21)) < IKFAST_ATAN2_MAGTHRESH && IKabs(new_r20) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((-1.0)*new_r21))+IKsqr(new_r20)-1) <= IKFAST_SINCOS_THRESH )
    continue;
j15array[0]=IKatan2(((-1.0)*new_r21), new_r20);
sj15array[0]=IKsin(j15array[0]);
cj15array[0]=IKcos(j15array[0]);
if( j15array[0] > IKPI )
{
    j15array[0]-=IK2PI;
}
else if( j15array[0] < -IKPI )
{    j15array[0]+=IK2PI;
}
j15valid[0] = true;
for(int ij15 = 0; ij15 < 1; ++ij15)
{
if( !j15valid[ij15] )
{
    continue;
}
_ij15[0] = ij15; _ij15[1] = -1;
for(int iij15 = ij15+1; iij15 < 1; ++iij15)
{
if( j15valid[iij15] && IKabs(cj15array[ij15]-cj15array[iij15]) < IKFAST_SOLUTION_THRESH && IKabs(sj15array[ij15]-sj15array[iij15]) < IKFAST_SOLUTION_THRESH )
{
    j15valid[iij15]=false; _ij15[1] = iij15; break; 
}
}
j15 = j15array[ij15]; cj15 = cj15array[ij15]; sj15 = sj15array[ij15];
{
IkReal evalcond[4];
IkReal x426=IKsin(j15);
IkReal x427=((1.0)*(IKcos(j15)));
evalcond[0]=(x426+new_r21);
evalcond[1]=((((-1.0)*x427))+new_r20);
evalcond[2]=((((-1.0)*x426))+(((-1.0)*new_r10)));
evalcond[3]=((((-1.0)*x427))+(((-1.0)*new_r11)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(8);
vinfos[0].jointtype = 17;
vinfos[0].foffset = j5;
vinfos[0].indices[0] = _ij5[0];
vinfos[0].indices[1] = _ij5[1];
vinfos[0].maxsolutions = _nj5;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j9;
vinfos[1].indices[0] = _ij9[0];
vinfos[1].indices[1] = _ij9[1];
vinfos[1].maxsolutions = _nj9;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j10;
vinfos[2].indices[0] = _ij10[0];
vinfos[2].indices[1] = _ij10[1];
vinfos[2].maxsolutions = _nj10;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j11;
vinfos[3].indices[0] = _ij11[0];
vinfos[3].indices[1] = _ij11[1];
vinfos[3].maxsolutions = _nj11;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j12;
vinfos[4].indices[0] = _ij12[0];
vinfos[4].indices[1] = _ij12[1];
vinfos[4].maxsolutions = _nj12;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j13;
vinfos[5].indices[0] = _ij13[0];
vinfos[5].indices[1] = _ij13[1];
vinfos[5].maxsolutions = _nj13;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j14;
vinfos[6].indices[0] = _ij14[0];
vinfos[6].indices[1] = _ij14[1];
vinfos[6].maxsolutions = _nj14;
vinfos[7].jointtype = 1;
vinfos[7].foffset = j15;
vinfos[7].indices[0] = _ij15[0];
vinfos[7].indices[1] = _ij15[1];
vinfos[7].maxsolutions = _nj15;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(j14))), 6.28318530717959)));
evalcond[1]=new_r20;
evalcond[2]=new_r02;
evalcond[3]=new_r21;
if( IKabs(evalcond[0]) < 0.0000050000000000  && IKabs(evalcond[1]) < 0.0000050000000000  && IKabs(evalcond[2]) < 0.0000050000000000  && IKabs(evalcond[3]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j15array[1], cj15array[1], sj15array[1];
bool j15valid[1]={false};
_nj15 = 1;
if( IKabs(new_r01) < IKFAST_ATAN2_MAGTHRESH && IKabs(((-1.0)*new_r11)) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(new_r01)+IKsqr(((-1.0)*new_r11))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j15array[0]=IKatan2(new_r01, ((-1.0)*new_r11));
sj15array[0]=IKsin(j15array[0]);
cj15array[0]=IKcos(j15array[0]);
if( j15array[0] > IKPI )
{
    j15array[0]-=IK2PI;
}
else if( j15array[0] < -IKPI )
{    j15array[0]+=IK2PI;
}
j15valid[0] = true;
for(int ij15 = 0; ij15 < 1; ++ij15)
{
if( !j15valid[ij15] )
{
    continue;
}
_ij15[0] = ij15; _ij15[1] = -1;
for(int iij15 = ij15+1; iij15 < 1; ++iij15)
{
if( j15valid[iij15] && IKabs(cj15array[ij15]-cj15array[iij15]) < IKFAST_SOLUTION_THRESH && IKabs(sj15array[ij15]-sj15array[iij15]) < IKFAST_SOLUTION_THRESH )
{
    j15valid[iij15]=false; _ij15[1] = iij15; break; 
}
}
j15 = j15array[ij15]; cj15 = cj15array[ij15]; sj15 = sj15array[ij15];
{
IkReal evalcond[4];
IkReal x428=IKsin(j15);
IkReal x429=((1.0)*(IKcos(j15)));
evalcond[0]=(x428+(((-1.0)*new_r01)));
evalcond[1]=((((-1.0)*x428))+(((-1.0)*new_r10)));
evalcond[2]=((((-1.0)*x429))+(((-1.0)*new_r11)));
evalcond[3]=((((-1.0)*x429))+(((-1.0)*new_r00)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(8);
vinfos[0].jointtype = 17;
vinfos[0].foffset = j5;
vinfos[0].indices[0] = _ij5[0];
vinfos[0].indices[1] = _ij5[1];
vinfos[0].maxsolutions = _nj5;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j9;
vinfos[1].indices[0] = _ij9[0];
vinfos[1].indices[1] = _ij9[1];
vinfos[1].maxsolutions = _nj9;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j10;
vinfos[2].indices[0] = _ij10[0];
vinfos[2].indices[1] = _ij10[1];
vinfos[2].maxsolutions = _nj10;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j11;
vinfos[3].indices[0] = _ij11[0];
vinfos[3].indices[1] = _ij11[1];
vinfos[3].maxsolutions = _nj11;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j12;
vinfos[4].indices[0] = _ij12[0];
vinfos[4].indices[1] = _ij12[1];
vinfos[4].maxsolutions = _nj12;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j13;
vinfos[5].indices[0] = _ij13[0];
vinfos[5].indices[1] = _ij13[1];
vinfos[5].maxsolutions = _nj13;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j14;
vinfos[6].indices[0] = _ij14[0];
vinfos[6].indices[1] = _ij14[1];
vinfos[6].maxsolutions = _nj14;
vinfos[7].jointtype = 1;
vinfos[7].foffset = j15;
vinfos[7].indices[0] = _ij15[0];
vinfos[7].indices[1] = _ij15[1];
vinfos[7].maxsolutions = _nj15;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((-3.14159265358979)+j14)))), 6.28318530717959)));
evalcond[1]=new_r20;
evalcond[2]=new_r02;
evalcond[3]=new_r21;
if( IKabs(evalcond[0]) < 0.0000050000000000  && IKabs(evalcond[1]) < 0.0000050000000000  && IKabs(evalcond[2]) < 0.0000050000000000  && IKabs(evalcond[3]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j15array[1], cj15array[1], sj15array[1];
bool j15valid[1]={false};
_nj15 = 1;
if( IKabs(((-1.0)*new_r10)) < IKFAST_ATAN2_MAGTHRESH && IKabs(new_r00) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((-1.0)*new_r10))+IKsqr(new_r00)-1) <= IKFAST_SINCOS_THRESH )
    continue;
j15array[0]=IKatan2(((-1.0)*new_r10), new_r00);
sj15array[0]=IKsin(j15array[0]);
cj15array[0]=IKcos(j15array[0]);
if( j15array[0] > IKPI )
{
    j15array[0]-=IK2PI;
}
else if( j15array[0] < -IKPI )
{    j15array[0]+=IK2PI;
}
j15valid[0] = true;
for(int ij15 = 0; ij15 < 1; ++ij15)
{
if( !j15valid[ij15] )
{
    continue;
}
_ij15[0] = ij15; _ij15[1] = -1;
for(int iij15 = ij15+1; iij15 < 1; ++iij15)
{
if( j15valid[iij15] && IKabs(cj15array[ij15]-cj15array[iij15]) < IKFAST_SOLUTION_THRESH && IKabs(sj15array[ij15]-sj15array[iij15]) < IKFAST_SOLUTION_THRESH )
{
    j15valid[iij15]=false; _ij15[1] = iij15; break; 
}
}
j15 = j15array[ij15]; cj15 = cj15array[ij15]; sj15 = sj15array[ij15];
{
IkReal evalcond[4];
IkReal x430=IKcos(j15);
IkReal x431=((1.0)*(IKsin(j15)));
evalcond[0]=(x430+(((-1.0)*new_r00)));
evalcond[1]=((((-1.0)*x431))+(((-1.0)*new_r10)));
evalcond[2]=((((-1.0)*x430))+(((-1.0)*new_r11)));
evalcond[3]=((((-1.0)*x431))+(((-1.0)*new_r01)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(8);
vinfos[0].jointtype = 17;
vinfos[0].foffset = j5;
vinfos[0].indices[0] = _ij5[0];
vinfos[0].indices[1] = _ij5[1];
vinfos[0].maxsolutions = _nj5;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j9;
vinfos[1].indices[0] = _ij9[0];
vinfos[1].indices[1] = _ij9[1];
vinfos[1].maxsolutions = _nj9;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j10;
vinfos[2].indices[0] = _ij10[0];
vinfos[2].indices[1] = _ij10[1];
vinfos[2].maxsolutions = _nj10;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j11;
vinfos[3].indices[0] = _ij11[0];
vinfos[3].indices[1] = _ij11[1];
vinfos[3].maxsolutions = _nj11;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j12;
vinfos[4].indices[0] = _ij12[0];
vinfos[4].indices[1] = _ij12[1];
vinfos[4].maxsolutions = _nj12;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j13;
vinfos[5].indices[0] = _ij13[0];
vinfos[5].indices[1] = _ij13[1];
vinfos[5].maxsolutions = _nj13;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j14;
vinfos[6].indices[0] = _ij14[0];
vinfos[6].indices[1] = _ij14[1];
vinfos[6].maxsolutions = _nj14;
vinfos[7].jointtype = 1;
vinfos[7].foffset = j15;
vinfos[7].indices[0] = _ij15[0];
vinfos[7].indices[1] = _ij15[1];
vinfos[7].maxsolutions = _nj15;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((IKabs(new_r20))+(IKabs(new_r21)));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j15array[1], cj15array[1], sj15array[1];
bool j15valid[1]={false};
_nj15 = 1;
if( IKabs(((-1.0)*new_r10)) < IKFAST_ATAN2_MAGTHRESH && IKabs(((-1.0)*new_r11)) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((-1.0)*new_r10))+IKsqr(((-1.0)*new_r11))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j15array[0]=IKatan2(((-1.0)*new_r10), ((-1.0)*new_r11));
sj15array[0]=IKsin(j15array[0]);
cj15array[0]=IKcos(j15array[0]);
if( j15array[0] > IKPI )
{
    j15array[0]-=IK2PI;
}
else if( j15array[0] < -IKPI )
{    j15array[0]+=IK2PI;
}
j15valid[0] = true;
for(int ij15 = 0; ij15 < 1; ++ij15)
{
if( !j15valid[ij15] )
{
    continue;
}
_ij15[0] = ij15; _ij15[1] = -1;
for(int iij15 = ij15+1; iij15 < 1; ++iij15)
{
if( j15valid[iij15] && IKabs(cj15array[ij15]-cj15array[iij15]) < IKFAST_SOLUTION_THRESH && IKabs(sj15array[ij15]-sj15array[iij15]) < IKFAST_SOLUTION_THRESH )
{
    j15valid[iij15]=false; _ij15[1] = iij15; break; 
}
}
j15 = j15array[ij15]; cj15 = cj15array[ij15]; sj15 = sj15array[ij15];
{
IkReal evalcond[6];
IkReal x432=IKsin(j15);
IkReal x433=IKcos(j15);
IkReal x434=((-1.0)*x433);
evalcond[0]=x432;
evalcond[1]=(new_r22*x432);
evalcond[2]=x434;
evalcond[3]=(new_r22*x434);
evalcond[4]=((((-1.0)*x432))+(((-1.0)*new_r10)));
evalcond[5]=((((-1.0)*x433))+(((-1.0)*new_r11)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(8);
vinfos[0].jointtype = 17;
vinfos[0].foffset = j5;
vinfos[0].indices[0] = _ij5[0];
vinfos[0].indices[1] = _ij5[1];
vinfos[0].maxsolutions = _nj5;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j9;
vinfos[1].indices[0] = _ij9[0];
vinfos[1].indices[1] = _ij9[1];
vinfos[1].maxsolutions = _nj9;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j10;
vinfos[2].indices[0] = _ij10[0];
vinfos[2].indices[1] = _ij10[1];
vinfos[2].maxsolutions = _nj10;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j11;
vinfos[3].indices[0] = _ij11[0];
vinfos[3].indices[1] = _ij11[1];
vinfos[3].maxsolutions = _nj11;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j12;
vinfos[4].indices[0] = _ij12[0];
vinfos[4].indices[1] = _ij12[1];
vinfos[4].maxsolutions = _nj12;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j13;
vinfos[5].indices[0] = _ij13[0];
vinfos[5].indices[1] = _ij13[1];
vinfos[5].maxsolutions = _nj13;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j14;
vinfos[6].indices[0] = _ij14[0];
vinfos[6].indices[1] = _ij14[1];
vinfos[6].maxsolutions = _nj14;
vinfos[7].jointtype = 1;
vinfos[7].foffset = j15;
vinfos[7].indices[0] = _ij15[0];
vinfos[7].indices[1] = _ij15[1];
vinfos[7].maxsolutions = _nj15;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
if( 1 )
{
bgotonextstatement=false;
continue; // branch miss [j15]

}
} while(0);
if( bgotonextstatement )
{
}
}
}
}
}
}
}

} else
{
{
IkReal j15array[1], cj15array[1], sj15array[1];
bool j15valid[1]={false};
_nj15 = 1;
CheckValue<IkReal> x435=IKPowWithIntegerCheck(cj14,-1);
if(!x435.valid){
continue;
}
CheckValue<IkReal> x436=IKPowWithIntegerCheck(sj14,-1);
if(!x436.valid){
continue;
}
if( IKabs((new_r01*(x435.value))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((-1.0)*new_r20*(x436.value))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr((new_r01*(x435.value)))+IKsqr(((-1.0)*new_r20*(x436.value)))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j15array[0]=IKatan2((new_r01*(x435.value)), ((-1.0)*new_r20*(x436.value)));
sj15array[0]=IKsin(j15array[0]);
cj15array[0]=IKcos(j15array[0]);
if( j15array[0] > IKPI )
{
    j15array[0]-=IK2PI;
}
else if( j15array[0] < -IKPI )
{    j15array[0]+=IK2PI;
}
j15valid[0] = true;
for(int ij15 = 0; ij15 < 1; ++ij15)
{
if( !j15valid[ij15] )
{
    continue;
}
_ij15[0] = ij15; _ij15[1] = -1;
for(int iij15 = ij15+1; iij15 < 1; ++iij15)
{
if( j15valid[iij15] && IKabs(cj15array[ij15]-cj15array[iij15]) < IKFAST_SOLUTION_THRESH && IKabs(sj15array[ij15]-sj15array[iij15]) < IKFAST_SOLUTION_THRESH )
{
    j15valid[iij15]=false; _ij15[1] = iij15; break; 
}
}
j15 = j15array[ij15]; cj15 = cj15array[ij15]; sj15 = sj15array[ij15];
{
IkReal evalcond[8];
IkReal x437=IKsin(j15);
IkReal x438=IKcos(j15);
IkReal x439=((1.0)*new_r00);
IkReal x440=((1.0)*sj14);
IkReal x441=((1.0)*new_r01);
IkReal x442=((1.0)*x438);
evalcond[0]=(((sj14*x438))+new_r20);
evalcond[1]=((((-1.0)*x437*x440))+new_r21);
evalcond[2]=((((-1.0)*x437))+(((-1.0)*new_r10)));
evalcond[3]=((((-1.0)*x442))+(((-1.0)*new_r11)));
evalcond[4]=((((-1.0)*x441))+((cj14*x437)));
evalcond[5]=((((-1.0)*x439))+(((-1.0)*cj14*x442)));
evalcond[6]=((((-1.0)*cj14*x441))+x437+(((-1.0)*new_r21*x440)));
evalcond[7]=((((-1.0)*x442))+(((-1.0)*cj14*x439))+(((-1.0)*new_r20*x440)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(8);
vinfos[0].jointtype = 17;
vinfos[0].foffset = j5;
vinfos[0].indices[0] = _ij5[0];
vinfos[0].indices[1] = _ij5[1];
vinfos[0].maxsolutions = _nj5;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j9;
vinfos[1].indices[0] = _ij9[0];
vinfos[1].indices[1] = _ij9[1];
vinfos[1].maxsolutions = _nj9;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j10;
vinfos[2].indices[0] = _ij10[0];
vinfos[2].indices[1] = _ij10[1];
vinfos[2].maxsolutions = _nj10;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j11;
vinfos[3].indices[0] = _ij11[0];
vinfos[3].indices[1] = _ij11[1];
vinfos[3].maxsolutions = _nj11;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j12;
vinfos[4].indices[0] = _ij12[0];
vinfos[4].indices[1] = _ij12[1];
vinfos[4].maxsolutions = _nj12;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j13;
vinfos[5].indices[0] = _ij13[0];
vinfos[5].indices[1] = _ij13[1];
vinfos[5].maxsolutions = _nj13;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j14;
vinfos[6].indices[0] = _ij14[0];
vinfos[6].indices[1] = _ij14[1];
vinfos[6].maxsolutions = _nj14;
vinfos[7].jointtype = 1;
vinfos[7].foffset = j15;
vinfos[7].indices[0] = _ij15[0];
vinfos[7].indices[1] = _ij15[1];
vinfos[7].maxsolutions = _nj15;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

} else
{
{
IkReal j15array[1], cj15array[1], sj15array[1];
bool j15valid[1]={false};
_nj15 = 1;
CheckValue<IkReal> x443=IKPowWithIntegerCheck(sj14,-1);
if(!x443.valid){
continue;
}
if( IKabs((new_r21*(x443.value))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((-1.0)*new_r11)) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr((new_r21*(x443.value)))+IKsqr(((-1.0)*new_r11))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j15array[0]=IKatan2((new_r21*(x443.value)), ((-1.0)*new_r11));
sj15array[0]=IKsin(j15array[0]);
cj15array[0]=IKcos(j15array[0]);
if( j15array[0] > IKPI )
{
    j15array[0]-=IK2PI;
}
else if( j15array[0] < -IKPI )
{    j15array[0]+=IK2PI;
}
j15valid[0] = true;
for(int ij15 = 0; ij15 < 1; ++ij15)
{
if( !j15valid[ij15] )
{
    continue;
}
_ij15[0] = ij15; _ij15[1] = -1;
for(int iij15 = ij15+1; iij15 < 1; ++iij15)
{
if( j15valid[iij15] && IKabs(cj15array[ij15]-cj15array[iij15]) < IKFAST_SOLUTION_THRESH && IKabs(sj15array[ij15]-sj15array[iij15]) < IKFAST_SOLUTION_THRESH )
{
    j15valid[iij15]=false; _ij15[1] = iij15; break; 
}
}
j15 = j15array[ij15]; cj15 = cj15array[ij15]; sj15 = sj15array[ij15];
{
IkReal evalcond[8];
IkReal x444=IKsin(j15);
IkReal x445=IKcos(j15);
IkReal x446=((1.0)*new_r00);
IkReal x447=((1.0)*sj14);
IkReal x448=((1.0)*new_r01);
IkReal x449=((1.0)*x445);
evalcond[0]=(((sj14*x445))+new_r20);
evalcond[1]=((((-1.0)*x444*x447))+new_r21);
evalcond[2]=((((-1.0)*x444))+(((-1.0)*new_r10)));
evalcond[3]=((((-1.0)*x449))+(((-1.0)*new_r11)));
evalcond[4]=(((cj14*x444))+(((-1.0)*x448)));
evalcond[5]=((((-1.0)*x446))+(((-1.0)*cj14*x449)));
evalcond[6]=((((-1.0)*cj14*x448))+x444+(((-1.0)*new_r21*x447)));
evalcond[7]=((((-1.0)*x449))+(((-1.0)*cj14*x446))+(((-1.0)*new_r20*x447)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(8);
vinfos[0].jointtype = 17;
vinfos[0].foffset = j5;
vinfos[0].indices[0] = _ij5[0];
vinfos[0].indices[1] = _ij5[1];
vinfos[0].maxsolutions = _nj5;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j9;
vinfos[1].indices[0] = _ij9[0];
vinfos[1].indices[1] = _ij9[1];
vinfos[1].maxsolutions = _nj9;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j10;
vinfos[2].indices[0] = _ij10[0];
vinfos[2].indices[1] = _ij10[1];
vinfos[2].maxsolutions = _nj10;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j11;
vinfos[3].indices[0] = _ij11[0];
vinfos[3].indices[1] = _ij11[1];
vinfos[3].maxsolutions = _nj11;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j12;
vinfos[4].indices[0] = _ij12[0];
vinfos[4].indices[1] = _ij12[1];
vinfos[4].maxsolutions = _nj12;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j13;
vinfos[5].indices[0] = _ij13[0];
vinfos[5].indices[1] = _ij13[1];
vinfos[5].maxsolutions = _nj13;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j14;
vinfos[6].indices[0] = _ij14[0];
vinfos[6].indices[1] = _ij14[1];
vinfos[6].maxsolutions = _nj14;
vinfos[7].jointtype = 1;
vinfos[7].foffset = j15;
vinfos[7].indices[0] = _ij15[0];
vinfos[7].indices[1] = _ij15[1];
vinfos[7].maxsolutions = _nj15;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

} else
{
{
IkReal j15array[1], cj15array[1], sj15array[1];
bool j15valid[1]={false};
_nj15 = 1;
CheckValue<IkReal> x450=IKPowWithIntegerCheck(IKsign(sj14),-1);
if(!x450.valid){
continue;
}
CheckValue<IkReal> x451 = IKatan2WithCheck(IkReal(new_r21),IkReal(((-1.0)*new_r20)),IKFAST_ATAN2_MAGTHRESH);
if(!x451.valid){
continue;
}
j15array[0]=((-1.5707963267949)+(((1.5707963267949)*(x450.value)))+(x451.value));
sj15array[0]=IKsin(j15array[0]);
cj15array[0]=IKcos(j15array[0]);
if( j15array[0] > IKPI )
{
    j15array[0]-=IK2PI;
}
else if( j15array[0] < -IKPI )
{    j15array[0]+=IK2PI;
}
j15valid[0] = true;
for(int ij15 = 0; ij15 < 1; ++ij15)
{
if( !j15valid[ij15] )
{
    continue;
}
_ij15[0] = ij15; _ij15[1] = -1;
for(int iij15 = ij15+1; iij15 < 1; ++iij15)
{
if( j15valid[iij15] && IKabs(cj15array[ij15]-cj15array[iij15]) < IKFAST_SOLUTION_THRESH && IKabs(sj15array[ij15]-sj15array[iij15]) < IKFAST_SOLUTION_THRESH )
{
    j15valid[iij15]=false; _ij15[1] = iij15; break; 
}
}
j15 = j15array[ij15]; cj15 = cj15array[ij15]; sj15 = sj15array[ij15];
{
IkReal evalcond[8];
IkReal x452=IKsin(j15);
IkReal x453=IKcos(j15);
IkReal x454=((1.0)*new_r00);
IkReal x455=((1.0)*sj14);
IkReal x456=((1.0)*new_r01);
IkReal x457=((1.0)*x453);
evalcond[0]=(((sj14*x453))+new_r20);
evalcond[1]=((((-1.0)*x452*x455))+new_r21);
evalcond[2]=((((-1.0)*x452))+(((-1.0)*new_r10)));
evalcond[3]=((((-1.0)*x457))+(((-1.0)*new_r11)));
evalcond[4]=((((-1.0)*x456))+((cj14*x452)));
evalcond[5]=((((-1.0)*cj14*x457))+(((-1.0)*x454)));
evalcond[6]=((((-1.0)*new_r21*x455))+(((-1.0)*cj14*x456))+x452);
evalcond[7]=((((-1.0)*new_r20*x455))+(((-1.0)*cj14*x454))+(((-1.0)*x457)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(8);
vinfos[0].jointtype = 17;
vinfos[0].foffset = j5;
vinfos[0].indices[0] = _ij5[0];
vinfos[0].indices[1] = _ij5[1];
vinfos[0].maxsolutions = _nj5;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j9;
vinfos[1].indices[0] = _ij9[0];
vinfos[1].indices[1] = _ij9[1];
vinfos[1].maxsolutions = _nj9;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j10;
vinfos[2].indices[0] = _ij10[0];
vinfos[2].indices[1] = _ij10[1];
vinfos[2].maxsolutions = _nj10;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j11;
vinfos[3].indices[0] = _ij11[0];
vinfos[3].indices[1] = _ij11[1];
vinfos[3].maxsolutions = _nj11;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j12;
vinfos[4].indices[0] = _ij12[0];
vinfos[4].indices[1] = _ij12[1];
vinfos[4].maxsolutions = _nj12;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j13;
vinfos[5].indices[0] = _ij13[0];
vinfos[5].indices[1] = _ij13[1];
vinfos[5].maxsolutions = _nj13;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j14;
vinfos[6].indices[0] = _ij14[0];
vinfos[6].indices[1] = _ij14[1];
vinfos[6].maxsolutions = _nj14;
vinfos[7].jointtype = 1;
vinfos[7].foffset = j15;
vinfos[7].indices[0] = _ij15[0];
vinfos[7].indices[1] = _ij15[1];
vinfos[7].maxsolutions = _nj15;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(j14))), 6.28318530717959)));
evalcond[1]=new_r20;
evalcond[2]=new_r02;
evalcond[3]=new_r12;
evalcond[4]=new_r21;
if( IKabs(evalcond[0]) < 0.0000050000000000  && IKabs(evalcond[1]) < 0.0000050000000000  && IKabs(evalcond[2]) < 0.0000050000000000  && IKabs(evalcond[3]) < 0.0000050000000000  && IKabs(evalcond[4]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j15array[1], cj15array[1], sj15array[1];
bool j15valid[1]={false};
_nj15 = 1;
IkReal x458=((1.0)*new_r01);
if( IKabs(((((-1.0)*new_r00*sj13))+(((-1.0)*cj13*x458)))) < IKFAST_ATAN2_MAGTHRESH && IKabs((((cj13*new_r00))+(((-1.0)*sj13*x458)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((((-1.0)*new_r00*sj13))+(((-1.0)*cj13*x458))))+IKsqr((((cj13*new_r00))+(((-1.0)*sj13*x458))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j15array[0]=IKatan2(((((-1.0)*new_r00*sj13))+(((-1.0)*cj13*x458))), (((cj13*new_r00))+(((-1.0)*sj13*x458))));
sj15array[0]=IKsin(j15array[0]);
cj15array[0]=IKcos(j15array[0]);
if( j15array[0] > IKPI )
{
    j15array[0]-=IK2PI;
}
else if( j15array[0] < -IKPI )
{    j15array[0]+=IK2PI;
}
j15valid[0] = true;
for(int ij15 = 0; ij15 < 1; ++ij15)
{
if( !j15valid[ij15] )
{
    continue;
}
_ij15[0] = ij15; _ij15[1] = -1;
for(int iij15 = ij15+1; iij15 < 1; ++iij15)
{
if( j15valid[iij15] && IKabs(cj15array[ij15]-cj15array[iij15]) < IKFAST_SOLUTION_THRESH && IKabs(sj15array[ij15]-sj15array[iij15]) < IKFAST_SOLUTION_THRESH )
{
    j15valid[iij15]=false; _ij15[1] = iij15; break; 
}
}
j15 = j15array[ij15]; cj15 = cj15array[ij15]; sj15 = sj15array[ij15];
{
IkReal evalcond[8];
IkReal x459=IKsin(j15);
IkReal x460=IKcos(j15);
IkReal x461=((1.0)*cj13);
IkReal x462=((1.0)*sj13);
IkReal x463=((1.0)*x460);
IkReal x464=(sj13*x459);
IkReal x465=(x460*x461);
evalcond[0]=(((cj13*new_r01))+x459+((new_r11*sj13)));
evalcond[1]=(((cj13*x459))+((sj13*x460))+new_r01);
evalcond[2]=(((cj13*new_r00))+(((-1.0)*x463))+((new_r10*sj13)));
evalcond[3]=(((cj13*new_r10))+(((-1.0)*x459))+(((-1.0)*new_r00*x462)));
evalcond[4]=(((cj13*new_r11))+(((-1.0)*new_r01*x462))+(((-1.0)*x463)));
evalcond[5]=((((-1.0)*x465))+x464+new_r00);
evalcond[6]=((((-1.0)*x465))+x464+new_r11);
evalcond[7]=((((-1.0)*x460*x462))+(((-1.0)*x459*x461))+new_r10);
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(8);
vinfos[0].jointtype = 17;
vinfos[0].foffset = j5;
vinfos[0].indices[0] = _ij5[0];
vinfos[0].indices[1] = _ij5[1];
vinfos[0].maxsolutions = _nj5;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j9;
vinfos[1].indices[0] = _ij9[0];
vinfos[1].indices[1] = _ij9[1];
vinfos[1].maxsolutions = _nj9;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j10;
vinfos[2].indices[0] = _ij10[0];
vinfos[2].indices[1] = _ij10[1];
vinfos[2].maxsolutions = _nj10;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j11;
vinfos[3].indices[0] = _ij11[0];
vinfos[3].indices[1] = _ij11[1];
vinfos[3].maxsolutions = _nj11;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j12;
vinfos[4].indices[0] = _ij12[0];
vinfos[4].indices[1] = _ij12[1];
vinfos[4].maxsolutions = _nj12;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j13;
vinfos[5].indices[0] = _ij13[0];
vinfos[5].indices[1] = _ij13[1];
vinfos[5].maxsolutions = _nj13;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j14;
vinfos[6].indices[0] = _ij14[0];
vinfos[6].indices[1] = _ij14[1];
vinfos[6].maxsolutions = _nj14;
vinfos[7].jointtype = 1;
vinfos[7].foffset = j15;
vinfos[7].indices[0] = _ij15[0];
vinfos[7].indices[1] = _ij15[1];
vinfos[7].maxsolutions = _nj15;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((-3.14159265358979)+j14)))), 6.28318530717959)));
evalcond[1]=new_r20;
evalcond[2]=new_r02;
evalcond[3]=new_r12;
evalcond[4]=new_r21;
if( IKabs(evalcond[0]) < 0.0000050000000000  && IKabs(evalcond[1]) < 0.0000050000000000  && IKabs(evalcond[2]) < 0.0000050000000000  && IKabs(evalcond[3]) < 0.0000050000000000  && IKabs(evalcond[4]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j15array[1], cj15array[1], sj15array[1];
bool j15valid[1]={false};
_nj15 = 1;
IkReal x466=((1.0)*new_r00);
if( IKabs((((cj13*new_r01))+(((-1.0)*sj13*x466)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((((-1.0)*new_r01*sj13))+(((-1.0)*cj13*x466)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr((((cj13*new_r01))+(((-1.0)*sj13*x466))))+IKsqr(((((-1.0)*new_r01*sj13))+(((-1.0)*cj13*x466))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j15array[0]=IKatan2((((cj13*new_r01))+(((-1.0)*sj13*x466))), ((((-1.0)*new_r01*sj13))+(((-1.0)*cj13*x466))));
sj15array[0]=IKsin(j15array[0]);
cj15array[0]=IKcos(j15array[0]);
if( j15array[0] > IKPI )
{
    j15array[0]-=IK2PI;
}
else if( j15array[0] < -IKPI )
{    j15array[0]+=IK2PI;
}
j15valid[0] = true;
for(int ij15 = 0; ij15 < 1; ++ij15)
{
if( !j15valid[ij15] )
{
    continue;
}
_ij15[0] = ij15; _ij15[1] = -1;
for(int iij15 = ij15+1; iij15 < 1; ++iij15)
{
if( j15valid[iij15] && IKabs(cj15array[ij15]-cj15array[iij15]) < IKFAST_SOLUTION_THRESH && IKabs(sj15array[ij15]-sj15array[iij15]) < IKFAST_SOLUTION_THRESH )
{
    j15valid[iij15]=false; _ij15[1] = iij15; break; 
}
}
j15 = j15array[ij15]; cj15 = cj15array[ij15]; sj15 = sj15array[ij15];
{
IkReal evalcond[8];
IkReal x467=IKsin(j15);
IkReal x468=IKcos(j15);
IkReal x469=((1.0)*cj13);
IkReal x470=((1.0)*sj13);
IkReal x471=((1.0)*x467);
IkReal x472=(sj13*x468);
IkReal x473=(x467*x469);
evalcond[0]=(((cj13*new_r00))+x468+((new_r10*sj13)));
evalcond[1]=(((cj13*new_r01))+(((-1.0)*x471))+((new_r11*sj13)));
evalcond[2]=(((cj13*x468))+((sj13*x467))+new_r00);
evalcond[3]=(((cj13*new_r10))+(((-1.0)*new_r00*x470))+(((-1.0)*x471)));
evalcond[4]=(((cj13*new_r11))+(((-1.0)*x468))+(((-1.0)*new_r01*x470)));
evalcond[5]=((((-1.0)*x473))+x472+new_r01);
evalcond[6]=((((-1.0)*x473))+x472+new_r10);
evalcond[7]=((((-1.0)*x467*x470))+(((-1.0)*x468*x469))+new_r11);
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(8);
vinfos[0].jointtype = 17;
vinfos[0].foffset = j5;
vinfos[0].indices[0] = _ij5[0];
vinfos[0].indices[1] = _ij5[1];
vinfos[0].maxsolutions = _nj5;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j9;
vinfos[1].indices[0] = _ij9[0];
vinfos[1].indices[1] = _ij9[1];
vinfos[1].maxsolutions = _nj9;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j10;
vinfos[2].indices[0] = _ij10[0];
vinfos[2].indices[1] = _ij10[1];
vinfos[2].maxsolutions = _nj10;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j11;
vinfos[3].indices[0] = _ij11[0];
vinfos[3].indices[1] = _ij11[1];
vinfos[3].maxsolutions = _nj11;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j12;
vinfos[4].indices[0] = _ij12[0];
vinfos[4].indices[1] = _ij12[1];
vinfos[4].maxsolutions = _nj12;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j13;
vinfos[5].indices[0] = _ij13[0];
vinfos[5].indices[1] = _ij13[1];
vinfos[5].maxsolutions = _nj13;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j14;
vinfos[6].indices[0] = _ij14[0];
vinfos[6].indices[1] = _ij14[1];
vinfos[6].maxsolutions = _nj14;
vinfos[7].jointtype = 1;
vinfos[7].foffset = j15;
vinfos[7].indices[0] = _ij15[0];
vinfos[7].indices[1] = _ij15[1];
vinfos[7].maxsolutions = _nj15;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((IKabs(new_r20))+(IKabs(new_r21)));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j15eval[1];
new_r21=0;
new_r20=0;
new_r02=0;
new_r12=0;
j15eval[0]=1.0;
if( IKabs(j15eval[0]) < 0.0000000100000000  )
{
continue; // no branches [j15]

} else
{
IkReal op[2+1], zeror[2];
int numroots;
op[0]=1.0;
op[1]=0;
op[2]=-1.0;
polyroots2(op,zeror,numroots);
IkReal j15array[2], cj15array[2], sj15array[2], tempj15array[1];
int numsolutions = 0;
for(int ij15 = 0; ij15 < numroots; ++ij15)
{
IkReal htj15 = zeror[ij15];
tempj15array[0]=((2.0)*(atan(htj15)));
for(int kj15 = 0; kj15 < 1; ++kj15)
{
j15array[numsolutions] = tempj15array[kj15];
if( j15array[numsolutions] > IKPI )
{
    j15array[numsolutions]-=IK2PI;
}
else if( j15array[numsolutions] < -IKPI )
{
    j15array[numsolutions]+=IK2PI;
}
sj15array[numsolutions] = IKsin(j15array[numsolutions]);
cj15array[numsolutions] = IKcos(j15array[numsolutions]);
numsolutions++;
}
}
bool j15valid[2]={true,true};
_nj15 = 2;
for(int ij15 = 0; ij15 < numsolutions; ++ij15)
    {
if( !j15valid[ij15] )
{
    continue;
}
    j15 = j15array[ij15]; cj15 = cj15array[ij15]; sj15 = sj15array[ij15];
htj15 = IKtan(j15/2);

_ij15[0] = ij15; _ij15[1] = -1;
for(int iij15 = ij15+1; iij15 < numsolutions; ++iij15)
{
if( j15valid[iij15] && IKabs(cj15array[ij15]-cj15array[iij15]) < IKFAST_SOLUTION_THRESH && IKabs(sj15array[ij15]-sj15array[iij15]) < IKFAST_SOLUTION_THRESH )
{
    j15valid[iij15]=false; _ij15[1] = iij15; break; 
}
}
{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(8);
vinfos[0].jointtype = 17;
vinfos[0].foffset = j5;
vinfos[0].indices[0] = _ij5[0];
vinfos[0].indices[1] = _ij5[1];
vinfos[0].maxsolutions = _nj5;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j9;
vinfos[1].indices[0] = _ij9[0];
vinfos[1].indices[1] = _ij9[1];
vinfos[1].maxsolutions = _nj9;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j10;
vinfos[2].indices[0] = _ij10[0];
vinfos[2].indices[1] = _ij10[1];
vinfos[2].maxsolutions = _nj10;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j11;
vinfos[3].indices[0] = _ij11[0];
vinfos[3].indices[1] = _ij11[1];
vinfos[3].maxsolutions = _nj11;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j12;
vinfos[4].indices[0] = _ij12[0];
vinfos[4].indices[1] = _ij12[1];
vinfos[4].maxsolutions = _nj12;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j13;
vinfos[5].indices[0] = _ij13[0];
vinfos[5].indices[1] = _ij13[1];
vinfos[5].maxsolutions = _nj13;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j14;
vinfos[6].indices[0] = _ij14[0];
vinfos[6].indices[1] = _ij14[1];
vinfos[6].maxsolutions = _nj14;
vinfos[7].jointtype = 1;
vinfos[7].foffset = j15;
vinfos[7].indices[0] = _ij15[0];
vinfos[7].indices[1] = _ij15[1];
vinfos[7].maxsolutions = _nj15;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
    }

}

}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
if( 1 )
{
bgotonextstatement=false;
continue; // branch miss [j15]

}
} while(0);
if( bgotonextstatement )
{
}
}
}
}
}
}
}
}
}

} else
{
{
IkReal j15array[1], cj15array[1], sj15array[1];
bool j15valid[1]={false};
_nj15 = 1;
CheckValue<IkReal> x475=IKPowWithIntegerCheck(sj14,-1);
if(!x475.valid){
continue;
}
IkReal x474=x475.value;
CheckValue<IkReal> x476=IKPowWithIntegerCheck(cj14,-1);
if(!x476.valid){
continue;
}
CheckValue<IkReal> x477=IKPowWithIntegerCheck(sj13,-1);
if(!x477.valid){
continue;
}
if( IKabs((x474*(x476.value)*(x477.value)*(((((-1.0)*cj13*new_r20))+(((-1.0)*new_r11*sj14)))))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((-1.0)*new_r20*x474)) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr((x474*(x476.value)*(x477.value)*(((((-1.0)*cj13*new_r20))+(((-1.0)*new_r11*sj14))))))+IKsqr(((-1.0)*new_r20*x474))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j15array[0]=IKatan2((x474*(x476.value)*(x477.value)*(((((-1.0)*cj13*new_r20))+(((-1.0)*new_r11*sj14))))), ((-1.0)*new_r20*x474));
sj15array[0]=IKsin(j15array[0]);
cj15array[0]=IKcos(j15array[0]);
if( j15array[0] > IKPI )
{
    j15array[0]-=IK2PI;
}
else if( j15array[0] < -IKPI )
{    j15array[0]+=IK2PI;
}
j15valid[0] = true;
for(int ij15 = 0; ij15 < 1; ++ij15)
{
if( !j15valid[ij15] )
{
    continue;
}
_ij15[0] = ij15; _ij15[1] = -1;
for(int iij15 = ij15+1; iij15 < 1; ++iij15)
{
if( j15valid[iij15] && IKabs(cj15array[ij15]-cj15array[iij15]) < IKFAST_SOLUTION_THRESH && IKabs(sj15array[ij15]-sj15array[iij15]) < IKFAST_SOLUTION_THRESH )
{
    j15valid[iij15]=false; _ij15[1] = iij15; break; 
}
}
j15 = j15array[ij15]; cj15 = cj15array[ij15]; sj15 = sj15array[ij15];
{
IkReal evalcond[12];
IkReal x478=IKsin(j15);
IkReal x479=IKcos(j15);
IkReal x480=(cj13*cj14);
IkReal x481=((1.0)*sj14);
IkReal x482=(cj14*sj13);
IkReal x483=((1.0)*sj13);
IkReal x484=((1.0)*x479);
IkReal x485=((1.0)*x478);
evalcond[0]=(((sj14*x479))+new_r20);
evalcond[1]=(new_r21+(((-1.0)*x478*x481)));
evalcond[2]=(((cj13*new_r01))+((cj14*x478))+((new_r11*sj13)));
evalcond[3]=(((cj13*new_r10))+(((-1.0)*x485))+(((-1.0)*new_r00*x483)));
evalcond[4]=((((-1.0)*new_r01*x483))+((cj13*new_r11))+(((-1.0)*x484)));
evalcond[5]=(((sj13*x479))+((x478*x480))+new_r01);
evalcond[6]=(((cj13*new_r00))+(((-1.0)*cj14*x484))+((new_r10*sj13)));
evalcond[7]=(((sj13*x478))+(((-1.0)*x480*x484))+new_r00);
evalcond[8]=((((-1.0)*cj13*x484))+((x478*x482))+new_r11);
evalcond[9]=((((-1.0)*cj13*x485))+(((-1.0)*x482*x484))+new_r10);
evalcond[10]=((((-1.0)*new_r21*x481))+((new_r11*x482))+x478+((new_r01*x480)));
evalcond[11]=((((-1.0)*x484))+(((-1.0)*new_r20*x481))+((new_r10*x482))+((new_r00*x480)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[8]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[9]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[10]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[11]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(8);
vinfos[0].jointtype = 17;
vinfos[0].foffset = j5;
vinfos[0].indices[0] = _ij5[0];
vinfos[0].indices[1] = _ij5[1];
vinfos[0].maxsolutions = _nj5;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j9;
vinfos[1].indices[0] = _ij9[0];
vinfos[1].indices[1] = _ij9[1];
vinfos[1].maxsolutions = _nj9;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j10;
vinfos[2].indices[0] = _ij10[0];
vinfos[2].indices[1] = _ij10[1];
vinfos[2].maxsolutions = _nj10;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j11;
vinfos[3].indices[0] = _ij11[0];
vinfos[3].indices[1] = _ij11[1];
vinfos[3].maxsolutions = _nj11;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j12;
vinfos[4].indices[0] = _ij12[0];
vinfos[4].indices[1] = _ij12[1];
vinfos[4].maxsolutions = _nj12;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j13;
vinfos[5].indices[0] = _ij13[0];
vinfos[5].indices[1] = _ij13[1];
vinfos[5].maxsolutions = _nj13;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j14;
vinfos[6].indices[0] = _ij14[0];
vinfos[6].indices[1] = _ij14[1];
vinfos[6].maxsolutions = _nj14;
vinfos[7].jointtype = 1;
vinfos[7].foffset = j15;
vinfos[7].indices[0] = _ij15[0];
vinfos[7].indices[1] = _ij15[1];
vinfos[7].maxsolutions = _nj15;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

} else
{
{
IkReal j15array[1], cj15array[1], sj15array[1];
bool j15valid[1]={false};
_nj15 = 1;
CheckValue<IkReal> x487=IKPowWithIntegerCheck(sj14,-1);
if(!x487.valid){
continue;
}
IkReal x486=x487.value;
CheckValue<IkReal> x488=IKPowWithIntegerCheck(sj13,-1);
if(!x488.valid){
continue;
}
if( IKabs((new_r21*x486)) < IKFAST_ATAN2_MAGTHRESH && IKabs((x486*(x488.value)*(((((-1.0)*cj13*cj14*new_r21))+(((-1.0)*new_r01*sj14)))))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr((new_r21*x486))+IKsqr((x486*(x488.value)*(((((-1.0)*cj13*cj14*new_r21))+(((-1.0)*new_r01*sj14))))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j15array[0]=IKatan2((new_r21*x486), (x486*(x488.value)*(((((-1.0)*cj13*cj14*new_r21))+(((-1.0)*new_r01*sj14))))));
sj15array[0]=IKsin(j15array[0]);
cj15array[0]=IKcos(j15array[0]);
if( j15array[0] > IKPI )
{
    j15array[0]-=IK2PI;
}
else if( j15array[0] < -IKPI )
{    j15array[0]+=IK2PI;
}
j15valid[0] = true;
for(int ij15 = 0; ij15 < 1; ++ij15)
{
if( !j15valid[ij15] )
{
    continue;
}
_ij15[0] = ij15; _ij15[1] = -1;
for(int iij15 = ij15+1; iij15 < 1; ++iij15)
{
if( j15valid[iij15] && IKabs(cj15array[ij15]-cj15array[iij15]) < IKFAST_SOLUTION_THRESH && IKabs(sj15array[ij15]-sj15array[iij15]) < IKFAST_SOLUTION_THRESH )
{
    j15valid[iij15]=false; _ij15[1] = iij15; break; 
}
}
j15 = j15array[ij15]; cj15 = cj15array[ij15]; sj15 = sj15array[ij15];
{
IkReal evalcond[12];
IkReal x489=IKsin(j15);
IkReal x490=IKcos(j15);
IkReal x491=(cj13*cj14);
IkReal x492=((1.0)*sj14);
IkReal x493=(cj14*sj13);
IkReal x494=((1.0)*sj13);
IkReal x495=((1.0)*x490);
IkReal x496=((1.0)*x489);
evalcond[0]=(new_r20+((sj14*x490)));
evalcond[1]=((((-1.0)*x489*x492))+new_r21);
evalcond[2]=(((cj13*new_r01))+((new_r11*sj13))+((cj14*x489)));
evalcond[3]=((((-1.0)*new_r00*x494))+(((-1.0)*x496))+((cj13*new_r10)));
evalcond[4]=((((-1.0)*x495))+((cj13*new_r11))+(((-1.0)*new_r01*x494)));
evalcond[5]=(((x489*x491))+new_r01+((sj13*x490)));
evalcond[6]=(((cj13*new_r00))+(((-1.0)*cj14*x495))+((new_r10*sj13)));
evalcond[7]=(((sj13*x489))+(((-1.0)*x491*x495))+new_r00);
evalcond[8]=(((x489*x493))+(((-1.0)*cj13*x495))+new_r11);
evalcond[9]=((((-1.0)*x493*x495))+(((-1.0)*cj13*x496))+new_r10);
evalcond[10]=((((-1.0)*new_r21*x492))+((new_r11*x493))+x489+((new_r01*x491)));
evalcond[11]=((((-1.0)*new_r20*x492))+(((-1.0)*x495))+((new_r10*x493))+((new_r00*x491)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[8]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[9]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[10]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[11]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(8);
vinfos[0].jointtype = 17;
vinfos[0].foffset = j5;
vinfos[0].indices[0] = _ij5[0];
vinfos[0].indices[1] = _ij5[1];
vinfos[0].maxsolutions = _nj5;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j9;
vinfos[1].indices[0] = _ij9[0];
vinfos[1].indices[1] = _ij9[1];
vinfos[1].maxsolutions = _nj9;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j10;
vinfos[2].indices[0] = _ij10[0];
vinfos[2].indices[1] = _ij10[1];
vinfos[2].maxsolutions = _nj10;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j11;
vinfos[3].indices[0] = _ij11[0];
vinfos[3].indices[1] = _ij11[1];
vinfos[3].maxsolutions = _nj11;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j12;
vinfos[4].indices[0] = _ij12[0];
vinfos[4].indices[1] = _ij12[1];
vinfos[4].maxsolutions = _nj12;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j13;
vinfos[5].indices[0] = _ij13[0];
vinfos[5].indices[1] = _ij13[1];
vinfos[5].maxsolutions = _nj13;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j14;
vinfos[6].indices[0] = _ij14[0];
vinfos[6].indices[1] = _ij14[1];
vinfos[6].maxsolutions = _nj14;
vinfos[7].jointtype = 1;
vinfos[7].foffset = j15;
vinfos[7].indices[0] = _ij15[0];
vinfos[7].indices[1] = _ij15[1];
vinfos[7].maxsolutions = _nj15;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

} else
{
{
IkReal j15array[1], cj15array[1], sj15array[1];
bool j15valid[1]={false};
_nj15 = 1;
CheckValue<IkReal> x497=IKPowWithIntegerCheck(IKsign(sj14),-1);
if(!x497.valid){
continue;
}
CheckValue<IkReal> x498 = IKatan2WithCheck(IkReal(new_r21),IkReal(((-1.0)*new_r20)),IKFAST_ATAN2_MAGTHRESH);
if(!x498.valid){
continue;
}
j15array[0]=((-1.5707963267949)+(((1.5707963267949)*(x497.value)))+(x498.value));
sj15array[0]=IKsin(j15array[0]);
cj15array[0]=IKcos(j15array[0]);
if( j15array[0] > IKPI )
{
    j15array[0]-=IK2PI;
}
else if( j15array[0] < -IKPI )
{    j15array[0]+=IK2PI;
}
j15valid[0] = true;
for(int ij15 = 0; ij15 < 1; ++ij15)
{
if( !j15valid[ij15] )
{
    continue;
}
_ij15[0] = ij15; _ij15[1] = -1;
for(int iij15 = ij15+1; iij15 < 1; ++iij15)
{
if( j15valid[iij15] && IKabs(cj15array[ij15]-cj15array[iij15]) < IKFAST_SOLUTION_THRESH && IKabs(sj15array[ij15]-sj15array[iij15]) < IKFAST_SOLUTION_THRESH )
{
    j15valid[iij15]=false; _ij15[1] = iij15; break; 
}
}
j15 = j15array[ij15]; cj15 = cj15array[ij15]; sj15 = sj15array[ij15];
{
IkReal evalcond[12];
IkReal x499=IKsin(j15);
IkReal x500=IKcos(j15);
IkReal x501=(cj13*cj14);
IkReal x502=((1.0)*sj14);
IkReal x503=(cj14*sj13);
IkReal x504=((1.0)*sj13);
IkReal x505=((1.0)*x500);
IkReal x506=((1.0)*x499);
evalcond[0]=(new_r20+((sj14*x500)));
evalcond[1]=((((-1.0)*x499*x502))+new_r21);
evalcond[2]=(((cj13*new_r01))+((new_r11*sj13))+((cj14*x499)));
evalcond[3]=(((cj13*new_r10))+(((-1.0)*new_r00*x504))+(((-1.0)*x506)));
evalcond[4]=((((-1.0)*new_r01*x504))+((cj13*new_r11))+(((-1.0)*x505)));
evalcond[5]=(new_r01+((sj13*x500))+((x499*x501)));
evalcond[6]=(((cj13*new_r00))+(((-1.0)*cj14*x505))+((new_r10*sj13)));
evalcond[7]=((((-1.0)*x501*x505))+new_r00+((sj13*x499)));
evalcond[8]=(new_r11+((x499*x503))+(((-1.0)*cj13*x505)));
evalcond[9]=((((-1.0)*x503*x505))+new_r10+(((-1.0)*cj13*x506)));
evalcond[10]=((((-1.0)*new_r21*x502))+((new_r11*x503))+x499+((new_r01*x501)));
evalcond[11]=((((-1.0)*new_r20*x502))+(((-1.0)*x505))+((new_r10*x503))+((new_r00*x501)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[8]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[9]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[10]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[11]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(8);
vinfos[0].jointtype = 17;
vinfos[0].foffset = j5;
vinfos[0].indices[0] = _ij5[0];
vinfos[0].indices[1] = _ij5[1];
vinfos[0].maxsolutions = _nj5;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j9;
vinfos[1].indices[0] = _ij9[0];
vinfos[1].indices[1] = _ij9[1];
vinfos[1].maxsolutions = _nj9;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j10;
vinfos[2].indices[0] = _ij10[0];
vinfos[2].indices[1] = _ij10[1];
vinfos[2].maxsolutions = _nj10;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j11;
vinfos[3].indices[0] = _ij11[0];
vinfos[3].indices[1] = _ij11[1];
vinfos[3].maxsolutions = _nj11;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j12;
vinfos[4].indices[0] = _ij12[0];
vinfos[4].indices[1] = _ij12[1];
vinfos[4].maxsolutions = _nj12;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j13;
vinfos[5].indices[0] = _ij13[0];
vinfos[5].indices[1] = _ij13[1];
vinfos[5].maxsolutions = _nj13;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j14;
vinfos[6].indices[0] = _ij14[0];
vinfos[6].indices[1] = _ij14[1];
vinfos[6].maxsolutions = _nj14;
vinfos[7].jointtype = 1;
vinfos[7].foffset = j15;
vinfos[7].indices[0] = _ij15[0];
vinfos[7].indices[1] = _ij15[1];
vinfos[7].maxsolutions = _nj15;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}
}
}

}

}

} else
{
{
IkReal j15array[1], cj15array[1], sj15array[1];
bool j15valid[1]={false};
_nj15 = 1;
CheckValue<IkReal> x507=IKPowWithIntegerCheck(IKsign(sj14),-1);
if(!x507.valid){
continue;
}
CheckValue<IkReal> x508 = IKatan2WithCheck(IkReal(new_r21),IkReal(((-1.0)*new_r20)),IKFAST_ATAN2_MAGTHRESH);
if(!x508.valid){
continue;
}
j15array[0]=((-1.5707963267949)+(((1.5707963267949)*(x507.value)))+(x508.value));
sj15array[0]=IKsin(j15array[0]);
cj15array[0]=IKcos(j15array[0]);
if( j15array[0] > IKPI )
{
    j15array[0]-=IK2PI;
}
else if( j15array[0] < -IKPI )
{    j15array[0]+=IK2PI;
}
j15valid[0] = true;
for(int ij15 = 0; ij15 < 1; ++ij15)
{
if( !j15valid[ij15] )
{
    continue;
}
_ij15[0] = ij15; _ij15[1] = -1;
for(int iij15 = ij15+1; iij15 < 1; ++iij15)
{
if( j15valid[iij15] && IKabs(cj15array[ij15]-cj15array[iij15]) < IKFAST_SOLUTION_THRESH && IKabs(sj15array[ij15]-sj15array[iij15]) < IKFAST_SOLUTION_THRESH )
{
    j15valid[iij15]=false; _ij15[1] = iij15; break; 
}
}
j15 = j15array[ij15]; cj15 = cj15array[ij15]; sj15 = sj15array[ij15];
{
IkReal evalcond[2];
evalcond[0]=(((sj14*(IKcos(j15))))+new_r20);
evalcond[1]=((((-1.0)*sj14*(IKsin(j15))))+new_r21);
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
IkReal j13eval[3];
j13eval[0]=sj14;
j13eval[1]=IKsign(sj14);
j13eval[2]=((IKabs(new_r12))+(IKabs(new_r02)));
if( IKabs(j13eval[0]) < 0.0000010000000000  || IKabs(j13eval[1]) < 0.0000010000000000  || IKabs(j13eval[2]) < 0.0000010000000000  )
{
{
IkReal j13eval[2];
j13eval[0]=cj15;
j13eval[1]=sj14;
if( IKabs(j13eval[0]) < 0.0000010000000000  || IKabs(j13eval[1]) < 0.0000010000000000  )
{
{
IkReal evalcond[5];
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((-1.5707963267949)+j15)))), 6.28318530717959)));
evalcond[1]=new_r20;
if( IKabs(evalcond[0]) < 0.0000050000000000  && IKabs(evalcond[1]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j13array[1], cj13array[1], sj13array[1];
bool j13valid[1]={false};
_nj13 = 1;
if( IKabs(((-1.0)*new_r00)) < IKFAST_ATAN2_MAGTHRESH && IKabs(new_r10) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((-1.0)*new_r00))+IKsqr(new_r10)-1) <= IKFAST_SINCOS_THRESH )
    continue;
j13array[0]=IKatan2(((-1.0)*new_r00), new_r10);
sj13array[0]=IKsin(j13array[0]);
cj13array[0]=IKcos(j13array[0]);
if( j13array[0] > IKPI )
{
    j13array[0]-=IK2PI;
}
else if( j13array[0] < -IKPI )
{    j13array[0]+=IK2PI;
}
j13valid[0] = true;
for(int ij13 = 0; ij13 < 1; ++ij13)
{
if( !j13valid[ij13] )
{
    continue;
}
_ij13[0] = ij13; _ij13[1] = -1;
for(int iij13 = ij13+1; iij13 < 1; ++iij13)
{
if( j13valid[iij13] && IKabs(cj13array[ij13]-cj13array[iij13]) < IKFAST_SOLUTION_THRESH && IKabs(sj13array[ij13]-sj13array[iij13]) < IKFAST_SOLUTION_THRESH )
{
    j13valid[iij13]=false; _ij13[1] = iij13; break; 
}
}
j13 = j13array[ij13]; cj13 = cj13array[ij13]; sj13 = sj13array[ij13];
{
IkReal evalcond[18];
IkReal x509=IKsin(j13);
IkReal x510=IKcos(j13);
IkReal x511=((1.0)*sj14);
IkReal x512=(new_r01*x510);
IkReal x513=(new_r00*x510);
IkReal x514=(new_r11*x509);
IkReal x515=(new_r22*x509);
IkReal x516=(sj14*x510);
IkReal x517=((1.0)*x509);
IkReal x518=(new_r22*x510);
IkReal x519=(new_r10*x509);
IkReal x520=(new_r12*x509);
evalcond[0]=(x509+new_r00);
evalcond[1]=(x518+new_r01);
evalcond[2]=(x515+new_r11);
evalcond[3]=((((-1.0)*x510))+new_r10);
evalcond[4]=(new_r02+(((-1.0)*x510*x511)));
evalcond[5]=(new_r12+(((-1.0)*x509*x511)));
evalcond[6]=(x519+x513);
evalcond[7]=(((new_r12*x510))+(((-1.0)*new_r02*x517)));
evalcond[8]=(((new_r11*x510))+(((-1.0)*new_r01*x517)));
evalcond[9]=(x514+x512+new_r22);
evalcond[10]=((-1.0)+((new_r10*x510))+(((-1.0)*new_r00*x517)));
evalcond[11]=(((sj14*x513))+((sj14*x519)));
evalcond[12]=(((new_r10*x515))+((new_r22*x513)));
evalcond[13]=(((new_r02*x510))+x520+(((-1.0)*x511)));
evalcond[14]=(((sj14*x514))+((sj14*x512))+((cj14*new_r21)));
evalcond[15]=((-1.0)+((new_r02*x516))+(new_r22*new_r22)+((sj14*x520)));
evalcond[16]=(((new_r02*x518))+((new_r12*x515))+(((-1.0)*new_r22*x511)));
evalcond[17]=((1.0)+(((-1.0)*sj14*x511))+((new_r22*x512))+((new_r22*x514)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[8]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[9]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[10]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[11]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[12]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[13]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[14]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[15]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[16]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[17]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(8);
vinfos[0].jointtype = 17;
vinfos[0].foffset = j5;
vinfos[0].indices[0] = _ij5[0];
vinfos[0].indices[1] = _ij5[1];
vinfos[0].maxsolutions = _nj5;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j9;
vinfos[1].indices[0] = _ij9[0];
vinfos[1].indices[1] = _ij9[1];
vinfos[1].maxsolutions = _nj9;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j10;
vinfos[2].indices[0] = _ij10[0];
vinfos[2].indices[1] = _ij10[1];
vinfos[2].maxsolutions = _nj10;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j11;
vinfos[3].indices[0] = _ij11[0];
vinfos[3].indices[1] = _ij11[1];
vinfos[3].maxsolutions = _nj11;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j12;
vinfos[4].indices[0] = _ij12[0];
vinfos[4].indices[1] = _ij12[1];
vinfos[4].maxsolutions = _nj12;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j13;
vinfos[5].indices[0] = _ij13[0];
vinfos[5].indices[1] = _ij13[1];
vinfos[5].maxsolutions = _nj13;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j14;
vinfos[6].indices[0] = _ij14[0];
vinfos[6].indices[1] = _ij14[1];
vinfos[6].maxsolutions = _nj14;
vinfos[7].jointtype = 1;
vinfos[7].foffset = j15;
vinfos[7].indices[0] = _ij15[0];
vinfos[7].indices[1] = _ij15[1];
vinfos[7].maxsolutions = _nj15;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((1.5707963267949)+j15)))), 6.28318530717959)));
evalcond[1]=new_r20;
if( IKabs(evalcond[0]) < 0.0000050000000000  && IKabs(evalcond[1]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j13array[1], cj13array[1], sj13array[1];
bool j13valid[1]={false};
_nj13 = 1;
if( IKabs(new_r00) < IKFAST_ATAN2_MAGTHRESH && IKabs(((-1.0)*new_r10)) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(new_r00)+IKsqr(((-1.0)*new_r10))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j13array[0]=IKatan2(new_r00, ((-1.0)*new_r10));
sj13array[0]=IKsin(j13array[0]);
cj13array[0]=IKcos(j13array[0]);
if( j13array[0] > IKPI )
{
    j13array[0]-=IK2PI;
}
else if( j13array[0] < -IKPI )
{    j13array[0]+=IK2PI;
}
j13valid[0] = true;
for(int ij13 = 0; ij13 < 1; ++ij13)
{
if( !j13valid[ij13] )
{
    continue;
}
_ij13[0] = ij13; _ij13[1] = -1;
for(int iij13 = ij13+1; iij13 < 1; ++iij13)
{
if( j13valid[iij13] && IKabs(cj13array[ij13]-cj13array[iij13]) < IKFAST_SOLUTION_THRESH && IKabs(sj13array[ij13]-sj13array[iij13]) < IKFAST_SOLUTION_THRESH )
{
    j13valid[iij13]=false; _ij13[1] = iij13; break; 
}
}
j13 = j13array[ij13]; cj13 = cj13array[ij13]; sj13 = sj13array[ij13];
{
IkReal evalcond[18];
IkReal x521=IKcos(j13);
IkReal x522=IKsin(j13);
IkReal x523=((1.0)*sj14);
IkReal x524=((1.0)*new_r22);
IkReal x525=(new_r01*x521);
IkReal x526=(new_r00*x521);
IkReal x527=(new_r11*x522);
IkReal x528=(new_r22*x522);
IkReal x529=(sj14*x521);
IkReal x530=((1.0)*x522);
IkReal x531=(new_r10*x522);
IkReal x532=(new_r12*x522);
IkReal x533=(new_r02*x521);
evalcond[0]=(x521+new_r10);
evalcond[1]=((((-1.0)*x530))+new_r00);
evalcond[2]=((((-1.0)*x521*x523))+new_r02);
evalcond[3]=((((-1.0)*x522*x523))+new_r12);
evalcond[4]=((((-1.0)*x521*x524))+new_r01);
evalcond[5]=((((-1.0)*x522*x524))+new_r11);
evalcond[6]=(x531+x526);
evalcond[7]=(((new_r12*x521))+(((-1.0)*new_r02*x530)));
evalcond[8]=(((new_r11*x521))+(((-1.0)*new_r01*x530)));
evalcond[9]=((1.0)+(((-1.0)*new_r00*x530))+((new_r10*x521)));
evalcond[10]=(((sj14*x531))+((sj14*x526)));
evalcond[11]=(((new_r10*x528))+((new_r22*x526)));
evalcond[12]=((((-1.0)*x523))+x533+x532);
evalcond[13]=((((-1.0)*x524))+x527+x525);
evalcond[14]=(((cj14*new_r21))+((sj14*x527))+((sj14*x525)));
evalcond[15]=((-1.0)+((new_r02*x529))+(new_r22*new_r22)+((sj14*x532)));
evalcond[16]=((((-1.0)*new_r22*x523))+((new_r12*x528))+((new_r22*x533)));
evalcond[17]=((-1.0)+(sj14*sj14)+((new_r22*x525))+((new_r22*x527)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[8]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[9]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[10]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[11]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[12]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[13]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[14]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[15]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[16]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[17]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(8);
vinfos[0].jointtype = 17;
vinfos[0].foffset = j5;
vinfos[0].indices[0] = _ij5[0];
vinfos[0].indices[1] = _ij5[1];
vinfos[0].maxsolutions = _nj5;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j9;
vinfos[1].indices[0] = _ij9[0];
vinfos[1].indices[1] = _ij9[1];
vinfos[1].maxsolutions = _nj9;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j10;
vinfos[2].indices[0] = _ij10[0];
vinfos[2].indices[1] = _ij10[1];
vinfos[2].maxsolutions = _nj10;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j11;
vinfos[3].indices[0] = _ij11[0];
vinfos[3].indices[1] = _ij11[1];
vinfos[3].maxsolutions = _nj11;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j12;
vinfos[4].indices[0] = _ij12[0];
vinfos[4].indices[1] = _ij12[1];
vinfos[4].maxsolutions = _nj12;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j13;
vinfos[5].indices[0] = _ij13[0];
vinfos[5].indices[1] = _ij13[1];
vinfos[5].maxsolutions = _nj13;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j14;
vinfos[6].indices[0] = _ij14[0];
vinfos[6].indices[1] = _ij14[1];
vinfos[6].maxsolutions = _nj14;
vinfos[7].jointtype = 1;
vinfos[7].foffset = j15;
vinfos[7].indices[0] = _ij15[0];
vinfos[7].indices[1] = _ij15[1];
vinfos[7].maxsolutions = _nj15;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(j14))), 6.28318530717959)));
evalcond[1]=new_r20;
evalcond[2]=new_r02;
evalcond[3]=new_r12;
evalcond[4]=new_r21;
if( IKabs(evalcond[0]) < 0.0000050000000000  && IKabs(evalcond[1]) < 0.0000050000000000  && IKabs(evalcond[2]) < 0.0000050000000000  && IKabs(evalcond[3]) < 0.0000050000000000  && IKabs(evalcond[4]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j13array[1], cj13array[1], sj13array[1];
bool j13valid[1]={false};
_nj13 = 1;
IkReal x534=((1.0)*new_r01);
if( IKabs(((((-1.0)*cj15*x534))+(((-1.0)*new_r00*sj15)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((((-1.0)*sj15*x534))+((cj15*new_r00)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((((-1.0)*cj15*x534))+(((-1.0)*new_r00*sj15))))+IKsqr(((((-1.0)*sj15*x534))+((cj15*new_r00))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j13array[0]=IKatan2(((((-1.0)*cj15*x534))+(((-1.0)*new_r00*sj15))), ((((-1.0)*sj15*x534))+((cj15*new_r00))));
sj13array[0]=IKsin(j13array[0]);
cj13array[0]=IKcos(j13array[0]);
if( j13array[0] > IKPI )
{
    j13array[0]-=IK2PI;
}
else if( j13array[0] < -IKPI )
{    j13array[0]+=IK2PI;
}
j13valid[0] = true;
for(int ij13 = 0; ij13 < 1; ++ij13)
{
if( !j13valid[ij13] )
{
    continue;
}
_ij13[0] = ij13; _ij13[1] = -1;
for(int iij13 = ij13+1; iij13 < 1; ++iij13)
{
if( j13valid[iij13] && IKabs(cj13array[ij13]-cj13array[iij13]) < IKFAST_SOLUTION_THRESH && IKabs(sj13array[ij13]-sj13array[iij13]) < IKFAST_SOLUTION_THRESH )
{
    j13valid[iij13]=false; _ij13[1] = iij13; break; 
}
}
j13 = j13array[ij13]; cj13 = cj13array[ij13]; sj13 = sj13array[ij13];
{
IkReal evalcond[8];
IkReal x535=IKcos(j13);
IkReal x536=IKsin(j13);
IkReal x537=((1.0)*cj15);
IkReal x538=((1.0)*sj15);
IkReal x539=(sj15*x536);
IkReal x540=((1.0)*x536);
IkReal x541=(x535*x537);
evalcond[0]=(((new_r01*x535))+((new_r11*x536))+sj15);
evalcond[1]=(((sj15*x535))+((cj15*x536))+new_r01);
evalcond[2]=((((-1.0)*x541))+x539+new_r00);
evalcond[3]=((((-1.0)*x541))+x539+new_r11);
evalcond[4]=((((-1.0)*x537))+((new_r10*x536))+((new_r00*x535)));
evalcond[5]=((((-1.0)*x535*x538))+new_r10+(((-1.0)*x536*x537)));
evalcond[6]=((((-1.0)*new_r00*x540))+(((-1.0)*x538))+((new_r10*x535)));
evalcond[7]=(((new_r11*x535))+(((-1.0)*x537))+(((-1.0)*new_r01*x540)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(8);
vinfos[0].jointtype = 17;
vinfos[0].foffset = j5;
vinfos[0].indices[0] = _ij5[0];
vinfos[0].indices[1] = _ij5[1];
vinfos[0].maxsolutions = _nj5;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j9;
vinfos[1].indices[0] = _ij9[0];
vinfos[1].indices[1] = _ij9[1];
vinfos[1].maxsolutions = _nj9;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j10;
vinfos[2].indices[0] = _ij10[0];
vinfos[2].indices[1] = _ij10[1];
vinfos[2].maxsolutions = _nj10;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j11;
vinfos[3].indices[0] = _ij11[0];
vinfos[3].indices[1] = _ij11[1];
vinfos[3].maxsolutions = _nj11;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j12;
vinfos[4].indices[0] = _ij12[0];
vinfos[4].indices[1] = _ij12[1];
vinfos[4].maxsolutions = _nj12;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j13;
vinfos[5].indices[0] = _ij13[0];
vinfos[5].indices[1] = _ij13[1];
vinfos[5].maxsolutions = _nj13;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j14;
vinfos[6].indices[0] = _ij14[0];
vinfos[6].indices[1] = _ij14[1];
vinfos[6].maxsolutions = _nj14;
vinfos[7].jointtype = 1;
vinfos[7].foffset = j15;
vinfos[7].indices[0] = _ij15[0];
vinfos[7].indices[1] = _ij15[1];
vinfos[7].maxsolutions = _nj15;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((-3.14159265358979)+j14)))), 6.28318530717959)));
evalcond[1]=new_r20;
evalcond[2]=new_r02;
evalcond[3]=new_r12;
evalcond[4]=new_r21;
if( IKabs(evalcond[0]) < 0.0000050000000000  && IKabs(evalcond[1]) < 0.0000050000000000  && IKabs(evalcond[2]) < 0.0000050000000000  && IKabs(evalcond[3]) < 0.0000050000000000  && IKabs(evalcond[4]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j13array[1], cj13array[1], sj13array[1];
bool j13valid[1]={false};
_nj13 = 1;
IkReal x542=((1.0)*cj15);
if( IKabs(((((-1.0)*new_r01*x542))+(((-1.0)*new_r00*sj15)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((((-1.0)*new_r00*x542))+((new_r01*sj15)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((((-1.0)*new_r01*x542))+(((-1.0)*new_r00*sj15))))+IKsqr(((((-1.0)*new_r00*x542))+((new_r01*sj15))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j13array[0]=IKatan2(((((-1.0)*new_r01*x542))+(((-1.0)*new_r00*sj15))), ((((-1.0)*new_r00*x542))+((new_r01*sj15))));
sj13array[0]=IKsin(j13array[0]);
cj13array[0]=IKcos(j13array[0]);
if( j13array[0] > IKPI )
{
    j13array[0]-=IK2PI;
}
else if( j13array[0] < -IKPI )
{    j13array[0]+=IK2PI;
}
j13valid[0] = true;
for(int ij13 = 0; ij13 < 1; ++ij13)
{
if( !j13valid[ij13] )
{
    continue;
}
_ij13[0] = ij13; _ij13[1] = -1;
for(int iij13 = ij13+1; iij13 < 1; ++iij13)
{
if( j13valid[iij13] && IKabs(cj13array[ij13]-cj13array[iij13]) < IKFAST_SOLUTION_THRESH && IKabs(sj13array[ij13]-sj13array[iij13]) < IKFAST_SOLUTION_THRESH )
{
    j13valid[iij13]=false; _ij13[1] = iij13; break; 
}
}
j13 = j13array[ij13]; cj13 = cj13array[ij13]; sj13 = sj13array[ij13];
{
IkReal evalcond[8];
IkReal x543=IKcos(j13);
IkReal x544=IKsin(j13);
IkReal x545=((1.0)*sj15);
IkReal x546=((1.0)*cj15);
IkReal x547=(cj15*x544);
IkReal x548=((1.0)*x544);
IkReal x549=(x543*x545);
evalcond[0]=(((new_r00*x543))+((new_r10*x544))+cj15);
evalcond[1]=(((sj15*x544))+((cj15*x543))+new_r00);
evalcond[2]=((((-1.0)*x549))+x547+new_r01);
evalcond[3]=((((-1.0)*x549))+x547+new_r10);
evalcond[4]=(((new_r11*x544))+(((-1.0)*x545))+((new_r01*x543)));
evalcond[5]=((((-1.0)*x544*x545))+new_r11+(((-1.0)*x543*x546)));
evalcond[6]=((((-1.0)*new_r00*x548))+((new_r10*x543))+(((-1.0)*x545)));
evalcond[7]=(((new_r11*x543))+(((-1.0)*new_r01*x548))+(((-1.0)*x546)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(8);
vinfos[0].jointtype = 17;
vinfos[0].foffset = j5;
vinfos[0].indices[0] = _ij5[0];
vinfos[0].indices[1] = _ij5[1];
vinfos[0].maxsolutions = _nj5;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j9;
vinfos[1].indices[0] = _ij9[0];
vinfos[1].indices[1] = _ij9[1];
vinfos[1].maxsolutions = _nj9;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j10;
vinfos[2].indices[0] = _ij10[0];
vinfos[2].indices[1] = _ij10[1];
vinfos[2].maxsolutions = _nj10;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j11;
vinfos[3].indices[0] = _ij11[0];
vinfos[3].indices[1] = _ij11[1];
vinfos[3].maxsolutions = _nj11;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j12;
vinfos[4].indices[0] = _ij12[0];
vinfos[4].indices[1] = _ij12[1];
vinfos[4].maxsolutions = _nj12;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j13;
vinfos[5].indices[0] = _ij13[0];
vinfos[5].indices[1] = _ij13[1];
vinfos[5].maxsolutions = _nj13;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j14;
vinfos[6].indices[0] = _ij14[0];
vinfos[6].indices[1] = _ij14[1];
vinfos[6].maxsolutions = _nj14;
vinfos[7].jointtype = 1;
vinfos[7].foffset = j15;
vinfos[7].indices[0] = _ij15[0];
vinfos[7].indices[1] = _ij15[1];
vinfos[7].maxsolutions = _nj15;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((IKabs(new_r12))+(IKabs(new_r02)));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j13eval[1];
new_r02=0;
new_r12=0;
new_r20=0;
new_r21=0;
j13eval[0]=((IKabs(new_r11))+(IKabs(new_r01)));
if( IKabs(j13eval[0]) < 0.0000010000000000  )
{
{
IkReal j13eval[1];
new_r02=0;
new_r12=0;
new_r20=0;
new_r21=0;
j13eval[0]=((IKabs(new_r10))+(IKabs(new_r00)));
if( IKabs(j13eval[0]) < 0.0000010000000000  )
{
{
IkReal j13eval[1];
new_r02=0;
new_r12=0;
new_r20=0;
new_r21=0;
j13eval[0]=((IKabs((new_r11*new_r22)))+(IKabs((new_r01*new_r22))));
if( IKabs(j13eval[0]) < 0.0000010000000000  )
{
continue; // no branches [j13]

} else
{
{
IkReal j13array[2], cj13array[2], sj13array[2];
bool j13valid[2]={false};
_nj13 = 2;
CheckValue<IkReal> x551 = IKatan2WithCheck(IkReal((new_r01*new_r22)),IkReal((new_r11*new_r22)),IKFAST_ATAN2_MAGTHRESH);
if(!x551.valid){
continue;
}
IkReal x550=x551.value;
j13array[0]=((-1.0)*x550);
sj13array[0]=IKsin(j13array[0]);
cj13array[0]=IKcos(j13array[0]);
j13array[1]=((3.14159265358979)+(((-1.0)*x550)));
sj13array[1]=IKsin(j13array[1]);
cj13array[1]=IKcos(j13array[1]);
if( j13array[0] > IKPI )
{
    j13array[0]-=IK2PI;
}
else if( j13array[0] < -IKPI )
{    j13array[0]+=IK2PI;
}
j13valid[0] = true;
if( j13array[1] > IKPI )
{
    j13array[1]-=IK2PI;
}
else if( j13array[1] < -IKPI )
{    j13array[1]+=IK2PI;
}
j13valid[1] = true;
for(int ij13 = 0; ij13 < 2; ++ij13)
{
if( !j13valid[ij13] )
{
    continue;
}
_ij13[0] = ij13; _ij13[1] = -1;
for(int iij13 = ij13+1; iij13 < 2; ++iij13)
{
if( j13valid[iij13] && IKabs(cj13array[ij13]-cj13array[iij13]) < IKFAST_SOLUTION_THRESH && IKabs(sj13array[ij13]-sj13array[iij13]) < IKFAST_SOLUTION_THRESH )
{
    j13valid[iij13]=false; _ij13[1] = iij13; break; 
}
}
j13 = j13array[ij13]; cj13 = cj13array[ij13]; sj13 = sj13array[ij13];
{
IkReal evalcond[5];
IkReal x552=IKcos(j13);
IkReal x553=IKsin(j13);
IkReal x554=((1.0)*x553);
IkReal x555=(new_r10*x553);
IkReal x556=(new_r00*x552);
evalcond[0]=(((new_r11*x553))+((new_r01*x552)));
evalcond[1]=(x556+x555);
evalcond[2]=(((new_r10*x552))+(((-1.0)*new_r00*x554)));
evalcond[3]=(((new_r11*x552))+(((-1.0)*new_r01*x554)));
evalcond[4]=(((new_r22*x555))+((new_r22*x556)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(8);
vinfos[0].jointtype = 17;
vinfos[0].foffset = j5;
vinfos[0].indices[0] = _ij5[0];
vinfos[0].indices[1] = _ij5[1];
vinfos[0].maxsolutions = _nj5;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j9;
vinfos[1].indices[0] = _ij9[0];
vinfos[1].indices[1] = _ij9[1];
vinfos[1].maxsolutions = _nj9;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j10;
vinfos[2].indices[0] = _ij10[0];
vinfos[2].indices[1] = _ij10[1];
vinfos[2].maxsolutions = _nj10;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j11;
vinfos[3].indices[0] = _ij11[0];
vinfos[3].indices[1] = _ij11[1];
vinfos[3].maxsolutions = _nj11;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j12;
vinfos[4].indices[0] = _ij12[0];
vinfos[4].indices[1] = _ij12[1];
vinfos[4].maxsolutions = _nj12;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j13;
vinfos[5].indices[0] = _ij13[0];
vinfos[5].indices[1] = _ij13[1];
vinfos[5].maxsolutions = _nj13;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j14;
vinfos[6].indices[0] = _ij14[0];
vinfos[6].indices[1] = _ij14[1];
vinfos[6].maxsolutions = _nj14;
vinfos[7].jointtype = 1;
vinfos[7].foffset = j15;
vinfos[7].indices[0] = _ij15[0];
vinfos[7].indices[1] = _ij15[1];
vinfos[7].maxsolutions = _nj15;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

} else
{
{
IkReal j13array[2], cj13array[2], sj13array[2];
bool j13valid[2]={false};
_nj13 = 2;
CheckValue<IkReal> x558 = IKatan2WithCheck(IkReal(new_r00),IkReal(new_r10),IKFAST_ATAN2_MAGTHRESH);
if(!x558.valid){
continue;
}
IkReal x557=x558.value;
j13array[0]=((-1.0)*x557);
sj13array[0]=IKsin(j13array[0]);
cj13array[0]=IKcos(j13array[0]);
j13array[1]=((3.14159265358979)+(((-1.0)*x557)));
sj13array[1]=IKsin(j13array[1]);
cj13array[1]=IKcos(j13array[1]);
if( j13array[0] > IKPI )
{
    j13array[0]-=IK2PI;
}
else if( j13array[0] < -IKPI )
{    j13array[0]+=IK2PI;
}
j13valid[0] = true;
if( j13array[1] > IKPI )
{
    j13array[1]-=IK2PI;
}
else if( j13array[1] < -IKPI )
{    j13array[1]+=IK2PI;
}
j13valid[1] = true;
for(int ij13 = 0; ij13 < 2; ++ij13)
{
if( !j13valid[ij13] )
{
    continue;
}
_ij13[0] = ij13; _ij13[1] = -1;
for(int iij13 = ij13+1; iij13 < 2; ++iij13)
{
if( j13valid[iij13] && IKabs(cj13array[ij13]-cj13array[iij13]) < IKFAST_SOLUTION_THRESH && IKabs(sj13array[ij13]-sj13array[iij13]) < IKFAST_SOLUTION_THRESH )
{
    j13valid[iij13]=false; _ij13[1] = iij13; break; 
}
}
j13 = j13array[ij13]; cj13 = cj13array[ij13]; sj13 = sj13array[ij13];
{
IkReal evalcond[5];
IkReal x559=IKcos(j13);
IkReal x560=IKsin(j13);
IkReal x561=((1.0)*x560);
IkReal x562=(new_r01*x559);
IkReal x563=(new_r22*x560);
evalcond[0]=(x562+((new_r11*x560)));
evalcond[1]=((((-1.0)*new_r00*x561))+((new_r10*x559)));
evalcond[2]=(((new_r11*x559))+(((-1.0)*new_r01*x561)));
evalcond[3]=(((new_r22*x562))+((new_r11*x563)));
evalcond[4]=(((new_r00*new_r22*x559))+((new_r10*x563)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(8);
vinfos[0].jointtype = 17;
vinfos[0].foffset = j5;
vinfos[0].indices[0] = _ij5[0];
vinfos[0].indices[1] = _ij5[1];
vinfos[0].maxsolutions = _nj5;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j9;
vinfos[1].indices[0] = _ij9[0];
vinfos[1].indices[1] = _ij9[1];
vinfos[1].maxsolutions = _nj9;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j10;
vinfos[2].indices[0] = _ij10[0];
vinfos[2].indices[1] = _ij10[1];
vinfos[2].maxsolutions = _nj10;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j11;
vinfos[3].indices[0] = _ij11[0];
vinfos[3].indices[1] = _ij11[1];
vinfos[3].maxsolutions = _nj11;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j12;
vinfos[4].indices[0] = _ij12[0];
vinfos[4].indices[1] = _ij12[1];
vinfos[4].maxsolutions = _nj12;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j13;
vinfos[5].indices[0] = _ij13[0];
vinfos[5].indices[1] = _ij13[1];
vinfos[5].maxsolutions = _nj13;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j14;
vinfos[6].indices[0] = _ij14[0];
vinfos[6].indices[1] = _ij14[1];
vinfos[6].maxsolutions = _nj14;
vinfos[7].jointtype = 1;
vinfos[7].foffset = j15;
vinfos[7].indices[0] = _ij15[0];
vinfos[7].indices[1] = _ij15[1];
vinfos[7].maxsolutions = _nj15;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

} else
{
{
IkReal j13array[2], cj13array[2], sj13array[2];
bool j13valid[2]={false};
_nj13 = 2;
CheckValue<IkReal> x565 = IKatan2WithCheck(IkReal(new_r01),IkReal(new_r11),IKFAST_ATAN2_MAGTHRESH);
if(!x565.valid){
continue;
}
IkReal x564=x565.value;
j13array[0]=((-1.0)*x564);
sj13array[0]=IKsin(j13array[0]);
cj13array[0]=IKcos(j13array[0]);
j13array[1]=((3.14159265358979)+(((-1.0)*x564)));
sj13array[1]=IKsin(j13array[1]);
cj13array[1]=IKcos(j13array[1]);
if( j13array[0] > IKPI )
{
    j13array[0]-=IK2PI;
}
else if( j13array[0] < -IKPI )
{    j13array[0]+=IK2PI;
}
j13valid[0] = true;
if( j13array[1] > IKPI )
{
    j13array[1]-=IK2PI;
}
else if( j13array[1] < -IKPI )
{    j13array[1]+=IK2PI;
}
j13valid[1] = true;
for(int ij13 = 0; ij13 < 2; ++ij13)
{
if( !j13valid[ij13] )
{
    continue;
}
_ij13[0] = ij13; _ij13[1] = -1;
for(int iij13 = ij13+1; iij13 < 2; ++iij13)
{
if( j13valid[iij13] && IKabs(cj13array[ij13]-cj13array[iij13]) < IKFAST_SOLUTION_THRESH && IKabs(sj13array[ij13]-sj13array[iij13]) < IKFAST_SOLUTION_THRESH )
{
    j13valid[iij13]=false; _ij13[1] = iij13; break; 
}
}
j13 = j13array[ij13]; cj13 = cj13array[ij13]; sj13 = sj13array[ij13];
{
IkReal evalcond[5];
IkReal x566=IKcos(j13);
IkReal x567=IKsin(j13);
IkReal x568=((1.0)*x567);
IkReal x569=(new_r22*x566);
IkReal x570=(new_r22*x567);
evalcond[0]=(((new_r00*x566))+((new_r10*x567)));
evalcond[1]=((((-1.0)*new_r00*x568))+((new_r10*x566)));
evalcond[2]=(((new_r11*x566))+(((-1.0)*new_r01*x568)));
evalcond[3]=(((new_r11*x570))+((new_r01*x569)));
evalcond[4]=(((new_r10*x570))+((new_r00*x569)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(8);
vinfos[0].jointtype = 17;
vinfos[0].foffset = j5;
vinfos[0].indices[0] = _ij5[0];
vinfos[0].indices[1] = _ij5[1];
vinfos[0].maxsolutions = _nj5;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j9;
vinfos[1].indices[0] = _ij9[0];
vinfos[1].indices[1] = _ij9[1];
vinfos[1].maxsolutions = _nj9;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j10;
vinfos[2].indices[0] = _ij10[0];
vinfos[2].indices[1] = _ij10[1];
vinfos[2].maxsolutions = _nj10;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j11;
vinfos[3].indices[0] = _ij11[0];
vinfos[3].indices[1] = _ij11[1];
vinfos[3].maxsolutions = _nj11;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j12;
vinfos[4].indices[0] = _ij12[0];
vinfos[4].indices[1] = _ij12[1];
vinfos[4].maxsolutions = _nj12;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j13;
vinfos[5].indices[0] = _ij13[0];
vinfos[5].indices[1] = _ij13[1];
vinfos[5].maxsolutions = _nj13;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j14;
vinfos[6].indices[0] = _ij14[0];
vinfos[6].indices[1] = _ij14[1];
vinfos[6].maxsolutions = _nj14;
vinfos[7].jointtype = 1;
vinfos[7].foffset = j15;
vinfos[7].indices[0] = _ij15[0];
vinfos[7].indices[1] = _ij15[1];
vinfos[7].maxsolutions = _nj15;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
if( 1 )
{
bgotonextstatement=false;
continue; // branch miss [j13]

}
} while(0);
if( bgotonextstatement )
{
}
}
}
}
}
}
}

} else
{
{
IkReal j13array[1], cj13array[1], sj13array[1];
bool j13valid[1]={false};
_nj13 = 1;
CheckValue<IkReal> x572=IKPowWithIntegerCheck(sj14,-1);
if(!x572.valid){
continue;
}
IkReal x571=x572.value;
CheckValue<IkReal> x573=IKPowWithIntegerCheck(cj15,-1);
if(!x573.valid){
continue;
}
if( IKabs((x571*(x573.value)*(((((-1.0)*new_r01*sj14))+(((-1.0)*cj14*new_r02*sj15)))))) < IKFAST_ATAN2_MAGTHRESH && IKabs((new_r02*x571)) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr((x571*(x573.value)*(((((-1.0)*new_r01*sj14))+(((-1.0)*cj14*new_r02*sj15))))))+IKsqr((new_r02*x571))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j13array[0]=IKatan2((x571*(x573.value)*(((((-1.0)*new_r01*sj14))+(((-1.0)*cj14*new_r02*sj15))))), (new_r02*x571));
sj13array[0]=IKsin(j13array[0]);
cj13array[0]=IKcos(j13array[0]);
if( j13array[0] > IKPI )
{
    j13array[0]-=IK2PI;
}
else if( j13array[0] < -IKPI )
{    j13array[0]+=IK2PI;
}
j13valid[0] = true;
for(int ij13 = 0; ij13 < 1; ++ij13)
{
if( !j13valid[ij13] )
{
    continue;
}
_ij13[0] = ij13; _ij13[1] = -1;
for(int iij13 = ij13+1; iij13 < 1; ++iij13)
{
if( j13valid[iij13] && IKabs(cj13array[ij13]-cj13array[iij13]) < IKFAST_SOLUTION_THRESH && IKabs(sj13array[ij13]-sj13array[iij13]) < IKFAST_SOLUTION_THRESH )
{
    j13valid[iij13]=false; _ij13[1] = iij13; break; 
}
}
j13 = j13array[ij13]; cj13 = cj13array[ij13]; sj13 = sj13array[ij13];
{
IkReal evalcond[18];
IkReal x574=IKcos(j13);
IkReal x575=IKsin(j13);
IkReal x576=((1.0)*cj15);
IkReal x577=((1.0)*sj15);
IkReal x578=((1.0)*sj14);
IkReal x579=(new_r01*x574);
IkReal x580=(new_r00*x574);
IkReal x581=(cj14*x575);
IkReal x582=(new_r11*x575);
IkReal x583=(sj14*x574);
IkReal x584=((1.0)*x575);
IkReal x585=(new_r10*x575);
IkReal x586=(new_r12*x575);
IkReal x587=(cj14*x574);
evalcond[0]=((((-1.0)*x574*x578))+new_r02);
evalcond[1]=((((-1.0)*x575*x578))+new_r12);
evalcond[2]=(((new_r12*x574))+(((-1.0)*new_r02*x584)));
evalcond[3]=(((sj15*x587))+((cj15*x575))+new_r01);
evalcond[4]=((((-1.0)*x578))+x586+((new_r02*x574)));
evalcond[5]=(((cj14*sj15))+x579+x582);
evalcond[6]=(((sj15*x575))+(((-1.0)*x576*x587))+new_r00);
evalcond[7]=(((sj15*x581))+(((-1.0)*x574*x576))+new_r11);
evalcond[8]=(((new_r10*x574))+(((-1.0)*x577))+(((-1.0)*new_r00*x584)));
evalcond[9]=((((-1.0)*new_r01*x584))+((new_r11*x574))+(((-1.0)*x576)));
evalcond[10]=((((-1.0)*cj14*x576))+x580+x585);
evalcond[11]=((((-1.0)*x574*x577))+(((-1.0)*x576*x581))+new_r10);
evalcond[12]=(((cj14*new_r20))+((sj14*x585))+((sj14*x580)));
evalcond[13]=(((sj14*x579))+((cj14*new_r21))+((sj14*x582)));
evalcond[14]=((-1.0)+((cj14*new_r22))+((sj14*x586))+((new_r02*x583)));
evalcond[15]=((((-1.0)*new_r22*x578))+((new_r12*x581))+((new_r02*x587)));
evalcond[16]=(((cj14*x579))+sj15+(((-1.0)*new_r21*x578))+((new_r11*x581)));
evalcond[17]=((((-1.0)*x576))+(((-1.0)*new_r20*x578))+((cj14*x580))+((new_r10*x581)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[8]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[9]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[10]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[11]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[12]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[13]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[14]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[15]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[16]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[17]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(8);
vinfos[0].jointtype = 17;
vinfos[0].foffset = j5;
vinfos[0].indices[0] = _ij5[0];
vinfos[0].indices[1] = _ij5[1];
vinfos[0].maxsolutions = _nj5;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j9;
vinfos[1].indices[0] = _ij9[0];
vinfos[1].indices[1] = _ij9[1];
vinfos[1].maxsolutions = _nj9;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j10;
vinfos[2].indices[0] = _ij10[0];
vinfos[2].indices[1] = _ij10[1];
vinfos[2].maxsolutions = _nj10;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j11;
vinfos[3].indices[0] = _ij11[0];
vinfos[3].indices[1] = _ij11[1];
vinfos[3].maxsolutions = _nj11;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j12;
vinfos[4].indices[0] = _ij12[0];
vinfos[4].indices[1] = _ij12[1];
vinfos[4].maxsolutions = _nj12;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j13;
vinfos[5].indices[0] = _ij13[0];
vinfos[5].indices[1] = _ij13[1];
vinfos[5].maxsolutions = _nj13;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j14;
vinfos[6].indices[0] = _ij14[0];
vinfos[6].indices[1] = _ij14[1];
vinfos[6].maxsolutions = _nj14;
vinfos[7].jointtype = 1;
vinfos[7].foffset = j15;
vinfos[7].indices[0] = _ij15[0];
vinfos[7].indices[1] = _ij15[1];
vinfos[7].maxsolutions = _nj15;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

} else
{
{
IkReal j13array[1], cj13array[1], sj13array[1];
bool j13valid[1]={false};
_nj13 = 1;
CheckValue<IkReal> x588=IKPowWithIntegerCheck(IKsign(sj14),-1);
if(!x588.valid){
continue;
}
CheckValue<IkReal> x589 = IKatan2WithCheck(IkReal(new_r12),IkReal(new_r02),IKFAST_ATAN2_MAGTHRESH);
if(!x589.valid){
continue;
}
j13array[0]=((-1.5707963267949)+(((1.5707963267949)*(x588.value)))+(x589.value));
sj13array[0]=IKsin(j13array[0]);
cj13array[0]=IKcos(j13array[0]);
if( j13array[0] > IKPI )
{
    j13array[0]-=IK2PI;
}
else if( j13array[0] < -IKPI )
{    j13array[0]+=IK2PI;
}
j13valid[0] = true;
for(int ij13 = 0; ij13 < 1; ++ij13)
{
if( !j13valid[ij13] )
{
    continue;
}
_ij13[0] = ij13; _ij13[1] = -1;
for(int iij13 = ij13+1; iij13 < 1; ++iij13)
{
if( j13valid[iij13] && IKabs(cj13array[ij13]-cj13array[iij13]) < IKFAST_SOLUTION_THRESH && IKabs(sj13array[ij13]-sj13array[iij13]) < IKFAST_SOLUTION_THRESH )
{
    j13valid[iij13]=false; _ij13[1] = iij13; break; 
}
}
j13 = j13array[ij13]; cj13 = cj13array[ij13]; sj13 = sj13array[ij13];
{
IkReal evalcond[18];
IkReal x590=IKcos(j13);
IkReal x591=IKsin(j13);
IkReal x592=((1.0)*cj15);
IkReal x593=((1.0)*sj15);
IkReal x594=((1.0)*sj14);
IkReal x595=(new_r01*x590);
IkReal x596=(new_r00*x590);
IkReal x597=(cj14*x591);
IkReal x598=(new_r11*x591);
IkReal x599=(sj14*x590);
IkReal x600=((1.0)*x591);
IkReal x601=(new_r10*x591);
IkReal x602=(new_r12*x591);
IkReal x603=(cj14*x590);
evalcond[0]=((((-1.0)*x590*x594))+new_r02);
evalcond[1]=(new_r12+(((-1.0)*x591*x594)));
evalcond[2]=(((new_r12*x590))+(((-1.0)*new_r02*x600)));
evalcond[3]=(((cj15*x591))+new_r01+((sj15*x603)));
evalcond[4]=(((new_r02*x590))+(((-1.0)*x594))+x602);
evalcond[5]=(((cj14*sj15))+x595+x598);
evalcond[6]=((((-1.0)*x592*x603))+((sj15*x591))+new_r00);
evalcond[7]=((((-1.0)*x590*x592))+((sj15*x597))+new_r11);
evalcond[8]=(((new_r10*x590))+(((-1.0)*x593))+(((-1.0)*new_r00*x600)));
evalcond[9]=(((new_r11*x590))+(((-1.0)*x592))+(((-1.0)*new_r01*x600)));
evalcond[10]=((((-1.0)*cj14*x592))+x596+x601);
evalcond[11]=((((-1.0)*x592*x597))+(((-1.0)*x590*x593))+new_r10);
evalcond[12]=(((cj14*new_r20))+((sj14*x601))+((sj14*x596)));
evalcond[13]=(((cj14*new_r21))+((sj14*x598))+((sj14*x595)));
evalcond[14]=((-1.0)+((new_r02*x599))+((cj14*new_r22))+((sj14*x602)));
evalcond[15]=(((new_r12*x597))+((new_r02*x603))+(((-1.0)*new_r22*x594)));
evalcond[16]=((((-1.0)*new_r21*x594))+((new_r11*x597))+sj15+((cj14*x595)));
evalcond[17]=((((-1.0)*new_r20*x594))+((new_r10*x597))+(((-1.0)*x592))+((cj14*x596)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[8]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[9]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[10]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[11]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[12]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[13]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[14]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[15]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[16]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[17]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(8);
vinfos[0].jointtype = 17;
vinfos[0].foffset = j5;
vinfos[0].indices[0] = _ij5[0];
vinfos[0].indices[1] = _ij5[1];
vinfos[0].maxsolutions = _nj5;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j9;
vinfos[1].indices[0] = _ij9[0];
vinfos[1].indices[1] = _ij9[1];
vinfos[1].maxsolutions = _nj9;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j10;
vinfos[2].indices[0] = _ij10[0];
vinfos[2].indices[1] = _ij10[1];
vinfos[2].maxsolutions = _nj10;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j11;
vinfos[3].indices[0] = _ij11[0];
vinfos[3].indices[1] = _ij11[1];
vinfos[3].maxsolutions = _nj11;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j12;
vinfos[4].indices[0] = _ij12[0];
vinfos[4].indices[1] = _ij12[1];
vinfos[4].maxsolutions = _nj12;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j13;
vinfos[5].indices[0] = _ij13[0];
vinfos[5].indices[1] = _ij13[1];
vinfos[5].maxsolutions = _nj13;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j14;
vinfos[6].indices[0] = _ij14[0];
vinfos[6].indices[1] = _ij14[1];
vinfos[6].maxsolutions = _nj14;
vinfos[7].jointtype = 1;
vinfos[7].foffset = j15;
vinfos[7].indices[0] = _ij15[0];
vinfos[7].indices[1] = _ij15[1];
vinfos[7].maxsolutions = _nj15;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}
}
}

}

}

} else
{
{
IkReal j13array[1], cj13array[1], sj13array[1];
bool j13valid[1]={false};
_nj13 = 1;
CheckValue<IkReal> x604=IKPowWithIntegerCheck(IKsign(sj14),-1);
if(!x604.valid){
continue;
}
CheckValue<IkReal> x605 = IKatan2WithCheck(IkReal(new_r12),IkReal(new_r02),IKFAST_ATAN2_MAGTHRESH);
if(!x605.valid){
continue;
}
j13array[0]=((-1.5707963267949)+(((1.5707963267949)*(x604.value)))+(x605.value));
sj13array[0]=IKsin(j13array[0]);
cj13array[0]=IKcos(j13array[0]);
if( j13array[0] > IKPI )
{
    j13array[0]-=IK2PI;
}
else if( j13array[0] < -IKPI )
{    j13array[0]+=IK2PI;
}
j13valid[0] = true;
for(int ij13 = 0; ij13 < 1; ++ij13)
{
if( !j13valid[ij13] )
{
    continue;
}
_ij13[0] = ij13; _ij13[1] = -1;
for(int iij13 = ij13+1; iij13 < 1; ++iij13)
{
if( j13valid[iij13] && IKabs(cj13array[ij13]-cj13array[iij13]) < IKFAST_SOLUTION_THRESH && IKabs(sj13array[ij13]-sj13array[iij13]) < IKFAST_SOLUTION_THRESH )
{
    j13valid[iij13]=false; _ij13[1] = iij13; break; 
}
}
j13 = j13array[ij13]; cj13 = cj13array[ij13]; sj13 = sj13array[ij13];
{
IkReal evalcond[8];
IkReal x606=IKcos(j13);
IkReal x607=IKsin(j13);
IkReal x608=((1.0)*sj14);
IkReal x609=(new_r12*x607);
IkReal x610=(new_r02*x606);
IkReal x611=(sj14*x606);
IkReal x612=(sj14*x607);
evalcond[0]=(new_r02+(((-1.0)*x606*x608)));
evalcond[1]=(new_r12+(((-1.0)*x607*x608)));
evalcond[2]=(((new_r12*x606))+(((-1.0)*new_r02*x607)));
evalcond[3]=(x609+x610+(((-1.0)*x608)));
evalcond[4]=(((new_r10*x612))+((cj14*new_r20))+((new_r00*x611)));
evalcond[5]=(((new_r11*x612))+((cj14*new_r21))+((new_r01*x611)));
evalcond[6]=((-1.0)+((cj14*new_r22))+((sj14*x609))+((sj14*x610)));
evalcond[7]=((((-1.0)*new_r22*x608))+((cj14*x609))+((cj14*x610)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
IkReal j15eval[3];
j15eval[0]=sj14;
j15eval[1]=IKsign(sj14);
j15eval[2]=((IKabs(new_r20))+(IKabs(new_r21)));
if( IKabs(j15eval[0]) < 0.0000010000000000  || IKabs(j15eval[1]) < 0.0000010000000000  || IKabs(j15eval[2]) < 0.0000010000000000  )
{
{
IkReal j15eval[2];
j15eval[0]=sj14;
j15eval[1]=sj13;
if( IKabs(j15eval[0]) < 0.0000010000000000  || IKabs(j15eval[1]) < 0.0000010000000000  )
{
{
IkReal j15eval[3];
j15eval[0]=cj14;
j15eval[1]=sj13;
j15eval[2]=sj14;
if( IKabs(j15eval[0]) < 0.0000010000000000  || IKabs(j15eval[1]) < 0.0000010000000000  || IKabs(j15eval[2]) < 0.0000010000000000  )
{
{
IkReal evalcond[5];
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((-1.5707963267949)+j14)))), 6.28318530717959)));
evalcond[1]=new_r22;
if( IKabs(evalcond[0]) < 0.0000050000000000  && IKabs(evalcond[1]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j15array[1], cj15array[1], sj15array[1];
bool j15valid[1]={false};
_nj15 = 1;
if( IKabs(new_r21) < IKFAST_ATAN2_MAGTHRESH && IKabs(((-1.0)*new_r20)) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(new_r21)+IKsqr(((-1.0)*new_r20))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j15array[0]=IKatan2(new_r21, ((-1.0)*new_r20));
sj15array[0]=IKsin(j15array[0]);
cj15array[0]=IKcos(j15array[0]);
if( j15array[0] > IKPI )
{
    j15array[0]-=IK2PI;
}
else if( j15array[0] < -IKPI )
{    j15array[0]+=IK2PI;
}
j15valid[0] = true;
for(int ij15 = 0; ij15 < 1; ++ij15)
{
if( !j15valid[ij15] )
{
    continue;
}
_ij15[0] = ij15; _ij15[1] = -1;
for(int iij15 = ij15+1; iij15 < 1; ++iij15)
{
if( j15valid[iij15] && IKabs(cj15array[ij15]-cj15array[iij15]) < IKFAST_SOLUTION_THRESH && IKabs(sj15array[ij15]-sj15array[iij15]) < IKFAST_SOLUTION_THRESH )
{
    j15valid[iij15]=false; _ij15[1] = iij15; break; 
}
}
j15 = j15array[ij15]; cj15 = cj15array[ij15]; sj15 = sj15array[ij15];
{
IkReal evalcond[8];
IkReal x613=IKcos(j15);
IkReal x614=IKsin(j15);
IkReal x615=((1.0)*cj13);
IkReal x616=((1.0)*sj13);
IkReal x617=((1.0)*x614);
evalcond[0]=(x613+new_r20);
evalcond[1]=((((-1.0)*x617))+new_r21);
evalcond[2]=(((sj13*x613))+new_r01);
evalcond[3]=(((sj13*x614))+new_r00);
evalcond[4]=((((-1.0)*x613*x615))+new_r11);
evalcond[5]=((((-1.0)*x614*x615))+new_r10);
evalcond[6]=(((cj13*new_r10))+(((-1.0)*x617))+(((-1.0)*new_r00*x616)));
evalcond[7]=(((cj13*new_r11))+(((-1.0)*x613))+(((-1.0)*new_r01*x616)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(8);
vinfos[0].jointtype = 17;
vinfos[0].foffset = j5;
vinfos[0].indices[0] = _ij5[0];
vinfos[0].indices[1] = _ij5[1];
vinfos[0].maxsolutions = _nj5;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j9;
vinfos[1].indices[0] = _ij9[0];
vinfos[1].indices[1] = _ij9[1];
vinfos[1].maxsolutions = _nj9;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j10;
vinfos[2].indices[0] = _ij10[0];
vinfos[2].indices[1] = _ij10[1];
vinfos[2].maxsolutions = _nj10;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j11;
vinfos[3].indices[0] = _ij11[0];
vinfos[3].indices[1] = _ij11[1];
vinfos[3].maxsolutions = _nj11;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j12;
vinfos[4].indices[0] = _ij12[0];
vinfos[4].indices[1] = _ij12[1];
vinfos[4].maxsolutions = _nj12;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j13;
vinfos[5].indices[0] = _ij13[0];
vinfos[5].indices[1] = _ij13[1];
vinfos[5].maxsolutions = _nj13;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j14;
vinfos[6].indices[0] = _ij14[0];
vinfos[6].indices[1] = _ij14[1];
vinfos[6].maxsolutions = _nj14;
vinfos[7].jointtype = 1;
vinfos[7].foffset = j15;
vinfos[7].indices[0] = _ij15[0];
vinfos[7].indices[1] = _ij15[1];
vinfos[7].maxsolutions = _nj15;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((1.5707963267949)+j14)))), 6.28318530717959)));
evalcond[1]=new_r22;
if( IKabs(evalcond[0]) < 0.0000050000000000  && IKabs(evalcond[1]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j15array[1], cj15array[1], sj15array[1];
bool j15valid[1]={false};
_nj15 = 1;
if( IKabs(((-1.0)*new_r21)) < IKFAST_ATAN2_MAGTHRESH && IKabs(new_r20) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((-1.0)*new_r21))+IKsqr(new_r20)-1) <= IKFAST_SINCOS_THRESH )
    continue;
j15array[0]=IKatan2(((-1.0)*new_r21), new_r20);
sj15array[0]=IKsin(j15array[0]);
cj15array[0]=IKcos(j15array[0]);
if( j15array[0] > IKPI )
{
    j15array[0]-=IK2PI;
}
else if( j15array[0] < -IKPI )
{    j15array[0]+=IK2PI;
}
j15valid[0] = true;
for(int ij15 = 0; ij15 < 1; ++ij15)
{
if( !j15valid[ij15] )
{
    continue;
}
_ij15[0] = ij15; _ij15[1] = -1;
for(int iij15 = ij15+1; iij15 < 1; ++iij15)
{
if( j15valid[iij15] && IKabs(cj15array[ij15]-cj15array[iij15]) < IKFAST_SOLUTION_THRESH && IKabs(sj15array[ij15]-sj15array[iij15]) < IKFAST_SOLUTION_THRESH )
{
    j15valid[iij15]=false; _ij15[1] = iij15; break; 
}
}
j15 = j15array[ij15]; cj15 = cj15array[ij15]; sj15 = sj15array[ij15];
{
IkReal evalcond[8];
IkReal x618=IKcos(j15);
IkReal x619=IKsin(j15);
IkReal x620=((1.0)*cj13);
IkReal x621=((1.0)*sj13);
IkReal x622=((1.0)*x618);
evalcond[0]=(x619+new_r21);
evalcond[1]=((((-1.0)*x622))+new_r20);
evalcond[2]=(((sj13*x618))+new_r01);
evalcond[3]=(((sj13*x619))+new_r00);
evalcond[4]=((((-1.0)*x618*x620))+new_r11);
evalcond[5]=((((-1.0)*x619*x620))+new_r10);
evalcond[6]=((((-1.0)*new_r00*x621))+((cj13*new_r10))+(((-1.0)*x619)));
evalcond[7]=((((-1.0)*new_r01*x621))+((cj13*new_r11))+(((-1.0)*x622)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(8);
vinfos[0].jointtype = 17;
vinfos[0].foffset = j5;
vinfos[0].indices[0] = _ij5[0];
vinfos[0].indices[1] = _ij5[1];
vinfos[0].maxsolutions = _nj5;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j9;
vinfos[1].indices[0] = _ij9[0];
vinfos[1].indices[1] = _ij9[1];
vinfos[1].maxsolutions = _nj9;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j10;
vinfos[2].indices[0] = _ij10[0];
vinfos[2].indices[1] = _ij10[1];
vinfos[2].maxsolutions = _nj10;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j11;
vinfos[3].indices[0] = _ij11[0];
vinfos[3].indices[1] = _ij11[1];
vinfos[3].maxsolutions = _nj11;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j12;
vinfos[4].indices[0] = _ij12[0];
vinfos[4].indices[1] = _ij12[1];
vinfos[4].maxsolutions = _nj12;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j13;
vinfos[5].indices[0] = _ij13[0];
vinfos[5].indices[1] = _ij13[1];
vinfos[5].maxsolutions = _nj13;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j14;
vinfos[6].indices[0] = _ij14[0];
vinfos[6].indices[1] = _ij14[1];
vinfos[6].maxsolutions = _nj14;
vinfos[7].jointtype = 1;
vinfos[7].foffset = j15;
vinfos[7].indices[0] = _ij15[0];
vinfos[7].indices[1] = _ij15[1];
vinfos[7].maxsolutions = _nj15;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(j13))), 6.28318530717959)));
evalcond[1]=new_r12;
if( IKabs(evalcond[0]) < 0.0000050000000000  && IKabs(evalcond[1]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j15array[1], cj15array[1], sj15array[1];
bool j15valid[1]={false};
_nj15 = 1;
if( IKabs(new_r10) < IKFAST_ATAN2_MAGTHRESH && IKabs(new_r11) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(new_r10)+IKsqr(new_r11)-1) <= IKFAST_SINCOS_THRESH )
    continue;
j15array[0]=IKatan2(new_r10, new_r11);
sj15array[0]=IKsin(j15array[0]);
cj15array[0]=IKcos(j15array[0]);
if( j15array[0] > IKPI )
{
    j15array[0]-=IK2PI;
}
else if( j15array[0] < -IKPI )
{    j15array[0]+=IK2PI;
}
j15valid[0] = true;
for(int ij15 = 0; ij15 < 1; ++ij15)
{
if( !j15valid[ij15] )
{
    continue;
}
_ij15[0] = ij15; _ij15[1] = -1;
for(int iij15 = ij15+1; iij15 < 1; ++iij15)
{
if( j15valid[iij15] && IKabs(cj15array[ij15]-cj15array[iij15]) < IKFAST_SOLUTION_THRESH && IKabs(sj15array[ij15]-sj15array[iij15]) < IKFAST_SOLUTION_THRESH )
{
    j15valid[iij15]=false; _ij15[1] = iij15; break; 
}
}
j15 = j15array[ij15]; cj15 = cj15array[ij15]; sj15 = sj15array[ij15];
{
IkReal evalcond[8];
IkReal x623=IKcos(j15);
IkReal x624=IKsin(j15);
IkReal x625=((1.0)*sj14);
IkReal x626=((1.0)*x623);
evalcond[0]=(new_r20+((sj14*x623)));
evalcond[1]=((((-1.0)*x624))+new_r10);
evalcond[2]=((((-1.0)*x626))+new_r11);
evalcond[3]=(new_r01+((cj14*x624)));
evalcond[4]=((((-1.0)*x624*x625))+new_r21);
evalcond[5]=((((-1.0)*cj14*x626))+new_r00);
evalcond[6]=(((cj14*new_r01))+(((-1.0)*new_r21*x625))+x624);
evalcond[7]=(((cj14*new_r00))+(((-1.0)*x626))+(((-1.0)*new_r20*x625)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(8);
vinfos[0].jointtype = 17;
vinfos[0].foffset = j5;
vinfos[0].indices[0] = _ij5[0];
vinfos[0].indices[1] = _ij5[1];
vinfos[0].maxsolutions = _nj5;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j9;
vinfos[1].indices[0] = _ij9[0];
vinfos[1].indices[1] = _ij9[1];
vinfos[1].maxsolutions = _nj9;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j10;
vinfos[2].indices[0] = _ij10[0];
vinfos[2].indices[1] = _ij10[1];
vinfos[2].maxsolutions = _nj10;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j11;
vinfos[3].indices[0] = _ij11[0];
vinfos[3].indices[1] = _ij11[1];
vinfos[3].maxsolutions = _nj11;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j12;
vinfos[4].indices[0] = _ij12[0];
vinfos[4].indices[1] = _ij12[1];
vinfos[4].maxsolutions = _nj12;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j13;
vinfos[5].indices[0] = _ij13[0];
vinfos[5].indices[1] = _ij13[1];
vinfos[5].maxsolutions = _nj13;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j14;
vinfos[6].indices[0] = _ij14[0];
vinfos[6].indices[1] = _ij14[1];
vinfos[6].maxsolutions = _nj14;
vinfos[7].jointtype = 1;
vinfos[7].foffset = j15;
vinfos[7].indices[0] = _ij15[0];
vinfos[7].indices[1] = _ij15[1];
vinfos[7].maxsolutions = _nj15;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((-3.14159265358979)+j13)))), 6.28318530717959)));
evalcond[1]=new_r12;
if( IKabs(evalcond[0]) < 0.0000050000000000  && IKabs(evalcond[1]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j15eval[3];
sj13=0;
cj13=-1.0;
j13=3.14159265358979;
j15eval[0]=sj14;
j15eval[1]=IKsign(sj14);
j15eval[2]=((IKabs(new_r20))+(IKabs(new_r21)));
if( IKabs(j15eval[0]) < 0.0000010000000000  || IKabs(j15eval[1]) < 0.0000010000000000  || IKabs(j15eval[2]) < 0.0000010000000000  )
{
{
IkReal j15eval[1];
sj13=0;
cj13=-1.0;
j13=3.14159265358979;
j15eval[0]=sj14;
if( IKabs(j15eval[0]) < 0.0000010000000000  )
{
{
IkReal j15eval[2];
sj13=0;
cj13=-1.0;
j13=3.14159265358979;
j15eval[0]=cj14;
j15eval[1]=sj14;
if( IKabs(j15eval[0]) < 0.0000010000000000  || IKabs(j15eval[1]) < 0.0000010000000000  )
{
{
IkReal evalcond[4];
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((-1.5707963267949)+j14)))), 6.28318530717959)));
evalcond[1]=new_r22;
evalcond[2]=new_r01;
evalcond[3]=new_r00;
if( IKabs(evalcond[0]) < 0.0000050000000000  && IKabs(evalcond[1]) < 0.0000050000000000  && IKabs(evalcond[2]) < 0.0000050000000000  && IKabs(evalcond[3]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j15array[1], cj15array[1], sj15array[1];
bool j15valid[1]={false};
_nj15 = 1;
if( IKabs(new_r21) < IKFAST_ATAN2_MAGTHRESH && IKabs(((-1.0)*new_r20)) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(new_r21)+IKsqr(((-1.0)*new_r20))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j15array[0]=IKatan2(new_r21, ((-1.0)*new_r20));
sj15array[0]=IKsin(j15array[0]);
cj15array[0]=IKcos(j15array[0]);
if( j15array[0] > IKPI )
{
    j15array[0]-=IK2PI;
}
else if( j15array[0] < -IKPI )
{    j15array[0]+=IK2PI;
}
j15valid[0] = true;
for(int ij15 = 0; ij15 < 1; ++ij15)
{
if( !j15valid[ij15] )
{
    continue;
}
_ij15[0] = ij15; _ij15[1] = -1;
for(int iij15 = ij15+1; iij15 < 1; ++iij15)
{
if( j15valid[iij15] && IKabs(cj15array[ij15]-cj15array[iij15]) < IKFAST_SOLUTION_THRESH && IKabs(sj15array[ij15]-sj15array[iij15]) < IKFAST_SOLUTION_THRESH )
{
    j15valid[iij15]=false; _ij15[1] = iij15; break; 
}
}
j15 = j15array[ij15]; cj15 = cj15array[ij15]; sj15 = sj15array[ij15];
{
IkReal evalcond[4];
IkReal x627=IKcos(j15);
IkReal x628=((1.0)*(IKsin(j15)));
evalcond[0]=(x627+new_r20);
evalcond[1]=((((-1.0)*x628))+new_r21);
evalcond[2]=((((-1.0)*x628))+(((-1.0)*new_r10)));
evalcond[3]=((((-1.0)*new_r11))+(((-1.0)*x627)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(8);
vinfos[0].jointtype = 17;
vinfos[0].foffset = j5;
vinfos[0].indices[0] = _ij5[0];
vinfos[0].indices[1] = _ij5[1];
vinfos[0].maxsolutions = _nj5;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j9;
vinfos[1].indices[0] = _ij9[0];
vinfos[1].indices[1] = _ij9[1];
vinfos[1].maxsolutions = _nj9;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j10;
vinfos[2].indices[0] = _ij10[0];
vinfos[2].indices[1] = _ij10[1];
vinfos[2].maxsolutions = _nj10;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j11;
vinfos[3].indices[0] = _ij11[0];
vinfos[3].indices[1] = _ij11[1];
vinfos[3].maxsolutions = _nj11;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j12;
vinfos[4].indices[0] = _ij12[0];
vinfos[4].indices[1] = _ij12[1];
vinfos[4].maxsolutions = _nj12;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j13;
vinfos[5].indices[0] = _ij13[0];
vinfos[5].indices[1] = _ij13[1];
vinfos[5].maxsolutions = _nj13;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j14;
vinfos[6].indices[0] = _ij14[0];
vinfos[6].indices[1] = _ij14[1];
vinfos[6].maxsolutions = _nj14;
vinfos[7].jointtype = 1;
vinfos[7].foffset = j15;
vinfos[7].indices[0] = _ij15[0];
vinfos[7].indices[1] = _ij15[1];
vinfos[7].maxsolutions = _nj15;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((1.5707963267949)+j14)))), 6.28318530717959)));
evalcond[1]=new_r22;
evalcond[2]=new_r01;
evalcond[3]=new_r00;
if( IKabs(evalcond[0]) < 0.0000050000000000  && IKabs(evalcond[1]) < 0.0000050000000000  && IKabs(evalcond[2]) < 0.0000050000000000  && IKabs(evalcond[3]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j15array[1], cj15array[1], sj15array[1];
bool j15valid[1]={false};
_nj15 = 1;
if( IKabs(((-1.0)*new_r21)) < IKFAST_ATAN2_MAGTHRESH && IKabs(new_r20) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((-1.0)*new_r21))+IKsqr(new_r20)-1) <= IKFAST_SINCOS_THRESH )
    continue;
j15array[0]=IKatan2(((-1.0)*new_r21), new_r20);
sj15array[0]=IKsin(j15array[0]);
cj15array[0]=IKcos(j15array[0]);
if( j15array[0] > IKPI )
{
    j15array[0]-=IK2PI;
}
else if( j15array[0] < -IKPI )
{    j15array[0]+=IK2PI;
}
j15valid[0] = true;
for(int ij15 = 0; ij15 < 1; ++ij15)
{
if( !j15valid[ij15] )
{
    continue;
}
_ij15[0] = ij15; _ij15[1] = -1;
for(int iij15 = ij15+1; iij15 < 1; ++iij15)
{
if( j15valid[iij15] && IKabs(cj15array[ij15]-cj15array[iij15]) < IKFAST_SOLUTION_THRESH && IKabs(sj15array[ij15]-sj15array[iij15]) < IKFAST_SOLUTION_THRESH )
{
    j15valid[iij15]=false; _ij15[1] = iij15; break; 
}
}
j15 = j15array[ij15]; cj15 = cj15array[ij15]; sj15 = sj15array[ij15];
{
IkReal evalcond[4];
IkReal x629=IKsin(j15);
IkReal x630=((1.0)*(IKcos(j15)));
evalcond[0]=(x629+new_r21);
evalcond[1]=((((-1.0)*x630))+new_r20);
evalcond[2]=((((-1.0)*new_r10))+(((-1.0)*x629)));
evalcond[3]=((((-1.0)*x630))+(((-1.0)*new_r11)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(8);
vinfos[0].jointtype = 17;
vinfos[0].foffset = j5;
vinfos[0].indices[0] = _ij5[0];
vinfos[0].indices[1] = _ij5[1];
vinfos[0].maxsolutions = _nj5;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j9;
vinfos[1].indices[0] = _ij9[0];
vinfos[1].indices[1] = _ij9[1];
vinfos[1].maxsolutions = _nj9;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j10;
vinfos[2].indices[0] = _ij10[0];
vinfos[2].indices[1] = _ij10[1];
vinfos[2].maxsolutions = _nj10;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j11;
vinfos[3].indices[0] = _ij11[0];
vinfos[3].indices[1] = _ij11[1];
vinfos[3].maxsolutions = _nj11;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j12;
vinfos[4].indices[0] = _ij12[0];
vinfos[4].indices[1] = _ij12[1];
vinfos[4].maxsolutions = _nj12;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j13;
vinfos[5].indices[0] = _ij13[0];
vinfos[5].indices[1] = _ij13[1];
vinfos[5].maxsolutions = _nj13;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j14;
vinfos[6].indices[0] = _ij14[0];
vinfos[6].indices[1] = _ij14[1];
vinfos[6].maxsolutions = _nj14;
vinfos[7].jointtype = 1;
vinfos[7].foffset = j15;
vinfos[7].indices[0] = _ij15[0];
vinfos[7].indices[1] = _ij15[1];
vinfos[7].maxsolutions = _nj15;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(j14))), 6.28318530717959)));
evalcond[1]=new_r20;
evalcond[2]=new_r02;
evalcond[3]=new_r21;
if( IKabs(evalcond[0]) < 0.0000050000000000  && IKabs(evalcond[1]) < 0.0000050000000000  && IKabs(evalcond[2]) < 0.0000050000000000  && IKabs(evalcond[3]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j15array[1], cj15array[1], sj15array[1];
bool j15valid[1]={false};
_nj15 = 1;
if( IKabs(new_r01) < IKFAST_ATAN2_MAGTHRESH && IKabs(((-1.0)*new_r11)) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(new_r01)+IKsqr(((-1.0)*new_r11))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j15array[0]=IKatan2(new_r01, ((-1.0)*new_r11));
sj15array[0]=IKsin(j15array[0]);
cj15array[0]=IKcos(j15array[0]);
if( j15array[0] > IKPI )
{
    j15array[0]-=IK2PI;
}
else if( j15array[0] < -IKPI )
{    j15array[0]+=IK2PI;
}
j15valid[0] = true;
for(int ij15 = 0; ij15 < 1; ++ij15)
{
if( !j15valid[ij15] )
{
    continue;
}
_ij15[0] = ij15; _ij15[1] = -1;
for(int iij15 = ij15+1; iij15 < 1; ++iij15)
{
if( j15valid[iij15] && IKabs(cj15array[ij15]-cj15array[iij15]) < IKFAST_SOLUTION_THRESH && IKabs(sj15array[ij15]-sj15array[iij15]) < IKFAST_SOLUTION_THRESH )
{
    j15valid[iij15]=false; _ij15[1] = iij15; break; 
}
}
j15 = j15array[ij15]; cj15 = cj15array[ij15]; sj15 = sj15array[ij15];
{
IkReal evalcond[4];
IkReal x631=IKsin(j15);
IkReal x632=((1.0)*(IKcos(j15)));
evalcond[0]=(x631+(((-1.0)*new_r01)));
evalcond[1]=((((-1.0)*new_r10))+(((-1.0)*x631)));
evalcond[2]=((((-1.0)*x632))+(((-1.0)*new_r11)));
evalcond[3]=((((-1.0)*x632))+(((-1.0)*new_r00)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(8);
vinfos[0].jointtype = 17;
vinfos[0].foffset = j5;
vinfos[0].indices[0] = _ij5[0];
vinfos[0].indices[1] = _ij5[1];
vinfos[0].maxsolutions = _nj5;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j9;
vinfos[1].indices[0] = _ij9[0];
vinfos[1].indices[1] = _ij9[1];
vinfos[1].maxsolutions = _nj9;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j10;
vinfos[2].indices[0] = _ij10[0];
vinfos[2].indices[1] = _ij10[1];
vinfos[2].maxsolutions = _nj10;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j11;
vinfos[3].indices[0] = _ij11[0];
vinfos[3].indices[1] = _ij11[1];
vinfos[3].maxsolutions = _nj11;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j12;
vinfos[4].indices[0] = _ij12[0];
vinfos[4].indices[1] = _ij12[1];
vinfos[4].maxsolutions = _nj12;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j13;
vinfos[5].indices[0] = _ij13[0];
vinfos[5].indices[1] = _ij13[1];
vinfos[5].maxsolutions = _nj13;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j14;
vinfos[6].indices[0] = _ij14[0];
vinfos[6].indices[1] = _ij14[1];
vinfos[6].maxsolutions = _nj14;
vinfos[7].jointtype = 1;
vinfos[7].foffset = j15;
vinfos[7].indices[0] = _ij15[0];
vinfos[7].indices[1] = _ij15[1];
vinfos[7].maxsolutions = _nj15;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((-3.14159265358979)+j14)))), 6.28318530717959)));
evalcond[1]=new_r20;
evalcond[2]=new_r02;
evalcond[3]=new_r21;
if( IKabs(evalcond[0]) < 0.0000050000000000  && IKabs(evalcond[1]) < 0.0000050000000000  && IKabs(evalcond[2]) < 0.0000050000000000  && IKabs(evalcond[3]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j15array[1], cj15array[1], sj15array[1];
bool j15valid[1]={false};
_nj15 = 1;
if( IKabs(((-1.0)*new_r10)) < IKFAST_ATAN2_MAGTHRESH && IKabs(new_r00) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((-1.0)*new_r10))+IKsqr(new_r00)-1) <= IKFAST_SINCOS_THRESH )
    continue;
j15array[0]=IKatan2(((-1.0)*new_r10), new_r00);
sj15array[0]=IKsin(j15array[0]);
cj15array[0]=IKcos(j15array[0]);
if( j15array[0] > IKPI )
{
    j15array[0]-=IK2PI;
}
else if( j15array[0] < -IKPI )
{    j15array[0]+=IK2PI;
}
j15valid[0] = true;
for(int ij15 = 0; ij15 < 1; ++ij15)
{
if( !j15valid[ij15] )
{
    continue;
}
_ij15[0] = ij15; _ij15[1] = -1;
for(int iij15 = ij15+1; iij15 < 1; ++iij15)
{
if( j15valid[iij15] && IKabs(cj15array[ij15]-cj15array[iij15]) < IKFAST_SOLUTION_THRESH && IKabs(sj15array[ij15]-sj15array[iij15]) < IKFAST_SOLUTION_THRESH )
{
    j15valid[iij15]=false; _ij15[1] = iij15; break; 
}
}
j15 = j15array[ij15]; cj15 = cj15array[ij15]; sj15 = sj15array[ij15];
{
IkReal evalcond[4];
IkReal x633=IKcos(j15);
IkReal x634=((1.0)*(IKsin(j15)));
evalcond[0]=(x633+(((-1.0)*new_r00)));
evalcond[1]=((((-1.0)*x634))+(((-1.0)*new_r10)));
evalcond[2]=((((-1.0)*new_r11))+(((-1.0)*x633)));
evalcond[3]=((((-1.0)*x634))+(((-1.0)*new_r01)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(8);
vinfos[0].jointtype = 17;
vinfos[0].foffset = j5;
vinfos[0].indices[0] = _ij5[0];
vinfos[0].indices[1] = _ij5[1];
vinfos[0].maxsolutions = _nj5;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j9;
vinfos[1].indices[0] = _ij9[0];
vinfos[1].indices[1] = _ij9[1];
vinfos[1].maxsolutions = _nj9;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j10;
vinfos[2].indices[0] = _ij10[0];
vinfos[2].indices[1] = _ij10[1];
vinfos[2].maxsolutions = _nj10;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j11;
vinfos[3].indices[0] = _ij11[0];
vinfos[3].indices[1] = _ij11[1];
vinfos[3].maxsolutions = _nj11;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j12;
vinfos[4].indices[0] = _ij12[0];
vinfos[4].indices[1] = _ij12[1];
vinfos[4].maxsolutions = _nj12;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j13;
vinfos[5].indices[0] = _ij13[0];
vinfos[5].indices[1] = _ij13[1];
vinfos[5].maxsolutions = _nj13;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j14;
vinfos[6].indices[0] = _ij14[0];
vinfos[6].indices[1] = _ij14[1];
vinfos[6].maxsolutions = _nj14;
vinfos[7].jointtype = 1;
vinfos[7].foffset = j15;
vinfos[7].indices[0] = _ij15[0];
vinfos[7].indices[1] = _ij15[1];
vinfos[7].maxsolutions = _nj15;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((IKabs(new_r20))+(IKabs(new_r21)));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j15array[1], cj15array[1], sj15array[1];
bool j15valid[1]={false};
_nj15 = 1;
if( IKabs(((-1.0)*new_r10)) < IKFAST_ATAN2_MAGTHRESH && IKabs(((-1.0)*new_r11)) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((-1.0)*new_r10))+IKsqr(((-1.0)*new_r11))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j15array[0]=IKatan2(((-1.0)*new_r10), ((-1.0)*new_r11));
sj15array[0]=IKsin(j15array[0]);
cj15array[0]=IKcos(j15array[0]);
if( j15array[0] > IKPI )
{
    j15array[0]-=IK2PI;
}
else if( j15array[0] < -IKPI )
{    j15array[0]+=IK2PI;
}
j15valid[0] = true;
for(int ij15 = 0; ij15 < 1; ++ij15)
{
if( !j15valid[ij15] )
{
    continue;
}
_ij15[0] = ij15; _ij15[1] = -1;
for(int iij15 = ij15+1; iij15 < 1; ++iij15)
{
if( j15valid[iij15] && IKabs(cj15array[ij15]-cj15array[iij15]) < IKFAST_SOLUTION_THRESH && IKabs(sj15array[ij15]-sj15array[iij15]) < IKFAST_SOLUTION_THRESH )
{
    j15valid[iij15]=false; _ij15[1] = iij15; break; 
}
}
j15 = j15array[ij15]; cj15 = cj15array[ij15]; sj15 = sj15array[ij15];
{
IkReal evalcond[6];
IkReal x635=IKsin(j15);
IkReal x636=IKcos(j15);
IkReal x637=((-1.0)*x636);
evalcond[0]=x635;
evalcond[1]=(new_r22*x635);
evalcond[2]=x637;
evalcond[3]=(new_r22*x637);
evalcond[4]=((((-1.0)*new_r10))+(((-1.0)*x635)));
evalcond[5]=((((-1.0)*new_r11))+(((-1.0)*x636)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(8);
vinfos[0].jointtype = 17;
vinfos[0].foffset = j5;
vinfos[0].indices[0] = _ij5[0];
vinfos[0].indices[1] = _ij5[1];
vinfos[0].maxsolutions = _nj5;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j9;
vinfos[1].indices[0] = _ij9[0];
vinfos[1].indices[1] = _ij9[1];
vinfos[1].maxsolutions = _nj9;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j10;
vinfos[2].indices[0] = _ij10[0];
vinfos[2].indices[1] = _ij10[1];
vinfos[2].maxsolutions = _nj10;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j11;
vinfos[3].indices[0] = _ij11[0];
vinfos[3].indices[1] = _ij11[1];
vinfos[3].maxsolutions = _nj11;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j12;
vinfos[4].indices[0] = _ij12[0];
vinfos[4].indices[1] = _ij12[1];
vinfos[4].maxsolutions = _nj12;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j13;
vinfos[5].indices[0] = _ij13[0];
vinfos[5].indices[1] = _ij13[1];
vinfos[5].maxsolutions = _nj13;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j14;
vinfos[6].indices[0] = _ij14[0];
vinfos[6].indices[1] = _ij14[1];
vinfos[6].maxsolutions = _nj14;
vinfos[7].jointtype = 1;
vinfos[7].foffset = j15;
vinfos[7].indices[0] = _ij15[0];
vinfos[7].indices[1] = _ij15[1];
vinfos[7].maxsolutions = _nj15;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
if( 1 )
{
bgotonextstatement=false;
continue; // branch miss [j15]

}
} while(0);
if( bgotonextstatement )
{
}
}
}
}
}
}
}

} else
{
{
IkReal j15array[1], cj15array[1], sj15array[1];
bool j15valid[1]={false};
_nj15 = 1;
CheckValue<IkReal> x638=IKPowWithIntegerCheck(cj14,-1);
if(!x638.valid){
continue;
}
CheckValue<IkReal> x639=IKPowWithIntegerCheck(sj14,-1);
if(!x639.valid){
continue;
}
if( IKabs((new_r01*(x638.value))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((-1.0)*new_r20*(x639.value))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr((new_r01*(x638.value)))+IKsqr(((-1.0)*new_r20*(x639.value)))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j15array[0]=IKatan2((new_r01*(x638.value)), ((-1.0)*new_r20*(x639.value)));
sj15array[0]=IKsin(j15array[0]);
cj15array[0]=IKcos(j15array[0]);
if( j15array[0] > IKPI )
{
    j15array[0]-=IK2PI;
}
else if( j15array[0] < -IKPI )
{    j15array[0]+=IK2PI;
}
j15valid[0] = true;
for(int ij15 = 0; ij15 < 1; ++ij15)
{
if( !j15valid[ij15] )
{
    continue;
}
_ij15[0] = ij15; _ij15[1] = -1;
for(int iij15 = ij15+1; iij15 < 1; ++iij15)
{
if( j15valid[iij15] && IKabs(cj15array[ij15]-cj15array[iij15]) < IKFAST_SOLUTION_THRESH && IKabs(sj15array[ij15]-sj15array[iij15]) < IKFAST_SOLUTION_THRESH )
{
    j15valid[iij15]=false; _ij15[1] = iij15; break; 
}
}
j15 = j15array[ij15]; cj15 = cj15array[ij15]; sj15 = sj15array[ij15];
{
IkReal evalcond[8];
IkReal x640=IKsin(j15);
IkReal x641=IKcos(j15);
IkReal x642=((1.0)*new_r00);
IkReal x643=((1.0)*sj14);
IkReal x644=((1.0)*new_r01);
IkReal x645=((1.0)*x641);
evalcond[0]=(new_r20+((sj14*x641)));
evalcond[1]=((((-1.0)*x640*x643))+new_r21);
evalcond[2]=((((-1.0)*x640))+(((-1.0)*new_r10)));
evalcond[3]=((((-1.0)*x645))+(((-1.0)*new_r11)));
evalcond[4]=((((-1.0)*x644))+((cj14*x640)));
evalcond[5]=((((-1.0)*x642))+(((-1.0)*cj14*x645)));
evalcond[6]=((((-1.0)*new_r21*x643))+x640+(((-1.0)*cj14*x644)));
evalcond[7]=((((-1.0)*x645))+(((-1.0)*cj14*x642))+(((-1.0)*new_r20*x643)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(8);
vinfos[0].jointtype = 17;
vinfos[0].foffset = j5;
vinfos[0].indices[0] = _ij5[0];
vinfos[0].indices[1] = _ij5[1];
vinfos[0].maxsolutions = _nj5;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j9;
vinfos[1].indices[0] = _ij9[0];
vinfos[1].indices[1] = _ij9[1];
vinfos[1].maxsolutions = _nj9;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j10;
vinfos[2].indices[0] = _ij10[0];
vinfos[2].indices[1] = _ij10[1];
vinfos[2].maxsolutions = _nj10;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j11;
vinfos[3].indices[0] = _ij11[0];
vinfos[3].indices[1] = _ij11[1];
vinfos[3].maxsolutions = _nj11;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j12;
vinfos[4].indices[0] = _ij12[0];
vinfos[4].indices[1] = _ij12[1];
vinfos[4].maxsolutions = _nj12;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j13;
vinfos[5].indices[0] = _ij13[0];
vinfos[5].indices[1] = _ij13[1];
vinfos[5].maxsolutions = _nj13;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j14;
vinfos[6].indices[0] = _ij14[0];
vinfos[6].indices[1] = _ij14[1];
vinfos[6].maxsolutions = _nj14;
vinfos[7].jointtype = 1;
vinfos[7].foffset = j15;
vinfos[7].indices[0] = _ij15[0];
vinfos[7].indices[1] = _ij15[1];
vinfos[7].maxsolutions = _nj15;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

} else
{
{
IkReal j15array[1], cj15array[1], sj15array[1];
bool j15valid[1]={false};
_nj15 = 1;
CheckValue<IkReal> x646=IKPowWithIntegerCheck(sj14,-1);
if(!x646.valid){
continue;
}
if( IKabs((new_r21*(x646.value))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((-1.0)*new_r11)) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr((new_r21*(x646.value)))+IKsqr(((-1.0)*new_r11))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j15array[0]=IKatan2((new_r21*(x646.value)), ((-1.0)*new_r11));
sj15array[0]=IKsin(j15array[0]);
cj15array[0]=IKcos(j15array[0]);
if( j15array[0] > IKPI )
{
    j15array[0]-=IK2PI;
}
else if( j15array[0] < -IKPI )
{    j15array[0]+=IK2PI;
}
j15valid[0] = true;
for(int ij15 = 0; ij15 < 1; ++ij15)
{
if( !j15valid[ij15] )
{
    continue;
}
_ij15[0] = ij15; _ij15[1] = -1;
for(int iij15 = ij15+1; iij15 < 1; ++iij15)
{
if( j15valid[iij15] && IKabs(cj15array[ij15]-cj15array[iij15]) < IKFAST_SOLUTION_THRESH && IKabs(sj15array[ij15]-sj15array[iij15]) < IKFAST_SOLUTION_THRESH )
{
    j15valid[iij15]=false; _ij15[1] = iij15; break; 
}
}
j15 = j15array[ij15]; cj15 = cj15array[ij15]; sj15 = sj15array[ij15];
{
IkReal evalcond[8];
IkReal x647=IKsin(j15);
IkReal x648=IKcos(j15);
IkReal x649=((1.0)*new_r00);
IkReal x650=((1.0)*sj14);
IkReal x651=((1.0)*new_r01);
IkReal x652=((1.0)*x648);
evalcond[0]=(new_r20+((sj14*x648)));
evalcond[1]=((((-1.0)*x647*x650))+new_r21);
evalcond[2]=((((-1.0)*x647))+(((-1.0)*new_r10)));
evalcond[3]=((((-1.0)*x652))+(((-1.0)*new_r11)));
evalcond[4]=((((-1.0)*x651))+((cj14*x647)));
evalcond[5]=((((-1.0)*x649))+(((-1.0)*cj14*x652)));
evalcond[6]=(x647+(((-1.0)*cj14*x651))+(((-1.0)*new_r21*x650)));
evalcond[7]=((((-1.0)*x652))+(((-1.0)*new_r20*x650))+(((-1.0)*cj14*x649)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(8);
vinfos[0].jointtype = 17;
vinfos[0].foffset = j5;
vinfos[0].indices[0] = _ij5[0];
vinfos[0].indices[1] = _ij5[1];
vinfos[0].maxsolutions = _nj5;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j9;
vinfos[1].indices[0] = _ij9[0];
vinfos[1].indices[1] = _ij9[1];
vinfos[1].maxsolutions = _nj9;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j10;
vinfos[2].indices[0] = _ij10[0];
vinfos[2].indices[1] = _ij10[1];
vinfos[2].maxsolutions = _nj10;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j11;
vinfos[3].indices[0] = _ij11[0];
vinfos[3].indices[1] = _ij11[1];
vinfos[3].maxsolutions = _nj11;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j12;
vinfos[4].indices[0] = _ij12[0];
vinfos[4].indices[1] = _ij12[1];
vinfos[4].maxsolutions = _nj12;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j13;
vinfos[5].indices[0] = _ij13[0];
vinfos[5].indices[1] = _ij13[1];
vinfos[5].maxsolutions = _nj13;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j14;
vinfos[6].indices[0] = _ij14[0];
vinfos[6].indices[1] = _ij14[1];
vinfos[6].maxsolutions = _nj14;
vinfos[7].jointtype = 1;
vinfos[7].foffset = j15;
vinfos[7].indices[0] = _ij15[0];
vinfos[7].indices[1] = _ij15[1];
vinfos[7].maxsolutions = _nj15;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

} else
{
{
IkReal j15array[1], cj15array[1], sj15array[1];
bool j15valid[1]={false};
_nj15 = 1;
CheckValue<IkReal> x653=IKPowWithIntegerCheck(IKsign(sj14),-1);
if(!x653.valid){
continue;
}
CheckValue<IkReal> x654 = IKatan2WithCheck(IkReal(new_r21),IkReal(((-1.0)*new_r20)),IKFAST_ATAN2_MAGTHRESH);
if(!x654.valid){
continue;
}
j15array[0]=((-1.5707963267949)+(((1.5707963267949)*(x653.value)))+(x654.value));
sj15array[0]=IKsin(j15array[0]);
cj15array[0]=IKcos(j15array[0]);
if( j15array[0] > IKPI )
{
    j15array[0]-=IK2PI;
}
else if( j15array[0] < -IKPI )
{    j15array[0]+=IK2PI;
}
j15valid[0] = true;
for(int ij15 = 0; ij15 < 1; ++ij15)
{
if( !j15valid[ij15] )
{
    continue;
}
_ij15[0] = ij15; _ij15[1] = -1;
for(int iij15 = ij15+1; iij15 < 1; ++iij15)
{
if( j15valid[iij15] && IKabs(cj15array[ij15]-cj15array[iij15]) < IKFAST_SOLUTION_THRESH && IKabs(sj15array[ij15]-sj15array[iij15]) < IKFAST_SOLUTION_THRESH )
{
    j15valid[iij15]=false; _ij15[1] = iij15; break; 
}
}
j15 = j15array[ij15]; cj15 = cj15array[ij15]; sj15 = sj15array[ij15];
{
IkReal evalcond[8];
IkReal x655=IKsin(j15);
IkReal x656=IKcos(j15);
IkReal x657=((1.0)*new_r00);
IkReal x658=((1.0)*sj14);
IkReal x659=((1.0)*new_r01);
IkReal x660=((1.0)*x656);
evalcond[0]=(new_r20+((sj14*x656)));
evalcond[1]=((((-1.0)*x655*x658))+new_r21);
evalcond[2]=((((-1.0)*x655))+(((-1.0)*new_r10)));
evalcond[3]=((((-1.0)*x660))+(((-1.0)*new_r11)));
evalcond[4]=((((-1.0)*x659))+((cj14*x655)));
evalcond[5]=((((-1.0)*cj14*x660))+(((-1.0)*x657)));
evalcond[6]=(x655+(((-1.0)*cj14*x659))+(((-1.0)*new_r21*x658)));
evalcond[7]=((((-1.0)*new_r20*x658))+(((-1.0)*x660))+(((-1.0)*cj14*x657)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(8);
vinfos[0].jointtype = 17;
vinfos[0].foffset = j5;
vinfos[0].indices[0] = _ij5[0];
vinfos[0].indices[1] = _ij5[1];
vinfos[0].maxsolutions = _nj5;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j9;
vinfos[1].indices[0] = _ij9[0];
vinfos[1].indices[1] = _ij9[1];
vinfos[1].maxsolutions = _nj9;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j10;
vinfos[2].indices[0] = _ij10[0];
vinfos[2].indices[1] = _ij10[1];
vinfos[2].maxsolutions = _nj10;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j11;
vinfos[3].indices[0] = _ij11[0];
vinfos[3].indices[1] = _ij11[1];
vinfos[3].maxsolutions = _nj11;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j12;
vinfos[4].indices[0] = _ij12[0];
vinfos[4].indices[1] = _ij12[1];
vinfos[4].maxsolutions = _nj12;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j13;
vinfos[5].indices[0] = _ij13[0];
vinfos[5].indices[1] = _ij13[1];
vinfos[5].maxsolutions = _nj13;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j14;
vinfos[6].indices[0] = _ij14[0];
vinfos[6].indices[1] = _ij14[1];
vinfos[6].maxsolutions = _nj14;
vinfos[7].jointtype = 1;
vinfos[7].foffset = j15;
vinfos[7].indices[0] = _ij15[0];
vinfos[7].indices[1] = _ij15[1];
vinfos[7].maxsolutions = _nj15;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(j14))), 6.28318530717959)));
evalcond[1]=new_r20;
evalcond[2]=new_r02;
evalcond[3]=new_r12;
evalcond[4]=new_r21;
if( IKabs(evalcond[0]) < 0.0000050000000000  && IKabs(evalcond[1]) < 0.0000050000000000  && IKabs(evalcond[2]) < 0.0000050000000000  && IKabs(evalcond[3]) < 0.0000050000000000  && IKabs(evalcond[4]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j15array[1], cj15array[1], sj15array[1];
bool j15valid[1]={false};
_nj15 = 1;
IkReal x661=((1.0)*new_r01);
if( IKabs(((((-1.0)*cj13*x661))+(((-1.0)*new_r00*sj13)))) < IKFAST_ATAN2_MAGTHRESH && IKabs((((cj13*new_r00))+(((-1.0)*sj13*x661)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((((-1.0)*cj13*x661))+(((-1.0)*new_r00*sj13))))+IKsqr((((cj13*new_r00))+(((-1.0)*sj13*x661))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j15array[0]=IKatan2(((((-1.0)*cj13*x661))+(((-1.0)*new_r00*sj13))), (((cj13*new_r00))+(((-1.0)*sj13*x661))));
sj15array[0]=IKsin(j15array[0]);
cj15array[0]=IKcos(j15array[0]);
if( j15array[0] > IKPI )
{
    j15array[0]-=IK2PI;
}
else if( j15array[0] < -IKPI )
{    j15array[0]+=IK2PI;
}
j15valid[0] = true;
for(int ij15 = 0; ij15 < 1; ++ij15)
{
if( !j15valid[ij15] )
{
    continue;
}
_ij15[0] = ij15; _ij15[1] = -1;
for(int iij15 = ij15+1; iij15 < 1; ++iij15)
{
if( j15valid[iij15] && IKabs(cj15array[ij15]-cj15array[iij15]) < IKFAST_SOLUTION_THRESH && IKabs(sj15array[ij15]-sj15array[iij15]) < IKFAST_SOLUTION_THRESH )
{
    j15valid[iij15]=false; _ij15[1] = iij15; break; 
}
}
j15 = j15array[ij15]; cj15 = cj15array[ij15]; sj15 = sj15array[ij15];
{
IkReal evalcond[8];
IkReal x662=IKsin(j15);
IkReal x663=IKcos(j15);
IkReal x664=((1.0)*cj13);
IkReal x665=((1.0)*sj13);
IkReal x666=((1.0)*x663);
IkReal x667=(sj13*x662);
IkReal x668=(x663*x664);
evalcond[0]=(((cj13*new_r01))+x662+((new_r11*sj13)));
evalcond[1]=(((sj13*x663))+new_r01+((cj13*x662)));
evalcond[2]=(((cj13*new_r00))+(((-1.0)*x666))+((new_r10*sj13)));
evalcond[3]=(((cj13*new_r10))+(((-1.0)*x662))+(((-1.0)*new_r00*x665)));
evalcond[4]=(((cj13*new_r11))+(((-1.0)*x666))+(((-1.0)*new_r01*x665)));
evalcond[5]=((((-1.0)*x668))+x667+new_r00);
evalcond[6]=((((-1.0)*x668))+x667+new_r11);
evalcond[7]=((((-1.0)*x662*x664))+(((-1.0)*x663*x665))+new_r10);
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(8);
vinfos[0].jointtype = 17;
vinfos[0].foffset = j5;
vinfos[0].indices[0] = _ij5[0];
vinfos[0].indices[1] = _ij5[1];
vinfos[0].maxsolutions = _nj5;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j9;
vinfos[1].indices[0] = _ij9[0];
vinfos[1].indices[1] = _ij9[1];
vinfos[1].maxsolutions = _nj9;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j10;
vinfos[2].indices[0] = _ij10[0];
vinfos[2].indices[1] = _ij10[1];
vinfos[2].maxsolutions = _nj10;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j11;
vinfos[3].indices[0] = _ij11[0];
vinfos[3].indices[1] = _ij11[1];
vinfos[3].maxsolutions = _nj11;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j12;
vinfos[4].indices[0] = _ij12[0];
vinfos[4].indices[1] = _ij12[1];
vinfos[4].maxsolutions = _nj12;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j13;
vinfos[5].indices[0] = _ij13[0];
vinfos[5].indices[1] = _ij13[1];
vinfos[5].maxsolutions = _nj13;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j14;
vinfos[6].indices[0] = _ij14[0];
vinfos[6].indices[1] = _ij14[1];
vinfos[6].maxsolutions = _nj14;
vinfos[7].jointtype = 1;
vinfos[7].foffset = j15;
vinfos[7].indices[0] = _ij15[0];
vinfos[7].indices[1] = _ij15[1];
vinfos[7].maxsolutions = _nj15;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((-3.14159265358979)+j14)))), 6.28318530717959)));
evalcond[1]=new_r20;
evalcond[2]=new_r02;
evalcond[3]=new_r12;
evalcond[4]=new_r21;
if( IKabs(evalcond[0]) < 0.0000050000000000  && IKabs(evalcond[1]) < 0.0000050000000000  && IKabs(evalcond[2]) < 0.0000050000000000  && IKabs(evalcond[3]) < 0.0000050000000000  && IKabs(evalcond[4]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j15array[1], cj15array[1], sj15array[1];
bool j15valid[1]={false};
_nj15 = 1;
IkReal x669=((1.0)*new_r00);
if( IKabs((((cj13*new_r01))+(((-1.0)*sj13*x669)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((((-1.0)*new_r01*sj13))+(((-1.0)*cj13*x669)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr((((cj13*new_r01))+(((-1.0)*sj13*x669))))+IKsqr(((((-1.0)*new_r01*sj13))+(((-1.0)*cj13*x669))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j15array[0]=IKatan2((((cj13*new_r01))+(((-1.0)*sj13*x669))), ((((-1.0)*new_r01*sj13))+(((-1.0)*cj13*x669))));
sj15array[0]=IKsin(j15array[0]);
cj15array[0]=IKcos(j15array[0]);
if( j15array[0] > IKPI )
{
    j15array[0]-=IK2PI;
}
else if( j15array[0] < -IKPI )
{    j15array[0]+=IK2PI;
}
j15valid[0] = true;
for(int ij15 = 0; ij15 < 1; ++ij15)
{
if( !j15valid[ij15] )
{
    continue;
}
_ij15[0] = ij15; _ij15[1] = -1;
for(int iij15 = ij15+1; iij15 < 1; ++iij15)
{
if( j15valid[iij15] && IKabs(cj15array[ij15]-cj15array[iij15]) < IKFAST_SOLUTION_THRESH && IKabs(sj15array[ij15]-sj15array[iij15]) < IKFAST_SOLUTION_THRESH )
{
    j15valid[iij15]=false; _ij15[1] = iij15; break; 
}
}
j15 = j15array[ij15]; cj15 = cj15array[ij15]; sj15 = sj15array[ij15];
{
IkReal evalcond[8];
IkReal x670=IKsin(j15);
IkReal x671=IKcos(j15);
IkReal x672=((1.0)*cj13);
IkReal x673=((1.0)*sj13);
IkReal x674=((1.0)*x670);
IkReal x675=(sj13*x671);
IkReal x676=(x670*x672);
evalcond[0]=(((cj13*new_r00))+x671+((new_r10*sj13)));
evalcond[1]=(((cj13*new_r01))+((new_r11*sj13))+(((-1.0)*x674)));
evalcond[2]=(((cj13*x671))+((sj13*x670))+new_r00);
evalcond[3]=(((cj13*new_r10))+(((-1.0)*new_r00*x673))+(((-1.0)*x674)));
evalcond[4]=((((-1.0)*new_r01*x673))+((cj13*new_r11))+(((-1.0)*x671)));
evalcond[5]=(x675+new_r01+(((-1.0)*x676)));
evalcond[6]=(x675+new_r10+(((-1.0)*x676)));
evalcond[7]=((((-1.0)*x670*x673))+(((-1.0)*x671*x672))+new_r11);
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(8);
vinfos[0].jointtype = 17;
vinfos[0].foffset = j5;
vinfos[0].indices[0] = _ij5[0];
vinfos[0].indices[1] = _ij5[1];
vinfos[0].maxsolutions = _nj5;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j9;
vinfos[1].indices[0] = _ij9[0];
vinfos[1].indices[1] = _ij9[1];
vinfos[1].maxsolutions = _nj9;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j10;
vinfos[2].indices[0] = _ij10[0];
vinfos[2].indices[1] = _ij10[1];
vinfos[2].maxsolutions = _nj10;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j11;
vinfos[3].indices[0] = _ij11[0];
vinfos[3].indices[1] = _ij11[1];
vinfos[3].maxsolutions = _nj11;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j12;
vinfos[4].indices[0] = _ij12[0];
vinfos[4].indices[1] = _ij12[1];
vinfos[4].maxsolutions = _nj12;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j13;
vinfos[5].indices[0] = _ij13[0];
vinfos[5].indices[1] = _ij13[1];
vinfos[5].maxsolutions = _nj13;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j14;
vinfos[6].indices[0] = _ij14[0];
vinfos[6].indices[1] = _ij14[1];
vinfos[6].maxsolutions = _nj14;
vinfos[7].jointtype = 1;
vinfos[7].foffset = j15;
vinfos[7].indices[0] = _ij15[0];
vinfos[7].indices[1] = _ij15[1];
vinfos[7].maxsolutions = _nj15;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((IKabs(new_r20))+(IKabs(new_r21)));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j15eval[1];
new_r21=0;
new_r20=0;
new_r02=0;
new_r12=0;
j15eval[0]=1.0;
if( IKabs(j15eval[0]) < 0.0000000100000000  )
{
continue; // no branches [j15]

} else
{
IkReal op[2+1], zeror[2];
int numroots;
op[0]=1.0;
op[1]=0;
op[2]=-1.0;
polyroots2(op,zeror,numroots);
IkReal j15array[2], cj15array[2], sj15array[2], tempj15array[1];
int numsolutions = 0;
for(int ij15 = 0; ij15 < numroots; ++ij15)
{
IkReal htj15 = zeror[ij15];
tempj15array[0]=((2.0)*(atan(htj15)));
for(int kj15 = 0; kj15 < 1; ++kj15)
{
j15array[numsolutions] = tempj15array[kj15];
if( j15array[numsolutions] > IKPI )
{
    j15array[numsolutions]-=IK2PI;
}
else if( j15array[numsolutions] < -IKPI )
{
    j15array[numsolutions]+=IK2PI;
}
sj15array[numsolutions] = IKsin(j15array[numsolutions]);
cj15array[numsolutions] = IKcos(j15array[numsolutions]);
numsolutions++;
}
}
bool j15valid[2]={true,true};
_nj15 = 2;
for(int ij15 = 0; ij15 < numsolutions; ++ij15)
    {
if( !j15valid[ij15] )
{
    continue;
}
    j15 = j15array[ij15]; cj15 = cj15array[ij15]; sj15 = sj15array[ij15];
htj15 = IKtan(j15/2);

_ij15[0] = ij15; _ij15[1] = -1;
for(int iij15 = ij15+1; iij15 < numsolutions; ++iij15)
{
if( j15valid[iij15] && IKabs(cj15array[ij15]-cj15array[iij15]) < IKFAST_SOLUTION_THRESH && IKabs(sj15array[ij15]-sj15array[iij15]) < IKFAST_SOLUTION_THRESH )
{
    j15valid[iij15]=false; _ij15[1] = iij15; break; 
}
}
{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(8);
vinfos[0].jointtype = 17;
vinfos[0].foffset = j5;
vinfos[0].indices[0] = _ij5[0];
vinfos[0].indices[1] = _ij5[1];
vinfos[0].maxsolutions = _nj5;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j9;
vinfos[1].indices[0] = _ij9[0];
vinfos[1].indices[1] = _ij9[1];
vinfos[1].maxsolutions = _nj9;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j10;
vinfos[2].indices[0] = _ij10[0];
vinfos[2].indices[1] = _ij10[1];
vinfos[2].maxsolutions = _nj10;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j11;
vinfos[3].indices[0] = _ij11[0];
vinfos[3].indices[1] = _ij11[1];
vinfos[3].maxsolutions = _nj11;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j12;
vinfos[4].indices[0] = _ij12[0];
vinfos[4].indices[1] = _ij12[1];
vinfos[4].maxsolutions = _nj12;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j13;
vinfos[5].indices[0] = _ij13[0];
vinfos[5].indices[1] = _ij13[1];
vinfos[5].maxsolutions = _nj13;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j14;
vinfos[6].indices[0] = _ij14[0];
vinfos[6].indices[1] = _ij14[1];
vinfos[6].maxsolutions = _nj14;
vinfos[7].jointtype = 1;
vinfos[7].foffset = j15;
vinfos[7].indices[0] = _ij15[0];
vinfos[7].indices[1] = _ij15[1];
vinfos[7].maxsolutions = _nj15;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
    }

}

}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
if( 1 )
{
bgotonextstatement=false;
continue; // branch miss [j15]

}
} while(0);
if( bgotonextstatement )
{
}
}
}
}
}
}
}
}
}

} else
{
{
IkReal j15array[1], cj15array[1], sj15array[1];
bool j15valid[1]={false};
_nj15 = 1;
CheckValue<IkReal> x678=IKPowWithIntegerCheck(sj14,-1);
if(!x678.valid){
continue;
}
IkReal x677=x678.value;
CheckValue<IkReal> x679=IKPowWithIntegerCheck(cj14,-1);
if(!x679.valid){
continue;
}
CheckValue<IkReal> x680=IKPowWithIntegerCheck(sj13,-1);
if(!x680.valid){
continue;
}
if( IKabs((x677*(x679.value)*(x680.value)*(((((-1.0)*cj13*new_r20))+(((-1.0)*new_r11*sj14)))))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((-1.0)*new_r20*x677)) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr((x677*(x679.value)*(x680.value)*(((((-1.0)*cj13*new_r20))+(((-1.0)*new_r11*sj14))))))+IKsqr(((-1.0)*new_r20*x677))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j15array[0]=IKatan2((x677*(x679.value)*(x680.value)*(((((-1.0)*cj13*new_r20))+(((-1.0)*new_r11*sj14))))), ((-1.0)*new_r20*x677));
sj15array[0]=IKsin(j15array[0]);
cj15array[0]=IKcos(j15array[0]);
if( j15array[0] > IKPI )
{
    j15array[0]-=IK2PI;
}
else if( j15array[0] < -IKPI )
{    j15array[0]+=IK2PI;
}
j15valid[0] = true;
for(int ij15 = 0; ij15 < 1; ++ij15)
{
if( !j15valid[ij15] )
{
    continue;
}
_ij15[0] = ij15; _ij15[1] = -1;
for(int iij15 = ij15+1; iij15 < 1; ++iij15)
{
if( j15valid[iij15] && IKabs(cj15array[ij15]-cj15array[iij15]) < IKFAST_SOLUTION_THRESH && IKabs(sj15array[ij15]-sj15array[iij15]) < IKFAST_SOLUTION_THRESH )
{
    j15valid[iij15]=false; _ij15[1] = iij15; break; 
}
}
j15 = j15array[ij15]; cj15 = cj15array[ij15]; sj15 = sj15array[ij15];
{
IkReal evalcond[12];
IkReal x681=IKsin(j15);
IkReal x682=IKcos(j15);
IkReal x683=(cj13*cj14);
IkReal x684=((1.0)*sj14);
IkReal x685=(cj14*sj13);
IkReal x686=((1.0)*sj13);
IkReal x687=((1.0)*x682);
IkReal x688=((1.0)*x681);
evalcond[0]=(((sj14*x682))+new_r20);
evalcond[1]=((((-1.0)*x681*x684))+new_r21);
evalcond[2]=(((cj14*x681))+((cj13*new_r01))+((new_r11*sj13)));
evalcond[3]=(((cj13*new_r10))+(((-1.0)*x688))+(((-1.0)*new_r00*x686)));
evalcond[4]=(((cj13*new_r11))+(((-1.0)*new_r01*x686))+(((-1.0)*x687)));
evalcond[5]=(((x681*x683))+((sj13*x682))+new_r01);
evalcond[6]=(((cj13*new_r00))+(((-1.0)*cj14*x687))+((new_r10*sj13)));
evalcond[7]=(((sj13*x681))+(((-1.0)*x683*x687))+new_r00);
evalcond[8]=(((x681*x685))+new_r11+(((-1.0)*cj13*x687)));
evalcond[9]=((((-1.0)*x685*x687))+new_r10+(((-1.0)*cj13*x688)));
evalcond[10]=(((new_r01*x683))+(((-1.0)*new_r21*x684))+x681+((new_r11*x685)));
evalcond[11]=((((-1.0)*x687))+((new_r00*x683))+(((-1.0)*new_r20*x684))+((new_r10*x685)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[8]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[9]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[10]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[11]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(8);
vinfos[0].jointtype = 17;
vinfos[0].foffset = j5;
vinfos[0].indices[0] = _ij5[0];
vinfos[0].indices[1] = _ij5[1];
vinfos[0].maxsolutions = _nj5;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j9;
vinfos[1].indices[0] = _ij9[0];
vinfos[1].indices[1] = _ij9[1];
vinfos[1].maxsolutions = _nj9;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j10;
vinfos[2].indices[0] = _ij10[0];
vinfos[2].indices[1] = _ij10[1];
vinfos[2].maxsolutions = _nj10;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j11;
vinfos[3].indices[0] = _ij11[0];
vinfos[3].indices[1] = _ij11[1];
vinfos[3].maxsolutions = _nj11;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j12;
vinfos[4].indices[0] = _ij12[0];
vinfos[4].indices[1] = _ij12[1];
vinfos[4].maxsolutions = _nj12;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j13;
vinfos[5].indices[0] = _ij13[0];
vinfos[5].indices[1] = _ij13[1];
vinfos[5].maxsolutions = _nj13;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j14;
vinfos[6].indices[0] = _ij14[0];
vinfos[6].indices[1] = _ij14[1];
vinfos[6].maxsolutions = _nj14;
vinfos[7].jointtype = 1;
vinfos[7].foffset = j15;
vinfos[7].indices[0] = _ij15[0];
vinfos[7].indices[1] = _ij15[1];
vinfos[7].maxsolutions = _nj15;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

} else
{
{
IkReal j15array[1], cj15array[1], sj15array[1];
bool j15valid[1]={false};
_nj15 = 1;
CheckValue<IkReal> x690=IKPowWithIntegerCheck(sj14,-1);
if(!x690.valid){
continue;
}
IkReal x689=x690.value;
CheckValue<IkReal> x691=IKPowWithIntegerCheck(sj13,-1);
if(!x691.valid){
continue;
}
if( IKabs((new_r21*x689)) < IKFAST_ATAN2_MAGTHRESH && IKabs((x689*(x691.value)*(((((-1.0)*cj13*cj14*new_r21))+(((-1.0)*new_r01*sj14)))))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr((new_r21*x689))+IKsqr((x689*(x691.value)*(((((-1.0)*cj13*cj14*new_r21))+(((-1.0)*new_r01*sj14))))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j15array[0]=IKatan2((new_r21*x689), (x689*(x691.value)*(((((-1.0)*cj13*cj14*new_r21))+(((-1.0)*new_r01*sj14))))));
sj15array[0]=IKsin(j15array[0]);
cj15array[0]=IKcos(j15array[0]);
if( j15array[0] > IKPI )
{
    j15array[0]-=IK2PI;
}
else if( j15array[0] < -IKPI )
{    j15array[0]+=IK2PI;
}
j15valid[0] = true;
for(int ij15 = 0; ij15 < 1; ++ij15)
{
if( !j15valid[ij15] )
{
    continue;
}
_ij15[0] = ij15; _ij15[1] = -1;
for(int iij15 = ij15+1; iij15 < 1; ++iij15)
{
if( j15valid[iij15] && IKabs(cj15array[ij15]-cj15array[iij15]) < IKFAST_SOLUTION_THRESH && IKabs(sj15array[ij15]-sj15array[iij15]) < IKFAST_SOLUTION_THRESH )
{
    j15valid[iij15]=false; _ij15[1] = iij15; break; 
}
}
j15 = j15array[ij15]; cj15 = cj15array[ij15]; sj15 = sj15array[ij15];
{
IkReal evalcond[12];
IkReal x692=IKsin(j15);
IkReal x693=IKcos(j15);
IkReal x694=(cj13*cj14);
IkReal x695=((1.0)*sj14);
IkReal x696=(cj14*sj13);
IkReal x697=((1.0)*sj13);
IkReal x698=((1.0)*x693);
IkReal x699=((1.0)*x692);
evalcond[0]=(((sj14*x693))+new_r20);
evalcond[1]=((((-1.0)*x692*x695))+new_r21);
evalcond[2]=(((cj13*new_r01))+((cj14*x692))+((new_r11*sj13)));
evalcond[3]=(((cj13*new_r10))+(((-1.0)*new_r00*x697))+(((-1.0)*x699)));
evalcond[4]=(((cj13*new_r11))+(((-1.0)*new_r01*x697))+(((-1.0)*x698)));
evalcond[5]=(((sj13*x693))+((x692*x694))+new_r01);
evalcond[6]=(((cj13*new_r00))+(((-1.0)*cj14*x698))+((new_r10*sj13)));
evalcond[7]=(((sj13*x692))+(((-1.0)*x694*x698))+new_r00);
evalcond[8]=(((x692*x696))+new_r11+(((-1.0)*cj13*x698)));
evalcond[9]=((((-1.0)*x696*x698))+new_r10+(((-1.0)*cj13*x699)));
evalcond[10]=(((new_r11*x696))+x692+((new_r01*x694))+(((-1.0)*new_r21*x695)));
evalcond[11]=(((new_r10*x696))+(((-1.0)*x698))+((new_r00*x694))+(((-1.0)*new_r20*x695)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[8]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[9]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[10]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[11]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(8);
vinfos[0].jointtype = 17;
vinfos[0].foffset = j5;
vinfos[0].indices[0] = _ij5[0];
vinfos[0].indices[1] = _ij5[1];
vinfos[0].maxsolutions = _nj5;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j9;
vinfos[1].indices[0] = _ij9[0];
vinfos[1].indices[1] = _ij9[1];
vinfos[1].maxsolutions = _nj9;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j10;
vinfos[2].indices[0] = _ij10[0];
vinfos[2].indices[1] = _ij10[1];
vinfos[2].maxsolutions = _nj10;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j11;
vinfos[3].indices[0] = _ij11[0];
vinfos[3].indices[1] = _ij11[1];
vinfos[3].maxsolutions = _nj11;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j12;
vinfos[4].indices[0] = _ij12[0];
vinfos[4].indices[1] = _ij12[1];
vinfos[4].maxsolutions = _nj12;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j13;
vinfos[5].indices[0] = _ij13[0];
vinfos[5].indices[1] = _ij13[1];
vinfos[5].maxsolutions = _nj13;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j14;
vinfos[6].indices[0] = _ij14[0];
vinfos[6].indices[1] = _ij14[1];
vinfos[6].maxsolutions = _nj14;
vinfos[7].jointtype = 1;
vinfos[7].foffset = j15;
vinfos[7].indices[0] = _ij15[0];
vinfos[7].indices[1] = _ij15[1];
vinfos[7].maxsolutions = _nj15;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

} else
{
{
IkReal j15array[1], cj15array[1], sj15array[1];
bool j15valid[1]={false};
_nj15 = 1;
CheckValue<IkReal> x700=IKPowWithIntegerCheck(IKsign(sj14),-1);
if(!x700.valid){
continue;
}
CheckValue<IkReal> x701 = IKatan2WithCheck(IkReal(new_r21),IkReal(((-1.0)*new_r20)),IKFAST_ATAN2_MAGTHRESH);
if(!x701.valid){
continue;
}
j15array[0]=((-1.5707963267949)+(((1.5707963267949)*(x700.value)))+(x701.value));
sj15array[0]=IKsin(j15array[0]);
cj15array[0]=IKcos(j15array[0]);
if( j15array[0] > IKPI )
{
    j15array[0]-=IK2PI;
}
else if( j15array[0] < -IKPI )
{    j15array[0]+=IK2PI;
}
j15valid[0] = true;
for(int ij15 = 0; ij15 < 1; ++ij15)
{
if( !j15valid[ij15] )
{
    continue;
}
_ij15[0] = ij15; _ij15[1] = -1;
for(int iij15 = ij15+1; iij15 < 1; ++iij15)
{
if( j15valid[iij15] && IKabs(cj15array[ij15]-cj15array[iij15]) < IKFAST_SOLUTION_THRESH && IKabs(sj15array[ij15]-sj15array[iij15]) < IKFAST_SOLUTION_THRESH )
{
    j15valid[iij15]=false; _ij15[1] = iij15; break; 
}
}
j15 = j15array[ij15]; cj15 = cj15array[ij15]; sj15 = sj15array[ij15];
{
IkReal evalcond[12];
IkReal x702=IKsin(j15);
IkReal x703=IKcos(j15);
IkReal x704=(cj13*cj14);
IkReal x705=((1.0)*sj14);
IkReal x706=(cj14*sj13);
IkReal x707=((1.0)*sj13);
IkReal x708=((1.0)*x703);
IkReal x709=((1.0)*x702);
evalcond[0]=(((sj14*x703))+new_r20);
evalcond[1]=((((-1.0)*x702*x705))+new_r21);
evalcond[2]=(((cj14*x702))+((cj13*new_r01))+((new_r11*sj13)));
evalcond[3]=(((cj13*new_r10))+(((-1.0)*x709))+(((-1.0)*new_r00*x707)));
evalcond[4]=(((cj13*new_r11))+(((-1.0)*x708))+(((-1.0)*new_r01*x707)));
evalcond[5]=(((x702*x704))+new_r01+((sj13*x703)));
evalcond[6]=(((cj13*new_r00))+(((-1.0)*cj14*x708))+((new_r10*sj13)));
evalcond[7]=((((-1.0)*x704*x708))+new_r00+((sj13*x702)));
evalcond[8]=(((x702*x706))+(((-1.0)*cj13*x708))+new_r11);
evalcond[9]=((((-1.0)*x706*x708))+(((-1.0)*cj13*x709))+new_r10);
evalcond[10]=((((-1.0)*new_r21*x705))+((new_r01*x704))+x702+((new_r11*x706)));
evalcond[11]=(((new_r00*x704))+(((-1.0)*new_r20*x705))+(((-1.0)*x708))+((new_r10*x706)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[8]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[9]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[10]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[11]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(8);
vinfos[0].jointtype = 17;
vinfos[0].foffset = j5;
vinfos[0].indices[0] = _ij5[0];
vinfos[0].indices[1] = _ij5[1];
vinfos[0].maxsolutions = _nj5;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j9;
vinfos[1].indices[0] = _ij9[0];
vinfos[1].indices[1] = _ij9[1];
vinfos[1].maxsolutions = _nj9;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j10;
vinfos[2].indices[0] = _ij10[0];
vinfos[2].indices[1] = _ij10[1];
vinfos[2].maxsolutions = _nj10;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j11;
vinfos[3].indices[0] = _ij11[0];
vinfos[3].indices[1] = _ij11[1];
vinfos[3].maxsolutions = _nj11;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j12;
vinfos[4].indices[0] = _ij12[0];
vinfos[4].indices[1] = _ij12[1];
vinfos[4].maxsolutions = _nj12;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j13;
vinfos[5].indices[0] = _ij13[0];
vinfos[5].indices[1] = _ij13[1];
vinfos[5].maxsolutions = _nj13;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j14;
vinfos[6].indices[0] = _ij14[0];
vinfos[6].indices[1] = _ij14[1];
vinfos[6].maxsolutions = _nj14;
vinfos[7].jointtype = 1;
vinfos[7].foffset = j15;
vinfos[7].indices[0] = _ij15[0];
vinfos[7].indices[1] = _ij15[1];
vinfos[7].maxsolutions = _nj15;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}
}
}

}

}
}
}
}
}static inline void polyroots3(IkReal rawcoeffs[3+1], IkReal rawroots[3], int& numroots)
{
    using std::complex;
    if( rawcoeffs[0] == 0 ) {
        // solve with one reduced degree
        polyroots2(&rawcoeffs[1], &rawroots[0], numroots);
        return;
    }
    IKFAST_ASSERT(rawcoeffs[0] != 0);
    const IkReal tol = 128.0*std::numeric_limits<IkReal>::epsilon();
    const IkReal tolsqrt = sqrt(std::numeric_limits<IkReal>::epsilon());
    complex<IkReal> coeffs[3];
    const int maxsteps = 110;
    for(int i = 0; i < 3; ++i) {
        coeffs[i] = complex<IkReal>(rawcoeffs[i+1]/rawcoeffs[0]);
    }
    complex<IkReal> roots[3];
    IkReal err[3];
    roots[0] = complex<IkReal>(1,0);
    roots[1] = complex<IkReal>(0.4,0.9); // any complex number not a root of unity works
    err[0] = 1.0;
    err[1] = 1.0;
    for(int i = 2; i < 3; ++i) {
        roots[i] = roots[i-1]*roots[1];
        err[i] = 1.0;
    }
    for(int step = 0; step < maxsteps; ++step) {
        bool changed = false;
        for(int i = 0; i < 3; ++i) {
            if ( err[i] >= tol ) {
                changed = true;
                // evaluate
                complex<IkReal> x = roots[i] + coeffs[0];
                for(int j = 1; j < 3; ++j) {
                    x = roots[i] * x + coeffs[j];
                }
                for(int j = 0; j < 3; ++j) {
                    if( i != j ) {
                        if( roots[i] != roots[j] ) {
                            x /= (roots[i] - roots[j]);
                        }
                    }
                }
                roots[i] -= x;
                err[i] = abs(x);
            }
        }
        if( !changed ) {
            break;
        }
    }

    numroots = 0;
    bool visited[3] = {false};
    for(int i = 0; i < 3; ++i) {
        if( !visited[i] ) {
            // might be a multiple root, in which case it will have more error than the other roots
            // find any neighboring roots, and take the average
            complex<IkReal> newroot=roots[i];
            int n = 1;
            for(int j = i+1; j < 3; ++j) {
                // care about error in real much more than imaginary
                if( abs(real(roots[i])-real(roots[j])) < tolsqrt && abs(imag(roots[i])-imag(roots[j])) < 0.002 ) {
                    newroot += roots[j];
                    n += 1;
                    visited[j] = true;
                }
            }
            if( n > 1 ) {
                newroot /= n;
            }
            // there are still cases where even the mean is not accurate enough, until a better multi-root algorithm is used, need to use the sqrt
            if( IKabs(imag(newroot)) < tolsqrt ) {
                rawroots[numroots++] = real(newroot);
            }
        }
    }
}
static inline void polyroots2(IkReal rawcoeffs[2+1], IkReal rawroots[2], int& numroots) {
    IkReal det = rawcoeffs[1]*rawcoeffs[1]-4*rawcoeffs[0]*rawcoeffs[2];
    if( det < 0 ) {
        numroots=0;
    }
    else if( det == 0 ) {
        rawroots[0] = -0.5*rawcoeffs[1]/rawcoeffs[0];
        numroots = 1;
    }
    else {
        det = IKsqrt(det);
        rawroots[0] = (-rawcoeffs[1]+det)/(2*rawcoeffs[0]);
        rawroots[1] = (-rawcoeffs[1]-det)/(2*rawcoeffs[0]);//rawcoeffs[2]/(rawcoeffs[0]*rawroots[0]);
        numroots = 2;
    }
}
static inline void polyroots5(IkReal rawcoeffs[5+1], IkReal rawroots[5], int& numroots)
{
    using std::complex;
    if( rawcoeffs[0] == 0 ) {
        // solve with one reduced degree
        polyroots4(&rawcoeffs[1], &rawroots[0], numroots);
        return;
    }
    IKFAST_ASSERT(rawcoeffs[0] != 0);
    const IkReal tol = 128.0*std::numeric_limits<IkReal>::epsilon();
    const IkReal tolsqrt = sqrt(std::numeric_limits<IkReal>::epsilon());
    complex<IkReal> coeffs[5];
    const int maxsteps = 110;
    for(int i = 0; i < 5; ++i) {
        coeffs[i] = complex<IkReal>(rawcoeffs[i+1]/rawcoeffs[0]);
    }
    complex<IkReal> roots[5];
    IkReal err[5];
    roots[0] = complex<IkReal>(1,0);
    roots[1] = complex<IkReal>(0.4,0.9); // any complex number not a root of unity works
    err[0] = 1.0;
    err[1] = 1.0;
    for(int i = 2; i < 5; ++i) {
        roots[i] = roots[i-1]*roots[1];
        err[i] = 1.0;
    }
    for(int step = 0; step < maxsteps; ++step) {
        bool changed = false;
        for(int i = 0; i < 5; ++i) {
            if ( err[i] >= tol ) {
                changed = true;
                // evaluate
                complex<IkReal> x = roots[i] + coeffs[0];
                for(int j = 1; j < 5; ++j) {
                    x = roots[i] * x + coeffs[j];
                }
                for(int j = 0; j < 5; ++j) {
                    if( i != j ) {
                        if( roots[i] != roots[j] ) {
                            x /= (roots[i] - roots[j]);
                        }
                    }
                }
                roots[i] -= x;
                err[i] = abs(x);
            }
        }
        if( !changed ) {
            break;
        }
    }

    numroots = 0;
    bool visited[5] = {false};
    for(int i = 0; i < 5; ++i) {
        if( !visited[i] ) {
            // might be a multiple root, in which case it will have more error than the other roots
            // find any neighboring roots, and take the average
            complex<IkReal> newroot=roots[i];
            int n = 1;
            for(int j = i+1; j < 5; ++j) {
                // care about error in real much more than imaginary
                if( abs(real(roots[i])-real(roots[j])) < tolsqrt && abs(imag(roots[i])-imag(roots[j])) < 0.002 ) {
                    newroot += roots[j];
                    n += 1;
                    visited[j] = true;
                }
            }
            if( n > 1 ) {
                newroot /= n;
            }
            // there are still cases where even the mean is not accurate enough, until a better multi-root algorithm is used, need to use the sqrt
            if( IKabs(imag(newroot)) < tolsqrt ) {
                rawroots[numroots++] = real(newroot);
            }
        }
    }
}
static inline void polyroots4(IkReal rawcoeffs[4+1], IkReal rawroots[4], int& numroots)
{
    using std::complex;
    if( rawcoeffs[0] == 0 ) {
        // solve with one reduced degree
        polyroots3(&rawcoeffs[1], &rawroots[0], numroots);
        return;
    }
    IKFAST_ASSERT(rawcoeffs[0] != 0);
    const IkReal tol = 128.0*std::numeric_limits<IkReal>::epsilon();
    const IkReal tolsqrt = sqrt(std::numeric_limits<IkReal>::epsilon());
    complex<IkReal> coeffs[4];
    const int maxsteps = 110;
    for(int i = 0; i < 4; ++i) {
        coeffs[i] = complex<IkReal>(rawcoeffs[i+1]/rawcoeffs[0]);
    }
    complex<IkReal> roots[4];
    IkReal err[4];
    roots[0] = complex<IkReal>(1,0);
    roots[1] = complex<IkReal>(0.4,0.9); // any complex number not a root of unity works
    err[0] = 1.0;
    err[1] = 1.0;
    for(int i = 2; i < 4; ++i) {
        roots[i] = roots[i-1]*roots[1];
        err[i] = 1.0;
    }
    for(int step = 0; step < maxsteps; ++step) {
        bool changed = false;
        for(int i = 0; i < 4; ++i) {
            if ( err[i] >= tol ) {
                changed = true;
                // evaluate
                complex<IkReal> x = roots[i] + coeffs[0];
                for(int j = 1; j < 4; ++j) {
                    x = roots[i] * x + coeffs[j];
                }
                for(int j = 0; j < 4; ++j) {
                    if( i != j ) {
                        if( roots[i] != roots[j] ) {
                            x /= (roots[i] - roots[j]);
                        }
                    }
                }
                roots[i] -= x;
                err[i] = abs(x);
            }
        }
        if( !changed ) {
            break;
        }
    }

    numroots = 0;
    bool visited[4] = {false};
    for(int i = 0; i < 4; ++i) {
        if( !visited[i] ) {
            // might be a multiple root, in which case it will have more error than the other roots
            // find any neighboring roots, and take the average
            complex<IkReal> newroot=roots[i];
            int n = 1;
            for(int j = i+1; j < 4; ++j) {
                // care about error in real much more than imaginary
                if( abs(real(roots[i])-real(roots[j])) < tolsqrt && abs(imag(roots[i])-imag(roots[j])) < 0.002 ) {
                    newroot += roots[j];
                    n += 1;
                    visited[j] = true;
                }
            }
            if( n > 1 ) {
                newroot /= n;
            }
            // there are still cases where even the mean is not accurate enough, until a better multi-root algorithm is used, need to use the sqrt
            if( IKabs(imag(newroot)) < tolsqrt ) {
                rawroots[numroots++] = real(newroot);
            }
        }
    }
}
static inline void polyroots7(IkReal rawcoeffs[7+1], IkReal rawroots[7], int& numroots)
{
    using std::complex;
    if( rawcoeffs[0] == 0 ) {
        // solve with one reduced degree
        polyroots6(&rawcoeffs[1], &rawroots[0], numroots);
        return;
    }
    IKFAST_ASSERT(rawcoeffs[0] != 0);
    const IkReal tol = 128.0*std::numeric_limits<IkReal>::epsilon();
    const IkReal tolsqrt = sqrt(std::numeric_limits<IkReal>::epsilon());
    complex<IkReal> coeffs[7];
    const int maxsteps = 110;
    for(int i = 0; i < 7; ++i) {
        coeffs[i] = complex<IkReal>(rawcoeffs[i+1]/rawcoeffs[0]);
    }
    complex<IkReal> roots[7];
    IkReal err[7];
    roots[0] = complex<IkReal>(1,0);
    roots[1] = complex<IkReal>(0.4,0.9); // any complex number not a root of unity works
    err[0] = 1.0;
    err[1] = 1.0;
    for(int i = 2; i < 7; ++i) {
        roots[i] = roots[i-1]*roots[1];
        err[i] = 1.0;
    }
    for(int step = 0; step < maxsteps; ++step) {
        bool changed = false;
        for(int i = 0; i < 7; ++i) {
            if ( err[i] >= tol ) {
                changed = true;
                // evaluate
                complex<IkReal> x = roots[i] + coeffs[0];
                for(int j = 1; j < 7; ++j) {
                    x = roots[i] * x + coeffs[j];
                }
                for(int j = 0; j < 7; ++j) {
                    if( i != j ) {
                        if( roots[i] != roots[j] ) {
                            x /= (roots[i] - roots[j]);
                        }
                    }
                }
                roots[i] -= x;
                err[i] = abs(x);
            }
        }
        if( !changed ) {
            break;
        }
    }

    numroots = 0;
    bool visited[7] = {false};
    for(int i = 0; i < 7; ++i) {
        if( !visited[i] ) {
            // might be a multiple root, in which case it will have more error than the other roots
            // find any neighboring roots, and take the average
            complex<IkReal> newroot=roots[i];
            int n = 1;
            for(int j = i+1; j < 7; ++j) {
                // care about error in real much more than imaginary
                if( abs(real(roots[i])-real(roots[j])) < tolsqrt && abs(imag(roots[i])-imag(roots[j])) < 0.002 ) {
                    newroot += roots[j];
                    n += 1;
                    visited[j] = true;
                }
            }
            if( n > 1 ) {
                newroot /= n;
            }
            // there are still cases where even the mean is not accurate enough, until a better multi-root algorithm is used, need to use the sqrt
            if( IKabs(imag(newroot)) < tolsqrt ) {
                rawroots[numroots++] = real(newroot);
            }
        }
    }
}
static inline void polyroots6(IkReal rawcoeffs[6+1], IkReal rawroots[6], int& numroots)
{
    using std::complex;
    if( rawcoeffs[0] == 0 ) {
        // solve with one reduced degree
        polyroots5(&rawcoeffs[1], &rawroots[0], numroots);
        return;
    }
    IKFAST_ASSERT(rawcoeffs[0] != 0);
    const IkReal tol = 128.0*std::numeric_limits<IkReal>::epsilon();
    const IkReal tolsqrt = sqrt(std::numeric_limits<IkReal>::epsilon());
    complex<IkReal> coeffs[6];
    const int maxsteps = 110;
    for(int i = 0; i < 6; ++i) {
        coeffs[i] = complex<IkReal>(rawcoeffs[i+1]/rawcoeffs[0]);
    }
    complex<IkReal> roots[6];
    IkReal err[6];
    roots[0] = complex<IkReal>(1,0);
    roots[1] = complex<IkReal>(0.4,0.9); // any complex number not a root of unity works
    err[0] = 1.0;
    err[1] = 1.0;
    for(int i = 2; i < 6; ++i) {
        roots[i] = roots[i-1]*roots[1];
        err[i] = 1.0;
    }
    for(int step = 0; step < maxsteps; ++step) {
        bool changed = false;
        for(int i = 0; i < 6; ++i) {
            if ( err[i] >= tol ) {
                changed = true;
                // evaluate
                complex<IkReal> x = roots[i] + coeffs[0];
                for(int j = 1; j < 6; ++j) {
                    x = roots[i] * x + coeffs[j];
                }
                for(int j = 0; j < 6; ++j) {
                    if( i != j ) {
                        if( roots[i] != roots[j] ) {
                            x /= (roots[i] - roots[j]);
                        }
                    }
                }
                roots[i] -= x;
                err[i] = abs(x);
            }
        }
        if( !changed ) {
            break;
        }
    }

    numroots = 0;
    bool visited[6] = {false};
    for(int i = 0; i < 6; ++i) {
        if( !visited[i] ) {
            // might be a multiple root, in which case it will have more error than the other roots
            // find any neighboring roots, and take the average
            complex<IkReal> newroot=roots[i];
            int n = 1;
            for(int j = i+1; j < 6; ++j) {
                // care about error in real much more than imaginary
                if( abs(real(roots[i])-real(roots[j])) < tolsqrt && abs(imag(roots[i])-imag(roots[j])) < 0.002 ) {
                    newroot += roots[j];
                    n += 1;
                    visited[j] = true;
                }
            }
            if( n > 1 ) {
                newroot /= n;
            }
            // there are still cases where even the mean is not accurate enough, until a better multi-root algorithm is used, need to use the sqrt
            if( IKabs(imag(newroot)) < tolsqrt ) {
                rawroots[numroots++] = real(newroot);
            }
        }
    }
}
static inline void polyroots8(IkReal rawcoeffs[8+1], IkReal rawroots[8], int& numroots)
{
    using std::complex;
    if( rawcoeffs[0] == 0 ) {
        // solve with one reduced degree
        polyroots7(&rawcoeffs[1], &rawroots[0], numroots);
        return;
    }
    IKFAST_ASSERT(rawcoeffs[0] != 0);
    const IkReal tol = 128.0*std::numeric_limits<IkReal>::epsilon();
    const IkReal tolsqrt = sqrt(std::numeric_limits<IkReal>::epsilon());
    complex<IkReal> coeffs[8];
    const int maxsteps = 110;
    for(int i = 0; i < 8; ++i) {
        coeffs[i] = complex<IkReal>(rawcoeffs[i+1]/rawcoeffs[0]);
    }
    complex<IkReal> roots[8];
    IkReal err[8];
    roots[0] = complex<IkReal>(1,0);
    roots[1] = complex<IkReal>(0.4,0.9); // any complex number not a root of unity works
    err[0] = 1.0;
    err[1] = 1.0;
    for(int i = 2; i < 8; ++i) {
        roots[i] = roots[i-1]*roots[1];
        err[i] = 1.0;
    }
    for(int step = 0; step < maxsteps; ++step) {
        bool changed = false;
        for(int i = 0; i < 8; ++i) {
            if ( err[i] >= tol ) {
                changed = true;
                // evaluate
                complex<IkReal> x = roots[i] + coeffs[0];
                for(int j = 1; j < 8; ++j) {
                    x = roots[i] * x + coeffs[j];
                }
                for(int j = 0; j < 8; ++j) {
                    if( i != j ) {
                        if( roots[i] != roots[j] ) {
                            x /= (roots[i] - roots[j]);
                        }
                    }
                }
                roots[i] -= x;
                err[i] = abs(x);
            }
        }
        if( !changed ) {
            break;
        }
    }

    numroots = 0;
    bool visited[8] = {false};
    for(int i = 0; i < 8; ++i) {
        if( !visited[i] ) {
            // might be a multiple root, in which case it will have more error than the other roots
            // find any neighboring roots, and take the average
            complex<IkReal> newroot=roots[i];
            int n = 1;
            for(int j = i+1; j < 8; ++j) {
                // care about error in real much more than imaginary
                if( abs(real(roots[i])-real(roots[j])) < tolsqrt && abs(imag(roots[i])-imag(roots[j])) < 0.002 ) {
                    newroot += roots[j];
                    n += 1;
                    visited[j] = true;
                }
            }
            if( n > 1 ) {
                newroot /= n;
            }
            // there are still cases where even the mean is not accurate enough, until a better multi-root algorithm is used, need to use the sqrt
            if( IKabs(imag(newroot)) < tolsqrt ) {
                rawroots[numroots++] = real(newroot);
            }
        }
    }
}
};


/// solves the inverse kinematics equations.
/// \param pfree is an array specifying the free joints of the chain.
IKFAST_API bool ComputeIk(const IkReal* eetrans, const IkReal* eerot, const IkReal* pfree, IkSolutionListBase<IkReal>& solutions) {
IKSolver solver;
return solver.ComputeIk(eetrans,eerot,pfree,solutions);
}

IKFAST_API bool ComputeIk2(const IkReal* eetrans, const IkReal* eerot, const IkReal* pfree, IkSolutionListBase<IkReal>& solutions, void* pOpenRAVEManip) {
IKSolver solver;
return solver.ComputeIk(eetrans,eerot,pfree,solutions);
}

IKFAST_API const char* GetKinematicsHash() { return "e388bf1e0ce289e8f856bdb57953dbed"; }

IKFAST_API const char* GetIkFastVersion() { return "0x1000004a"; }

#ifdef IKFAST_NAMESPACE
} // end namespace
#endif

#ifndef IKFAST_NO_MAIN
#include <stdio.h>
#include <stdlib.h>
#ifdef IKFAST_NAMESPACE
using namespace IKFAST_NAMESPACE;
#endif
int main(int argc, char** argv)
{
    if( argc != 12+GetNumFreeParameters()+1 ) {
        printf("\nUsage: ./ik r00 r01 r02 t0 r10 r11 r12 t1 r20 r21 r22 t2 free0 ...\n\n"
               "Returns the ik solutions given the transformation of the end effector specified by\n"
               "a 3x3 rotation R (rXX), and a 3x1 translation (tX).\n"
               "There are %d free parameters that have to be specified.\n\n",GetNumFreeParameters());
        return 1;
    }

    IkSolutionList<IkReal> solutions;
    std::vector<IkReal> vfree(GetNumFreeParameters());
    IkReal eerot[9],eetrans[3];
    eerot[0] = atof(argv[1]); eerot[1] = atof(argv[2]); eerot[2] = atof(argv[3]); eetrans[0] = atof(argv[4]);
    eerot[3] = atof(argv[5]); eerot[4] = atof(argv[6]); eerot[5] = atof(argv[7]); eetrans[1] = atof(argv[8]);
    eerot[6] = atof(argv[9]); eerot[7] = atof(argv[10]); eerot[8] = atof(argv[11]); eetrans[2] = atof(argv[12]);
    for(std::size_t i = 0; i < vfree.size(); ++i)
        vfree[i] = atof(argv[13+i]);
    bool bSuccess = ComputeIk(eetrans, eerot, vfree.size() > 0 ? &vfree[0] : NULL, solutions);

    if( !bSuccess ) {
        fprintf(stderr,"Failed to get ik solution\n");
        return -1;
    }

    printf("Found %d ik solutions:\n", (int)solutions.GetNumSolutions());
    std::vector<IkReal> solvalues(GetNumJoints());
    for(std::size_t i = 0; i < solutions.GetNumSolutions(); ++i) {
        const IkSolutionBase<IkReal>& sol = solutions.GetSolution(i);
        printf("sol%d (free=%d): ", (int)i, (int)sol.GetFree().size());
        std::vector<IkReal> vsolfree(sol.GetFree().size());
        sol.GetSolution(&solvalues[0],vsolfree.size()>0?&vsolfree[0]:NULL);
        for( std::size_t j = 0; j < solvalues.size(); ++j)
            printf("%.15f, ", solvalues[j]);
        printf("\n");
    }
    return 0;
}

#endif


//// START
static PyObject *arm_ik(PyObject *self, PyObject *args) {
    IkSolutionList<IkReal> solutions;

    // Should only have two free parameters (torso and upper arm)
    std::vector<IkReal> vfree(GetNumFreeParameters());
    IkReal eerot[9], eetrans[3];

    // First list if 3x3 rotation matrix, easier to compute in Python.
    // Next list is [x, y, z] translation matrix.
    // Last list is free joints (torso and upper arm roll (in that order)).
    PyObject *rotList; // 3x3 rotation matrix
    PyObject *transList; // [x,y,z]
    PyObject *freeList; // [torso, upper arm]

    if(!PyArg_ParseTuple(args, "O!O!O!", &PyList_Type, &rotList, &PyList_Type, &transList, &PyList_Type, &freeList)) {
        return NULL;
    }

    for(std::size_t i = 0; i < 3; ++i) {
        eetrans[i] = PyFloat_AsDouble(PyList_GetItem(transList, i));

        PyObject* rowList = PyList_GetItem(rotList, i);
        for( std::size_t j = 0; j < 3; ++j) {
            eerot[3*i + j] = PyFloat_AsDouble(PyList_GetItem(rowList, j));
        }
    }

    for(int i = 0; i < GetNumFreeParameters(); ++i) {
        vfree[i] = PyFloat_AsDouble(PyList_GetItem(freeList, i));
    }

    // I don't understand why we pass &vfree[0] instead of just vfree.
    // Clearly ComputeIk takes an IkReal* parameter there, but it treats that parameter like an array.
    // It probably does work because the computeIk call in main specifically makes this change.
    // So it's hopefully right, and I don't understand because I don't know C++.
    bool bSuccess = ComputeIk(eetrans, eerot, &vfree[0], solutions);

    if (!bSuccess) {
        return Py_BuildValue(""); // Equivalent to returning None
    }

    // There are 8 joints in each solution (torso + 7 arm joints).
    std::vector<IkReal> solvalues(GetNumJoints());
    PyObject *solutionList = PyList_New(solutions.GetNumSolutions());

    for(std::size_t i = 0; i < solutions.GetNumSolutions(); ++i) {
        const IkSolutionBase<IkReal>& sol = solutions.GetSolution(i);
        std::vector<IkReal> vsolfree(sol.GetFree().size());
        sol.GetSolution(&solvalues[0],vsolfree.size()>0?&vsolfree[0]:NULL);

        PyObject *individualSolution = PyList_New(GetNumJoints());
        for( std::size_t j = 0; j < solvalues.size(); ++j) {
            // I think IkReal is just a wrapper for double. So this should work.
            PyList_SetItem(individualSolution, j, PyFloat_FromDouble(solvalues[j]));
        }
        PyList_SetItem(solutionList, i, individualSolution);
    }
    return solutionList;
}

static PyObject *arm_fk(PyObject *self, PyObject *args) {
    std::vector<IkReal> joints(8);
    IkReal eerot[9], eetrans[3];

    // First double is torso height. Next 7 doubles are arm joints
    PyObject *jointList;
    if(!PyArg_ParseTuple(args, "O!", &PyList_Type, &jointList)) {
        return NULL;
    }

    for(std::size_t i = 0; i < 8; ++i){
        joints[i] = PyFloat_AsDouble(PyList_GetItem(jointList, i));
    }

    ComputeFk(&joints[0], eetrans, eerot);

    PyObject *pose = PyList_New(2);
    PyObject *pos = PyList_New(3);
    PyObject *rot = PyList_New(3);

    for(std::size_t i = 0; i < 3; ++i) {
        PyList_SetItem(pos, i, PyFloat_FromDouble(eetrans[i]));

        PyObject *row = PyList_New(3);
        for( std::size_t j = 0; j < 3; ++j) {
            PyList_SetItem(row, j, PyFloat_FromDouble(eerot[3*i + j]));
        }
        PyList_SetItem(rot, i, row);
    }

    PyList_SetItem(pose, 0, pos);
    PyList_SetItem(pose, 1, rot);

    return pose;
}

static PyMethodDef ikfast_fetchMethods[] = {
    {"get_ik", arm_ik, METH_VARARGS, "Compute ik solutions using ikfast."},
    {"get_fk", arm_fk, METH_VARARGS, "Compute fk solutions using ikfast."},
    // TODO: deprecate
    {"armIK", arm_ik, METH_VARARGS, "Compute IK for the PR2's arm."},
    {"armFK", arm_fk, METH_VARARGS, "Compute FK for the PR2's arm."},
    {NULL, NULL, 0, NULL} // Not sure why/if this is needed. It shows up in the examples though(something about Sentinel).
};

// OLD WAY
/*#if PY_MAJOR_VERSION >= 3

//// This is the python3.4 version.
static struct PyModuleDef ikArmModule = {
    PyModuleDef_HEAD_INIT,
    "ikArm",
    NULL,
    -1,
    ikArmMethods
};

PyMODINIT_FUNC PyInit_ikArm(void) {
    return PyModule_Create(&ikArmModule);
}

#else

//// This is the python2.7 version.
PyMODINIT_FUNC initikArm(void) {
    (void) Py_InitModule("ikArm", ikArmMethods);
}

#endif*/

// NEW WAY
#if PY_MAJOR_VERSION >= 3

static struct PyModuleDef ikfast_fetchModule = {
    PyModuleDef_HEAD_INIT,
    "ikfast_fetch",   /* name of module */
    NULL, /* module documentation, may be NULL */
    -1,       /* size of per-interpreter state of the module,
                 or -1 if the module keeps state in global variables. */
    ikfast_fetchMethods
};

#define INITERROR return NULL

PyMODINIT_FUNC
PyInit_ikfast_fetch(void)

#else // PY_MAJOR_VERSION < 3
#define INITERROR return

PyMODINIT_FUNC
initikfast_fetch(void)
#endif
{
#if PY_MAJOR_VERSION >= 3
    PyObject *module = PyModule_Create(&ikfast_fetchModule);
#else
    PyObject *module = Py_InitModule("ikfast_fetch", ikfast_fetchMethods);
#endif

if (module == NULL)
    INITERROR;

#if PY_MAJOR_VERSION >= 3
    return module;
#endif
}

//// END